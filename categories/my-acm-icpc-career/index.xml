<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>My ACM-ICPC Career on I'm OWenT</title><link>//owent.net/categories/my-acm-icpc-career.html</link><description>Recent content in My ACM-ICPC Career on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Mon, 28 Apr 2014 21:10:46 +0000</lastBuildDate><atom:link href="//owent.net/categories/my-acm-icpc-career/index.xml" rel="self" type="application/rss+xml"/><item><title>[ACM] HDU 1006 解题报告</title><link>//owent.net/2014/1046.html</link><pubDate>Mon, 28 Apr 2014 21:10:46 +0000</pubDate><guid>//owent.net/2014/1046.html</guid><description>&lt;p>偶尔写写ACM水题还是挺好玩的。(好吧其实是老婆求助我才看滴)&lt;/p>
&lt;p>题目链接：&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=1006">http://acm.hdu.edu.cn/showproblem.php?pid=1006&lt;/a>&lt;/p>
&lt;p>一开始看到这题的时候，感觉一天24小时&lt;em>60分钟&lt;/em>60秒。把每一秒的最小指针角度记下来再搞个排序。&lt;/p></description></item><item><title>不知道是哪一年的腾讯马拉松题目 照片评级 解题报告</title><link>//owent.net/2013/930.html</link><pubDate>Fri, 25 Oct 2013 15:45:05 +0000</pubDate><guid>//owent.net/2013/930.html</guid><description>&lt;p>在某个神奇的下午，收到一个垃圾邮件（至少被邮件系统当成了垃圾邮件）。&lt;/p>
&lt;p>结果就一不小心看到了这个充满回忆的ACM模式竞赛，还有咱腾讯的，就忍不住看了一下。&lt;/p></description></item><item><title>POJ 2192 Zipper HDU 2059 龟兔赛跑</title><link>//owent.net/2013/861.html</link><pubDate>Mon, 15 Jul 2013 18:39:41 +0000</pubDate><guid>//owent.net/2013/861.html</guid><description>&lt;p>今天心情好，刷了两到ACM水题，思路很简单都在注释里，所以直接贴代码:&lt;/p>
&lt;pre>&lt;code class="language-cpp">/**
 * @file 龟兔赛跑.cpp
 * @brief 龟兔赛跑 AC代码 (DP)
 * DP方程式: [到第i的充电站的最短时间] = [到最后一个冲了电的充电站的最短时间] + [那个充电站到第i个充电站的时间]
 *
 * @link http://acm.hdu.edu.cn/showproblem.php?pid=2059
 * @version 1.0
 * @author OWenT
 * @date 2013.07.15
 *
 * @history
 *
 *
 */

#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;numeric&amp;gt;

int pn[128];
double dp[128]; /** dp[i] 表示 到第i个充电站的最小时间(0为开始位置，n+1为终点) **/

double calc_charge_time(int dis, int v1, int v2, int c) {
 if (dis &amp;lt;= c)
 return 1.0 * dis / v1;

 return 1.0 * c / v1 + 1.0 * (dis - c) / v2;
}

int main(int argc, char* argv[]) {
 using namespace std;

 double eps = std::numeric_limits&amp;lt;double&amp;gt;::epsilon();
 int l, n, c, t, vr, v1, v2;

 while(cin&amp;gt;&amp;gt; l) {
 cin &amp;gt;&amp;gt; n&amp;gt;&amp;gt; c&amp;gt;&amp;gt; t&amp;gt;&amp;gt; vr&amp;gt;&amp;gt; v1&amp;gt;&amp;gt; v2;

 pn[0] = 0; /** 0为起点 **/
 for (int i = 1; i &amp;lt;= n; ++ i) {
 cin&amp;gt;&amp;gt; pn[i];
 }
 pn[n + 1] = l; /** n+1为终点 **/

 memset(dp, 0, sizeof(dp));
 for(int i = 0; i &amp;lt;= n + 1; ++ i) {
 dp[i] = calc_charge_time(pn[i] - pn[0], v1, v2, c);
 }

 for(int i = 1; i &amp;lt;= n + 1; ++ i) {
 for(int j = 0; j &amp;lt; i; ++ j) {
 double tc = calc_charge_time(pn[i] - pn[j], v1, v2, c) + t + dp[j];
 dp[i] = std::min(tc, dp[i]);
 }
 
 }

 double rt = 1.0 * l / vr, tt = dp[n + 1];

 if (tt &amp;lt; rt)
 puts(&amp;quot;What a pity rabbit!&amp;quot;);
 else
 puts(&amp;quot;Good job,rabbit!&amp;quot;);
 }

 return 0;
}

/**
 * @file Zipper.cpp
 * @brief Zipper AC代码 (DP)
 * @link http://poj.org/problem?id=2192
 * DP方程式: [A串消耗个数i][B串消耗个数j] = min{[A串消耗个数i - 1][B串消耗个数j]|[A串消耗个数i][B串消耗个数j + 1]}
 * 以上分支选取条件是 A或B的新选用字符和C串新字符匹配
 *
 * @version 1.0
 * @author OWenT
 * @date 2013.07.15
 *
 * @history
 *
 *
 */

#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;numeric&amp;gt;


char strA[256], strB[256], strC[512];
int dp[256][256]; /** dp[i][j] = k 表示A消耗了i个字符，B消耗了j个字符，拼成的C串消耗了k个字符（其实就是i+j） **/

int main(int argc, char* argv[]) {
 using namespace std;
 int s, n;

 scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
 for( s = 0; s &amp;lt; n; ++ s) {
 scanf(&amp;quot;%s %s %s&amp;quot;, strA, strB, strC);
 int lenA = strlen(strA);
 int lenB = strlen(strB);
 int lenC = strlen(strC);
 bool bFlag = false;

 if ( lenC != lenA + lenB ) {
 printf(&amp;quot;Data set %d: no\n&amp;quot;, s + 1);
 continue;
 }

 memset(dp, 0, sizeof(dp));

 if (strA[0] == strC[0])
 dp[1][0] = 1;
 if (strB[0] == strC[0])
 dp[0][1] = 1;

 for (int i = 0; i &amp;lt;= lenA; ++ i) {
 for (int j = 0; j &amp;lt;= lenB; ++ j) {
 if (0 == dp[i][j])
 continue;

 int ri = i + 1, rj = j + 1;

 if (strA[i] == strC[dp[i][j]]) {
 dp[ri][j] = dp[i][j] + 1;
 if (ri + j == lenC)
 bFlag = true;
 }

 if (strB[j] == strC[dp[i][j]]) {
 dp[i][rj] = dp[i][j] + 1;
 if (i + rj == lenC)
 bFlag = true;
 }
 }
 }

 printf(&amp;quot;Data set %d: %s\n&amp;quot;, s + 1, bFlag? &amp;quot;yes&amp;quot;: &amp;quot;no&amp;quot;);
 }

 return 0;
}

&lt;/code>&lt;/pre></description></item><item><title>AC自动机</title><link>//owent.net/2012/652.html</link><pubDate>Tue, 28 Aug 2012 20:10:27 +0000</pubDate><guid>//owent.net/2012/652.html</guid><description>&lt;p>某个课程的作业，促使我来看看这玩意。&lt;/p>
&lt;p>整个程序的算法思想是看别人的ACM的blog看懂的，感觉确实和KMP很像。但是代码呢就比较工程化一点。顺便回忆了一把ACM的感觉。&lt;/p></description></item><item><title>忆往昔ECUST的ACM时代</title><link>//owent.net/2012/587.html</link><pubDate>Sat, 07 Apr 2012 10:37:44 +0000</pubDate><guid>//owent.net/2012/587.html</guid><description>&lt;p>&lt;strong>最初是接受了lpld的邀请来写这篇大总结。我没有LHH华丽的文笔，就只能随便写写了。回想起来，ACM应该是我在大学期间参加的最有意义并且收获最大的活动了。&lt;/strong>&lt;/p></description></item><item><title>2011 Google Code Jam 小记</title><link>//owent.net/2011/416.html</link><pubDate>Sun, 22 May 2011 07:46:12 +0000</pubDate><guid>//owent.net/2011/416.html</guid><description>&lt;p>好久没写这种类型的代码，感觉真是退步了很多。
这是我第一次参加Google Code Jam，以前有过报名可是没有做过。
我发现Google Code Jam的题目使用经典算法的几乎没有，都是模拟或者数学题（起码我目前做过的几题是这样）&lt;/p></description></item><item><title>线段树相关问题 (引用 PKU POJ题目) 整理</title><link>//owent.net/2010/8.html</link><pubDate>Tue, 12 Oct 2010 16:45:11 +0000</pubDate><guid>//owent.net/2010/8.html</guid><description>&lt;h2 id="1rangeminimummaximum-query问题计算单调区间内出现最多少的次数">1.RangeMinimum、Maximum Query问题（计算单调区间内出现最多（少）的次数）&lt;/h2>
&lt;p>对元素的起点做离散化，再把离散化后的位置作为线段树的[l, r),记录次数为t.&lt;/p>
&lt;p>对输入区间a, b:&lt;/p></description></item><item><title>POJ PKU 1474 Video Surveillance 解题报告</title><link>//owent.net/2010/10.html</link><pubDate>Mon, 04 Oct 2010 11:49:56 +0000</pubDate><guid>//owent.net/2010/10.html</guid><description>&lt;p>题目链接：&lt;a href="http://poj.org/problem?id=1474">http://poj.org/problem?id=1474&lt;/a>&lt;/p>
&lt;p>写这题的目的是看完了zzy的论文，写了半平面交，验证一下正确性，结果发现我写的问题还是很多的。&lt;/p>
&lt;p>题目大意是问能不能放一个摄像机，使得摄像机能看到整个多边形内部。&lt;/p></description></item><item><title>ACM 计算几何 个人模板</title><link>//owent.net/2010/11.html</link><pubDate>Mon, 04 Oct 2010 11:19:02 +0000</pubDate><guid>//owent.net/2010/11.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * 二维ACM计算几何模板
 * 注意变量类型更改和EPS
 * #include &amp;lt;cmath&amp;gt;
 * #include &amp;lt;cstdio&amp;gt;
 * By OWenT
 */

const double eps = 1e-8;
const double pi = std::acos(-1.0);
//点
class point
{
public:
 double x, y;
 point(){};
 point(double x, double y):x(x),y(y){};

 static int xmult(const point &amp;amp;ps, const point &amp;amp;pe, const point &amp;amp;po)
 {
 return (ps.x - po.x) * (pe.y - po.y) - (pe.x - po.x) * (ps.y - po.y);
 }

 //相对原点的差乘结果，参数：点[_Off]
 //即由原点和这两个点组成的平行四边形面积
 double operator *(const point &amp;amp;_Off) const
 {
 return x * _Off.y - y * _Off.x;
 }
 //相对偏移
 point operator - (const point &amp;amp;_Off) const
 {
 return point(x - _Off.x, y - _Off.y);
 }
 //点位置相同(double类型)
 bool operator == (const point &amp;amp;_Off) const
 {
 return std::fabs(_Off.x - x) &amp;lt; eps &amp;amp;&amp;amp; std::fabs(_Off.y - y) &amp;lt; eps;
 }
 //点位置不同(double类型)
 bool operator != (const point &amp;amp;_Off) const
 {
 return ((*this) == _Off) == false;
 }
 //两点间距离的平方
 double dis2(const point &amp;amp;_Off) const
 {
 return (x - _Off.x) * (x - _Off.x) + (y - _Off.y) * (y - _Off.y);
 }
 //两点间距离
 double dis(const point &amp;amp;_Off) const
 {
 return std::sqrt((x - _Off.x) * (x - _Off.x) + (y - _Off.y) * (y - _Off.y));
 }
};

//两点表示的向量
class pVector
{
public:
 point s, e;//两点表示，起点[s]，终点[e]
 double a, b, c;//一般式,ax+by+c=0

 pVector(){}
 pVector(const point &amp;amp;s, const point &amp;amp;e):s(s),e(e){}

 //向量与点的叉乘,参数：点[_Off]
 //[点相对向量位置判断]
 double operator *(const point &amp;amp;_Off) const
 {
 return (_Off.y - s.y) * (e.x - s.x) - (_Off.x - s.x) * (e.y - s.y);
 }
 //向量与向量的叉乘,参数：向量[_Off]
 double operator *(const pVector &amp;amp;_Off) const
 {
 return (e.x - s.x) * (_Off.e.y - _Off.s.y) - (e.y - s.y) * (_Off.e.x - _Off.s.x);
 }
 //从两点表示转换为一般表示
 bool pton()
 {
 a = s.y - e.y;
 b = e.x - s.x;
 c = s.x * e.y - s.y * e.x;
 return true;
 }

 //-----------点和直线（向量）-----------
 //点在向量左边（右边的小于号改成大于号即可,在对应直线上则加上=号）
 //参数：点[_Off],向量[_Ori]
 friend bool operator&amp;lt;(const point &amp;amp;_Off, const pVector &amp;amp;_Ori)
 {
 return (_Ori.e.y - _Ori.s.y) * (_Off.x - _Ori.s.x)
 &amp;lt; (_Off.y - _Ori.s.y) * (_Ori.e.x - _Ori.s.x);
 }

 //点在直线上,参数：点[_Off]
 bool lhas(const point &amp;amp;_Off) const
 {
 return std::fabs((*this) * _Off) &amp;lt; eps;
 }
 //点在线段上,参数：点[_Off]
 bool shas(const point &amp;amp;_Off) const
 {
 return lhas(_Off)
 &amp;amp;&amp;amp; _Off.x - std::min(s.x, e.x) &amp;gt; -eps &amp;amp;&amp;amp; _Off.x - std::max(s.x, e.x) &amp;lt; eps
 &amp;amp;&amp;amp; _Off.y - std::min(s.y, e.y) &amp;gt; -eps &amp;amp;&amp;amp; _Off.y - std::max(s.y, e.y) &amp;lt; eps;
 }

 //点到直线/线段的距离
 //参数： 点[_Off], 是否是线段[isSegment](默认为直线)
 double dis(const point &amp;amp;_Off, bool isSegment = false)
 {
 //化为一般式
 pton();

 //到直线垂足的距离
 double td = (a * _Off.x + b * _Off.y + c) / sqrt(a * a + b * b);

 //如果是线段判断垂足
 if(isSegment)
 {
 double xp = (b * b * _Off.x - a * b * _Off.y - a * c) / ( a * a + b * b);
 double yp = (-a * b * _Off.x + a * a * _Off.y - b * c) / (a * a + b * b);
 double xb = std::max(s.x, e.x);
 double yb = std::max(s.y, e.y);
 double xs = s.x + e.x - xb;
 double ys = s.y + e.y - yb;
 if(xp &amp;gt; xb + eps || xp &amp;lt; xs - eps || yp &amp;gt; yb + eps || yp &amp;lt; ys - eps)
 td = std::min(_Off.dis(s), _Off.dis(e));
 }

 return fabs(td);
 }

 //关于直线对称的点
 point mirror(const point &amp;amp;_Off) const
 {
 //注意先转为一般式
 point ret;
 double d = a * a + b * b;
 ret.x = (b * b * _Off.x - a * a * _Off.x - 2 * a * b * _Off.y - 2 * a * c) / d;
 ret.y = (a * a * _Off.y - b * b * _Off.y - 2 * a * b * _Off.x - 2 * b * c) / d;
 return ret;
 }
 //计算两点的中垂线
 static pVector ppline(const point &amp;amp;_a, const point &amp;amp;_b)
 {
 pVector ret;
 ret.s.x = (_a.x + _b.x) / 2;
 ret.s.y = (_a.y + _b.y) / 2;
 //一般式
 ret.a = _b.x - _a.x;
 ret.b = _b.y - _a.y;
 ret.c = (_a.y - _b.y) * ret.s.y + (_a.x - _b.x) * ret.s.x;
 //两点式
 if(std::fabs(ret.a) &amp;gt; eps)
 {
 ret.e.y = 0.0;
 ret.e.x = - ret.c / ret.a;
 if(ret.e == ret. s)
 {
 ret.e.y = 1e10;
 ret.e.x = - (ret.c - ret.b * ret.e.y) / ret.a;
 }
 }
 else
 {
 ret.e.x = 0.0;
 ret.e.y = - ret.c / ret.b;
 if(ret.e == ret. s)
 {
 ret.e.x = 1e10;
 ret.e.y = - (ret.c - ret.a * ret.e.x) / ret.b;
 }
 }
 return ret;
 }

 //------------直线和直线（向量）-------------
 //直线重合,参数：直线向量[_Off]
 bool equal(const pVector &amp;amp;_Off) const
 {
 return lhas(_Off.e) &amp;amp;&amp;amp; lhas(_Off.s);
 }
 //直线平行，参数：直线向量[_Off]
 bool parallel(const pVector &amp;amp;_Off) const
 {
 return std::fabs((*this) * _Off) &amp;lt; eps;
 }
 //两直线交点，参数：目标直线[_Off]
 point crossLPt(pVector _Off)
 {
 //注意先判断平行和重合
 point ret = s;
 double t = ((s.x - _Off.s.x) * (_Off.s.y - _Off.e.y) - (s.y - _Off.s.y) * (_Off.s.x - _Off.e.x))
 / ((s.x - e.x) * (_Off.s.y - _Off.e.y) - (s.y - e.y) * (_Off.s.x - _Off.e.x));
 ret.x += (e.x - s.x) * t;
 ret.y += (e.y - s.y) * t;
 return ret;
 }

 //------------线段和直线（向量）----------
 //线段和直线交
 //参数：线段[_Off]
 bool crossSL(const pVector &amp;amp;_Off) const
 {
 double rs = (*this) * _Off.s;
 double re = (*this) * _Off.e;
 return rs * re &amp;lt; eps;
 }

 //------------线段和线段（向量）----------
 //判断线段是否相交(注意添加eps)，参数：线段[_Off]
 bool isCrossSS(const pVector &amp;amp;_Off) const
 {
 //1.快速排斥试验判断以两条线段为对角线的两个矩形是否相交
 //2.跨立试验（等于0时端点重合）
 return (
 (std::max(s.x, e.x) &amp;gt;= std::min(_Off.s.x, _Off.e.x)) &amp;amp;&amp;amp;
 (std::max(_Off.s.x, _Off.e.x) &amp;gt;= std::min(s.x, e.x)) &amp;amp;&amp;amp;
 (std::max(s.y, e.y) &amp;gt;= std::min(_Off.s.y, _Off.e.y)) &amp;amp;&amp;amp;
 (std::max(_Off.s.y, _Off.e.y) &amp;gt;= std::min(s.y, e.y)) &amp;amp;&amp;amp;
 ((pVector(_Off.s, s) * _Off) * (_Off * pVector(_Off.s, e)) &amp;gt;= 0.0) &amp;amp;&amp;amp;
 ((pVector(s, _Off.s) * (*this)) * ((*this) * pVector(s, _Off.e)) &amp;gt;= 0.0)
 );
 }
};

class polygon
{
public:
 const static long maxpn = 100;
 point pt[maxpn];//点（顺时针或逆时针）
 long n;//点的个数

 point&amp;amp; operator[](int _p)
 {
 return pt[_p];
 }

 //求多边形面积，多边形内点必须顺时针或逆时针
 double area() const
 {
 double ans = 0.0;
 int i;
 for(i = 0; i &amp;lt; n; i ++)
 {
 int nt = (i + 1) % n;
 ans += pt[i].x * pt[nt].y - pt[nt].x * pt[i].y;
 }
 return std::fabs(ans / 2.0);
 }
 //求多边形重心，多边形内点必须顺时针或逆时针
 point gravity() const
 {
 point ans;
 ans.x = ans.y = 0.0;
 int i;
 double area = 0.0;
 for(i = 0; i &amp;lt; n; i ++)
 {
 int nt = (i + 1) % n;
 double tp = pt[i].x * pt[nt].y - pt[nt].x * pt[i].y;
 area += tp;
 ans.x += tp * (pt[i].x + pt[nt].x);
 ans.y += tp * (pt[i].y + pt[nt].y);
 }
 ans.x /= 3 * area;
 ans.y /= 3 * area;
 return ans;
 }
 //判断点在凸多边形内，参数：点[_Off]
 bool chas(const point &amp;amp;_Off) const
 {
 double tp = 0, np;
 int i;
 for(i = 0; i &amp;lt; n; i ++)
 {
 np = pVector(pt[i], pt[(i + 1) % n]) * _Off;
 if(tp * np &amp;lt; -eps)
 return false;
 tp = (std::fabs(np) &amp;gt; eps)?np: tp;
 }
 return true;
 }
 //判断点是否在任意多边形内[射线法]，O(n)
 bool ahas(const point &amp;amp;_Off) const
 {
 int ret = 0;
 double infv = 1e-10;//坐标系最大范围
 pVector l = pVector(_Off, point( -infv ,_Off.y));
 for(int i = 0; i &amp;lt; n; i ++)
 {
 pVector ln = pVector(pt[i], pt[(i + 1) % n]);
 if(fabs(ln.s.y - ln.e.y) &amp;gt; eps)
 {
 point tp = (ln.s.y &amp;gt; ln.e.y)? ln.s: ln.e;
 if(fabs(tp.y - _Off.y) &amp;lt; eps &amp;amp;&amp;amp; tp.x &amp;lt; _Off.x + eps)
 ret ++;
 }
 else if(ln.isCrossSS(l))
 ret ++;
 }
 return (ret % 2 == 1);
 }
 //凸多边形被直线分割,参数：直线[_Off]
 polygon split(pVector _Off)
 {
 //注意确保多边形能被分割
 polygon ret;
 point spt[2];
 double tp = 0.0, np;
 bool flag = true;
 int i, pn = 0, spn = 0;
 for(i = 0; i &amp;lt; n; i ++)
 {
 if(flag)
 pt[pn ++] = pt[i];
 else
 ret.pt[ret.n ++] = pt[i];
 np = _Off * pt[(i + 1) % n];
 if(tp * np &amp;lt; -eps)
 {
 flag = !flag;
 spt[spn ++] = _Off.crossLPt(pVector(pt[i], pt[(i + 1) % n]));
 }
 tp = (std::fabs(np) &amp;gt; eps)?np: tp;
 }
 ret.pt[ret.n ++] = spt[0];
 ret.pt[ret.n ++] = spt[1];
 n = pn;
 return ret;
 }

 //-------------凸包-------------
 //Graham扫描法，复杂度O(nlg(n)),结果为逆时针
 //#include &amp;lt;algorithm&amp;gt;
 static bool graham_cmp(const point &amp;amp;l, const point &amp;amp;r)//凸包排序函数
 {
 return l.y &amp;lt; r.y || (l.y == r.y &amp;amp;&amp;amp; l.x &amp;lt; r.x);
 }
 polygon&amp;amp; graham(point _p[], int _n)
 {
 int i, len;
 std::sort(_p, _p + _n, polygon::graham_cmp);
 n = 1;
 pt[0] = _p[0], pt[1] = _p[1];
 for(i = 2; i &amp;lt; _n; i ++)
 {
 while(n &amp;amp;&amp;amp; point::xmult(_p[i], pt[n], pt[n - 1]) &amp;gt;= 0)
 n --;
 pt[++ n] = _p[i];
 }
 len = n;
 pt[++ n] = _p[_n - 2];
 for(i = _n - 3; i &amp;gt;= 0; i --)
 {
 while(n != len &amp;amp;&amp;amp; point::xmult(_p[i], pt[n], pt[n - 1]) &amp;gt;= 0)
 n --;
 pt[++ n] = _p[i];
 }
 return (*this);
 }

 //凸包旋转卡壳(注意点必须顺时针或逆时针排列)
 //返回值凸包直径的平方（最远两点距离的平方）
 double rotating_calipers()
 {
 int i = 1;
 double ret = 0.0;
 pt[n] = pt[0];
 for(int j = 0; j &amp;lt; n; j ++)
 {
 while(fabs(point::xmult(pt[j], pt[j + 1], pt[i + 1])) &amp;gt; fabs(point::xmult(pt[j], pt[j + 1], pt[i])) + eps)
 i = (i + 1) % n;
 //pt[i]和pt[j],pt[i + 1]和pt[j + 1]可能是对踵点
 ret = std::max(ret, std::max(pt[i].dis(pt[j]), pt[i + 1].dis(pt[j + 1])));
 }
 return ret;
 }

 //凸包旋转卡壳(注意点必须逆时针排列)
 //返回值两凸包的最短距离
 double rotating_calipers(polygon &amp;amp;_Off)
 {
 int i = 0;
 double ret = 1e10;//inf
 pt[n] = pt[0];
 _Off.pt[_Off.n] = _Off.pt[0];
 //注意凸包必须逆时针排列且pt[0]是左下角点的位置
 while(_Off.pt[i + 1].y &amp;gt; _Off.pt[i].y)
 i = (i + 1) % _Off.n;
 for(int j = 0; j &amp;lt; n; j ++)
 {
 double tp;
 //逆时针时为 &amp;gt;,顺时针则相反
 while((tp = point::xmult(pt[j], pt[j + 1], _Off.pt[i + 1]) - point::xmult( pt[j], pt[j + 1], _Off.pt[i])) &amp;gt; eps)
 i = (i + 1) % _Off.n;
 //(pt[i],pt[i+1])和(_Off.pt[j],_Off.pt[j + 1])可能是最近线段
 ret = std::min(ret, pVector(pt[j], pt[j + 1]).dis(_Off.pt[i], true));
 ret = std::min(ret, pVector(_Off.pt[i], _Off.pt[i + 1]).dis(pt[j + 1], true));
 if(tp &amp;gt; -eps)//如果不考虑TLE问题最好不要加这个判断
 {
 ret = std::min(ret, pVector(pt[j], pt[j + 1]).dis(_Off.pt[i + 1], true));
 ret = std::min(ret, pVector(_Off.pt[i], _Off.pt[i + 1]).dis(pt[j], true));
 }
 }
 return ret;
 }

 //-----------半平面交-------------
 //复杂度:O(nlog2(n))
 //#include &amp;lt;algorithm&amp;gt;
 //半平面计算极角函数[如果考虑效率可以用成员变量记录]
 static double hpc_pa(const pVector &amp;amp;_Off)
 {
 return atan2(_Off.e.y - _Off.s.y, _Off.e.x - _Off.s.x);
 }
 //半平面交排序函数[优先顺序: 1.极角 2.前面的直线在后面的左边]
 static bool hpc_cmp(const pVector &amp;amp;l, const pVector &amp;amp;r)
 {
 double lp = hpc_pa(l), rp = hpc_pa(r);
 if(fabs(lp - rp) &amp;gt; eps)
 return lp &amp;lt; rp;
 return point::xmult(l.s, r.e, r.s) &amp;lt; 0.0;
 }
 //用于计算的双端队列
 pVector dequeue[maxpn];
 //获取半平面交的多边形（多边形的核）
 //参数：向量集合[l]，向量数量[ln];(半平面方向在向量左边）
 //函数运行后如果n[即返回多边形的点数量]为0则不存在半平面交的多边形（不存在区域或区域面积无穷大）
 polygon&amp;amp; halfPanelCross(pVector _Off[], int ln)
 {
 int i, tn;
 n = 0;
 std::sort(_Off, _Off + ln, hpc_cmp);
 //平面在向量左边的筛选
 for(i = tn = 1; i &amp;lt; ln; i ++)
 if(fabs(hpc_pa(_Off[i]) - hpc_pa(_Off[i - 1])) &amp;gt; eps)
 _Off[tn ++] = _Off[i];
 ln = tn;
 int bot = 0, top = 1;
 dequeue[0] = _Off[0];
 dequeue[1] = _Off[1];
 for(i = 2; i &amp;lt; ln; i ++)
 {
 if(dequeue[top].parallel(dequeue[top - 1]) ||
 dequeue[bot].parallel(dequeue[bot + 1]))
 return (*this);
 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[top].crossLPt(dequeue[top - 1]), _Off[i].e, _Off[i].s) &amp;gt; eps)
 top --;
 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[bot].crossLPt(dequeue[bot + 1]), _Off[i].e, _Off[i].s) &amp;gt; eps)
 bot ++;
 dequeue[++ top] = _Off[i];
 }

 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[top].crossLPt(dequeue[top - 1]), dequeue[bot].e, dequeue[bot].s) &amp;gt; eps)
 top --;
 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[bot].crossLPt(dequeue[bot + 1]), dequeue[top].e, dequeue[top].s) &amp;gt; eps)
 bot ++;
 //计算交点(注意不同直线形成的交点可能重合)
 if(top &amp;lt;= bot + 1)
 return (*this);
 for(i = bot; i &amp;lt; top; i ++)
 pt[n ++] = dequeue[i].crossLPt(dequeue[i + 1]);
 if(bot &amp;lt; top + 1)
 pt[n ++] = dequeue[bot].crossLPt(dequeue[top]);
 return (*this);
 }
};
class circle
{
public:
 point c;//圆心
 double r;//半径
 double db, de;//圆弧度数起点， 圆弧度数终点(逆时针0-360)

 //-------圆---------

 //判断圆在多边形内
 bool inside(const polygon &amp;amp;_Off) const
 {
 if(_Off.ahas(c) == false)
 return false;
 for(int i = 0; i &amp;lt; _Off.n; i ++)
 {
 pVector l = pVector(_Off.pt[i], _Off.pt[(i + 1) % _Off.n]);
 if(l.dis(c, true) &amp;lt; r - eps)
 return false;
 }
 return true;
 }

 //判断多边形在圆内（线段和折线类似）
 bool has(const polygon &amp;amp;_Off) const
 {
 for(int i = 0; i &amp;lt; _Off.n; i ++)
 if(_Off.pt[i].dis2(c) &amp;gt; r * r - eps)
 return false;
 return true;
 }

 //-------圆弧-------
 //圆被其他圆截得的圆弧，参数：圆[_Off]
 circle operator-(circle &amp;amp;_Off) const
 {
 //注意圆必须相交，圆心不能重合
 double d2 = c.dis2(_Off.c);
 double d = c.dis(_Off.c);
 double ans = std::acos((d2 + r * r - _Off.r * _Off.r) / (2 * d * r));
 point py = _Off.c - c;
 double oans = std::atan2(py.y, py.x);
 circle res;
 res.c = c;
 res.r = r;
 res.db = oans + ans;
 res.de = oans - ans + 2 * pi;
 return res;
 }
 //圆被其他圆截得的圆弧，参数：圆[_Off]
 circle operator+(circle &amp;amp;_Off) const
 {
 //注意圆必须相交，圆心不能重合
 double d2 = c.dis2(_Off.c);
 double d = c.dis(_Off.c);
 double ans = std::acos((d2 + r * r - _Off.r * _Off.r) / (2 * d * r));
 point py = _Off.c - c;
 double oans = std::atan2(py.y, py.x);
 circle res;
 res.c = c;
 res.r = r;
 res.db = oans - ans;
 res.de = oans + ans;
 return res;
 }

 //过圆外一点的两条切线
 //参数：点[_Off](必须在圆外),返回：两条切线(切线的s点为_Off,e点为切点)
 std::pair&amp;lt;pVector, pVector&amp;gt; tangent(const point &amp;amp;_Off) const
 {
 double d = c.dis(_Off);
 //计算角度偏移的方式
 double angp = std::acos(r / d), ango = std::atan2(_Off.y - c.y, _Off.x - c.x);
 point pl = point(c.x + r * std::cos(ango + angp), c.y + r * std::sin(ango + angp)),
 pr = point(c.x + r * std::cos(ango - angp), c.y + r * std::sin(ango - angp));
 return std::make_pair(pVector(_Off, pl), pVector(_Off, pr));
 }

 //计算直线和圆的两个交点
 //参数：直线[_Off](两点式)，返回两个交点，注意直线必须和圆有两个交点
 std::pair&amp;lt;point, point&amp;gt; cross(pVector _Off) const
 {
 _Off.pton();
 //到直线垂足的距离
 double td = fabs(_Off.a * c.x + _Off.b * c.y + _Off.c) / sqrt(_Off.a * _Off.a + _Off.b * _Off.b);

 //计算垂足坐标
 double xp = (_Off.b * _Off.b * c.x - _Off.a * _Off.b * c.y - _Off.a * _Off.c) / ( _Off.a * _Off.a + _Off.b * _Off.b);
 double yp = (- _Off.a * _Off.b * c.x + _Off.a * _Off.a * c.y - _Off.b * _Off.c) / (_Off.a * _Off.a + _Off.b * _Off.b);

 double ango = std::atan2(yp - c.y, xp - c.x);
 double angp = std::acos(td / r);

 return std::make_pair(point(c.x + r * std::cos(ango + angp), c.y + r * std::sin(ango + angp)),
 point(c.x + r * std::cos(ango - angp), c.y + r * std::sin(ango - angp)));
 }
};

class triangle
{
public:
 point a, b, c;//顶点
 triangle(){}
 triangle(point a, point b, point c): a(a), b(b), c(c){}

 //计算三角形面积
 double area()
 {
 return fabs(point::xmult(a, b, c)) / 2.0;
 }

 //计算三角形外心
 //返回：外接圆圆心
 point circumcenter()
 {
 pVector u,v;
 u.s.x = (a.x + b.x) / 2;
 u.s.y = (a.y + b.y) / 2;
 u.e.x = u.s.x - a.y + b.y;
 u.e.y = u.s.y + a.x - b.x;
 v.s.x = (a.x + c.x) / 2;
 v.s.y = (a.y + c.y) / 2;
 v.e.x = v.s.x - a.y + c.y;
 v.e.y = v.s.y + a.x - c.x;
 return u.crossLPt(v);
 }

 //计算三角形内心
 //返回：内接圆圆心
 point incenter()
 {
 pVector u, v;
 double m, n;
 u.s = a;
 m = atan2(b.y - a.y, b.x - a.x);
 n = atan2(c.y - a.y, c.x - a.x);
 u.e.x = u.s.x + cos((m + n) / 2);
 u.e.y = u.s.y + sin((m + n) / 2);
 v.s = b;
 m = atan2(a.y - b.y, a.x - b.x);
 n = atan2(c.y - b.y, c.x - b.x);
 v.e.x = v.s.x + cos((m + n) / 2);
 v.e.y = v.s.y + sin((m + n) / 2);
 return u.crossLPt(v);
 }

 //计算三角形垂心
 //返回：高的交点
 point perpencenter()
 {
 pVector u,v;
 u.s = c;
 u.e.x = u.s.x - a.y + b.y;
 u.e.y = u.s.y + a.x - b.x;
 v.s = b;
 v.e.x = v.s.x - a.y + c.y;
 v.e.y = v.s.y + a.x - c.x;
 return u.crossLPt(v);
 }

 //计算三角形重心
 //返回：重心
 //到三角形三顶点距离的平方和最小的点
 //三角形内到三边距离之积最大的点
 point barycenter()
 {
 pVector u,v;
 u.s.x = (a.x + b.x) / 2;
 u.s.y = (a.y + b.y) / 2;
 u.e = c;
 v.s.x = (a.x + c.x) / 2;
 v.s.y = (a.y + c.y) / 2;
 v.e = b;
 return u.crossLPt(v);
 }

 //计算三角形费马点
 //返回：到三角形三顶点距离之和最小的点
 point fermentpoint()
 {
 point u, v;
 double step = fabs(a.x) + fabs(a.y) + fabs(b.x) + fabs(b.y) + fabs(c.x) + fabs(c.y);
 int i, j, k;
 u.x = (a.x + b.x + c.x) / 3;
 u.y = (a.y + b.y + c.y) / 3;
 while (step &amp;gt; eps)
 {
 for (k = 0; k &amp;lt; 10; step /= 2, k ++)
 {
 for (i = -1; i &amp;lt;= 1; i ++)
 {
 for (j =- 1; j &amp;lt;= 1; j ++)
 {
 v.x = u.x + step * i;
 v.y = u.y + step * j;
 if (u.dis(a) + u.dis(b) + u.dis(c) &amp;gt; v.dis(a) + v.dis(b) + v.dis(c))
 u = v;
 }
 }
 }
 }
 return u;
 }
};
&lt;/code>&lt;/pre></description></item><item><title>The 35th ACM/ICPC Asia Regional Tianjin Site —— Online Contest 1009 Convex 解题报告</title><link>//owent.net/2010/13.html</link><pubDate>Tue, 14 Sep 2010 08:12:26 +0000</pubDate><guid>//owent.net/2010/13.html</guid><description>&lt;p>The 35th ACM/ICPC Asia Regional Tianjin Site —— Online Contest&lt;/p>
&lt;p>2010年天津赛 网络赛 I题 Convex&lt;/p>
&lt;p>题目链接：&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=3629">http://acm.hdu.edu.cn/showproblem.php?pid=3629&lt;/a>&lt;/p>
&lt;p>题目大意是给你700个点，问从中选4个点组成凸四边形的方法数&lt;/p>
&lt;p>比赛的时候其实最终得到了正确的方法，结果因为写搓了导致TLE，HDU的64位整形必须用I64d，导致WA&lt;/p></description></item><item><title>Catalan 数</title><link>//owent.net/2010/15.html</link><pubDate>Wed, 08 Sep 2010 16:47:57 +0000</pubDate><guid>//owent.net/2010/15.html</guid><description>&lt;p>Catalan数:&lt;/p>
&lt;p>$$ h(1)=1,h(0)=1 $$&lt;/p>
&lt;p>$$ h(n)=\begin{cases} \sum_{i=0}^{n-1} h(i) \times h(n-i-1) &amp;amp; \text{if }(n&amp;gt;=2) \\ \frac{C(2n,n)}{n+1} &amp;amp; \text{if }(n=1,2,3,\mathellipsis) \end{cases} $$&lt;/p>
&lt;p>相关结论：
n边形能分解成三角形的分法数为 h(n – 2)
n个节点能组成的二叉树个数为 h(n)
一个栈(无穷大)的进栈序列为1，2，3，…，n，出栈序列种数为 h(n)&lt;/p></description></item><item><title>简易四则运算(ACM个人模板)</title><link>//owent.net/2010/17.html</link><pubDate>Tue, 10 Aug 2010 18:40:31 +0000</pubDate><guid>//owent.net/2010/17.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * 简易四则运算（栈实现）
 * #include &amp;lt;stack&amp;gt;
 * #include &amp;lt;cstring&amp;gt;
 */
std::stack&amp;lt;char&amp;gt; opr;
std::stack&amp;lt;double&amp;gt; num;
char oprPRI[256];
//初始化调用
void initCalc()
{
 //优先级设置
 char oprMap[7][2] = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'^', 3}, {'(', 100}, {')', 0} };
 for(int i = 0; i &amp;lt; 7; i ++)
 oprPRI[oprMap[i][0]] = oprMap[i][1];
}
bool checkNum(char c)
{
 return c == '.' || (c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9');
}
double calcOpr(double l, double r, char opr)
{
 switch(opr)
 {
 case '+': return l + r;
 case '-': return l - r;
 case '*': return l * r;
 case '/': return l / r;
 case '^': return ::pow(l, r);
 }
 return 0.0;
}
void calcStack()
{
 double cl, cr;
 cr = num.top();
 num.pop();
 cl = num.top();
 num.pop();
 num.push(::calcOpr(cl, cr, opr.top()));
 opr.pop();
}
double calc(const char str[])
{
 while(!opr.empty())
 opr.pop();
 while(!num.empty())
 num.pop();
 int i = 0, len = strlen(str);
 num.push(0.0);
 opr.push('(');
 while(i &amp;lt; len)
 {
 if(::checkNum(str[i]))
 {
 double l;
 ::sscanf(str + i, &amp;quot;%lf&amp;quot;, &amp;amp;l);
 while(::checkNum(str[i]))
 i ++;
 num.push(l);
 }
 else
 {
 char c = str[i ++];
 if(c == ')')
 {
 while(opr.top() != '(')
 calcStack();
 opr.pop();
 }
 else if(oprPRI[c] &amp;gt; oprPRI[opr.top()])
 opr.push(c);
 else
 {
 while(opr.top() != '(' &amp;amp;&amp;amp; oprPRI[c] &amp;lt;= oprPRI[opr.top()])
 calcStack();
 opr.push(c);
 }
 }
 }
 while(opr.size() &amp;gt; 1)
 calcStack();
 return num.top();
}
&lt;/code>&lt;/pre></description></item><item><title>数论模板（个人模板）</title><link>//owent.net/2010/18.html</link><pubDate>Mon, 09 Aug 2010 15:54:02 +0000</pubDate><guid>//owent.net/2010/18.html</guid><description>&lt;h2 id="基础函数">基础函数:&lt;/h2>
&lt;pre>&lt;code class="language-cpp">// 最大公约数,欧几里得定理
int gcd(int a, int b)
{
 return b?gcd(b, a % b): a;
}
// 拓展欧几里得定理
// 求解ax + by = gcd(a,b)
int ext_gcd(int a, int b, int &amp;amp;x, int &amp;amp;y)
{
 int tmp, ret;
 if(!b)
 {
 x = 1;
 y = 0;
 return a;
 }
 ret = ext_gcd(b, a % b, x, y);
 tmp = x;
 x = y;
 y = tmp - (a / b) * y;
 return ret;
}
//交换数值
void swap(int &amp;amp;a, int &amp;amp;b)
{
 a ^= b ^= a ^= b;
}

/**
 * a的b次方Mod c
 * 参数为整数
 * 使用时注意修改类型
 */
int PowerMod(int a, int b, int c)
{
 int tp = 1;
 while (b)
 {
 if (b &amp;amp; 1)
 tp = (tp * a) % c;
 a = (a * a) % c;
 b &amp;gt;&amp;gt;= 1;
 }
 return tp;
}
&lt;/code>&lt;/pre>
&lt;h2 id="1欧拉函数">1.欧拉函数&lt;/h2>
&lt;p>Ψ（n） = 小于n且与n互质的数的个数&lt;/p></description></item><item><title>POJ PKU 2826 An Easy Problem?! 解题报告</title><link>//owent.net/2010/19.html</link><pubDate>Sat, 07 Aug 2010 08:54:04 +0000</pubDate><guid>//owent.net/2010/19.html</guid><description>&lt;p>题目链接：
&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2826">http://acm.pku.edu.cn/JudgeOnline/problem?id=2826&lt;/a>&lt;/p>
&lt;p>大致意思是给你两条线段，问组成的开口向上的V形区域能盛多少雨水。雨水是垂直落下的。&lt;/p>
&lt;p>显然线段不相交，或者平行，重合，或者有一条斜率为0时结果为0.00&lt;/p></description></item><item><title>POJ PKU 1986 Distance Queries 解题报告</title><link>//owent.net/2010/22.html</link><pubDate>Fri, 16 Jul 2010 04:57:10 +0000</pubDate><guid>//owent.net/2010/22.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1986">http://acm.pku.edu.cn/JudgeOnline/problem?id=1986&lt;/a>&lt;/p>
&lt;p>这是一道并查集+树的题，采用Tarjan离线算法&lt;/p>
&lt;p>首先BS一下出题的人，也太懒了吧，还要我们看1984题才知道输入&lt;/p>
&lt;p>题目的意思是告诉一个节点数为40000的树，问我们两个节点间的距离。实际上就是找出公共父节点，Tarjan算法写挫了很容易TLE，我开始用Vector就写搓了，结果TLE，后来重写，自己写邻接表然后AC了。&lt;/p></description></item><item><title>POJ PKU 2446 Chessboard 解题报告</title><link>//owent.net/2010/23.html</link><pubDate>Fri, 16 Jul 2010 04:51:23 +0000</pubDate><guid>//owent.net/2010/23.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2446">http://acm.pku.edu.cn/JudgeOnline/problem?id=2446&lt;/a>&lt;/p>
&lt;p>这是一道匹配题，把行数（r）和列数（c）按（r+c）%2分成两组，然后连边，做一次二分图匹配，可以直接用匈牙利算法&lt;/p>
&lt;p>匹配数等于两组的元素个数则为YES，否则NO&lt;/p></description></item><item><title>C#格式化输出(记录)</title><link>//owent.net/2010/26.html</link><pubDate>Tue, 08 Jun 2010 05:39:06 +0000</pubDate><guid>//owent.net/2010/26.html</guid><description>&lt;pre>&lt;code class="language-cs">int a = 12345678;
//格式为sring输出
Label1.Text = string.Format(&amp;quot;asdfadsf{0}adsfasdf&amp;quot;,a);
Label2.Text = &amp;quot;asdfadsf&amp;quot;+a.ToString()+&amp;quot;adsfasdf&amp;quot;;
Label1.Text = string.Format(&amp;quot;asdfadsf{0:C}adsfasdf&amp;quot;,a);//asdfadsf￥1,234.00adsfasdf
Label2.Text = &amp;quot;asdfadsf&amp;quot;+a.ToString(&amp;quot;C&amp;quot;)+&amp;quot;adsfasdf&amp;quot;;//asdfadsf￥1,234.00adsfasdf
double b = 1234.12543;
int a = 12345678;
//格式为特殊的string样式输出
Label1.Text = string.Format(&amp;quot;asdfadsf{0:C}adsfasdf&amp;quot;,b);//asdfadsf￥1,234.13adsfasdf
Label2.Text = &amp;quot;asdfadsf&amp;quot;+b.ToString(&amp;quot;C&amp;quot;)+&amp;quot;adsfasdf&amp;quot;;//asdfadsf￥1,234.13adsfasdf
Label1.Text = string.Format(&amp;quot;{0:C3}&amp;quot;,b);//￥1,234.125
Label2.Text = b.ToString(&amp;quot;C3&amp;quot;);//￥1,234.125
Label1.Text = string.Format(&amp;quot;{0:d}&amp;quot;,a);//十进制--12345678
Label2.Text = b.ToString(&amp;quot;d&amp;quot;);//十进制--相同的类型，转换报错
Label1.Text = string.Format(&amp;quot;{0:e}&amp;quot;,a);//指数--1.234568e+007
Label2.Text = b.ToString(&amp;quot;e&amp;quot;);//指数--1.234125e+003
Label1.Text = string.Format(&amp;quot;{0:f}&amp;quot;,a);//定点数--12345678.00
Label2.Text = b.ToString(&amp;quot;f&amp;quot;);//定点数--1234.13
Label1.Text = string.Format(&amp;quot;{0:n}&amp;quot;,a);//数值--12,345,678.00
Label2.Text = b.ToString(&amp;quot;n&amp;quot;);//数值--1,234.13
Label1.Text = string.Format(&amp;quot;{0:x}&amp;quot;,a);//十六进制--bc614e
Label2.Text = b.ToString(&amp;quot;x&amp;quot;);//16--带有小数不能转换，出错
Label1.Text = string.Format(&amp;quot;{0:g}&amp;quot;,a);//通用为最紧凑--12345678
Label2.Text = b.ToString(&amp;quot;g&amp;quot;);//通用为最紧凑--1234.12543
Label1.Text = string.Format(&amp;quot;{0:r}&amp;quot;,a);//转来转去不损失精度--整数不允许用，报错
Label2.Text = b.ToString(&amp;quot;r&amp;quot;);//转来转去不损失精度--1234.12543
double b = 4321.12543;
int a = 1234;
自定义模式输出：
//&amp;quot;0&amp;quot;描述：占位符，如果可能，填充位
Label1.Text = string.Format(&amp;quot;{0:000000}&amp;quot;,a);// 001234
Label2.Text = string.Format(&amp;quot;{0:000000}&amp;quot;,b);// 004321
//&amp;quot;#&amp;quot;描述：占位符，如果可能，填充位
Label1.Text = string.Format(&amp;quot;{0:####### }&amp;quot;,a);// 1234
Label2.Text = string.Format(&amp;quot;{0:####### }&amp;quot;,b);// 4321
Label1.Text = string.Format(&amp;quot;{0:#0#### }&amp;quot;,a);// 01234
Label2.Text = string.Format(&amp;quot;{0:0#0000}&amp;quot;,b);// 004321
//&amp;quot;.&amp;quot;描述：小数点
Label1.Text = string.Format(&amp;quot;{0:000.000}&amp;quot;,a);//1234.000
Label2.Text = string.Format(&amp;quot;{0:000.000}&amp;quot;,b);//4321.125
double b = 87654321.12543;
int a = 12345678;
//&amp;quot;,&amp;quot;描述：数字分组，也用于增倍器
Label1.Text = string.Format(&amp;quot;{0:0,00}&amp;quot;,a);// 12,345,678
Label2.Text = string.Format(&amp;quot;{0:0,00}&amp;quot;,b);// 87,654,32
Label1.Text = string.Format(&amp;quot;{0:0,}&amp;quot;,a);// 12346
Label2.Text = string.Format(&amp;quot;{0:0,}&amp;quot;,b);// 87654
Label1.Text = string.Format(&amp;quot;{0:0,,}&amp;quot;,a);// 12
Label2.Text = string.Format(&amp;quot;{0:0,,}&amp;quot;,b);// 88
Label1.Text = string.Format(&amp;quot;{0:0,,,}&amp;quot;,a);// 0
Label2.Text = string.Format(&amp;quot;{0:0,,,}&amp;quot;,b);// 0
//&amp;quot;%&amp;quot;描述：格式为百分数
Label1.Text = string.Format(&amp;quot;{ 0:0% }&amp;quot;,a);// 1234567800%
Label2.Text = string.Format(&amp;quot;{ 0:#% }&amp;quot;,b);// 8765432113%
Label1.Text = string.Format(&amp;quot;{ 0:0.00% }&amp;quot;,a);// 1234567800.00%
Label2.Text = string.Format(&amp;quot;{ 0:#.00% }&amp;quot;,b);// 8765432112.54%
//&amp;quot;abc&amp;quot;描述：显示单引号内的文本
Label1.Text = string.Format(&amp;quot;{0:'文本'0}&amp;quot;,a);// 文本12345678
Label2.Text = string.Format(&amp;quot;{0:文本0}&amp;quot;,b);// 文本87654321
//&amp;quot;\&amp;quot;描述：后跟1要打印字的字符，也用于转移符\n等
Label1.Text = string.Format(&amp;quot;\&amp;quot;你好！\&amp;quot;&amp;quot;);// &amp;quot;你好！&amp;quot;
Label2.Text = string.Format(&amp;quot;[url=file://\\c\\books\\new\\we.asp]\\c\\books\\new\\we.asp&amp;quot;);//\c\books\new\we.asp
//&amp;quot;@&amp;quot;描述：后跟要打印字的字符,
Label1.Text = string.Format(@&amp;quot;&amp;quot;&amp;quot;你好！&amp;quot;&amp;quot;&amp;quot;); // &amp;quot;你好！&amp;quot;要打印&amp;quot;则需要输入两对才可以
Label2.Text = string.Format(@&amp;quot;\c\books\new\we.asp&amp;quot;);//\c\books\new\we.asp 
&lt;/code>&lt;/pre></description></item><item><title>USACO 2008 March Gold Cow Jogging 解题报告</title><link>//owent.net/2010/27.html</link><pubDate>Wed, 02 Jun 2010 17:31:57 +0000</pubDate><guid>//owent.net/2010/27.html</guid><description>&lt;p>题目链接：&lt;a href="http://202.120.106.94/onlinejudge/problemshow.php?pro_id=143">http://202.120.106.94/onlinejudge/problemshow.php?pro_id=143&lt;/a>&lt;/p>
&lt;p>这道题嘛，怎么说呢，好吧中等题&lt;/p>
&lt;p>要求算出下山的前k短路的路长度&lt;/p>
&lt;p>由于一定是下山所以可以用邻接表记录路径，然后用一个优先队列记录已有的到n的路长度&lt;/p></description></item><item><title>POJ PKU 3659 Cell Phone Network 解题报告</title><link>//owent.net/2010/28.html</link><pubDate>Tue, 01 Jun 2010 15:51:00 +0000</pubDate><guid>//owent.net/2010/28.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3659">http://acm.pku.edu.cn/JudgeOnline/problem?id=3659&lt;/a>&lt;/p>
&lt;p>这题不算难题了，基本算是中等题&lt;/p>
&lt;p>题目大意是给出一颗树，在一些点建一个信号塔，信号塔覆盖范围是其所在点和邻近点，问最少几个信号塔可以覆盖全区域&lt;/p></description></item><item><title>浙江理工 省赛总结 team62 By OWenT of Coeus</title><link>//owent.net/2010/29.html</link><pubDate>Mon, 10 May 2010 16:45:14 +0000</pubDate><guid>//owent.net/2010/29.html</guid><description>&lt;p>这次比赛成绩比预期差&lt;/p>
&lt;p>开始Ultramanhu调整IDE&lt;/p>
&lt;p>Q Boy从头开始看题&lt;/p>
&lt;p>我的任务是倒数看题，最后看的题目是J，I，H，G&lt;/p>
&lt;p>我看完J觉得J可做（哈密顿回路），但是需要很长时间。就首先放着继续看题&lt;/p></description></item><item><title>树状数组模块(个人模板)</title><link>//owent.net/2010/30.html</link><pubDate>Thu, 06 May 2010 13:51:29 +0000</pubDate><guid>//owent.net/2010/30.html</guid><description>&lt;p>树状数组模块&lt;/p>
&lt;p>ACM个人模板&lt;/p>
&lt;p>POJ 2155 题目测试通过&lt;/p>
&lt;pre>&lt;code class="language-cpp">/**
 * 树状数组模块
 * 下标从0开始
 */
typedef long DG_Ran;
typedef long DG_Num;
const DG_Num DG_MAXN = 1005;

//2^n
DG_Num LowBit(DG_Num n)
{
 return n &amp;amp; (-n);
}
//获取父节点索引
DG_Num DGFather(DG_Num n)
{
 return n + LowBit(n + 1);
}
//获取小的兄弟节点索引
DG_Num DGBrother(DG_Num n)
{
 return n - LowBit(n + 1);
}
//查找增加树状数组前pos项和
//参数(树状数组[in],索引[in],初始赋0即查找前n项和[out])
//复杂度:log(n)
void DGFind(DG_Ran *g,DG_Num pos,DG_Ran &amp;amp;sum)
{
 sum += *(g + pos);
 if(pos &amp;gt;= LowBit(pos + 1))
 DGFind(g, pos - LowBit(pos + 1), sum);
}
//查找对应线性数组元素
//参数(树状数组[in],索引[in]).
//返回值:对应线性数组元素log(n)
//复杂度:log(n)
DG_Ran DGFindEle(DG_Ran *g,DG_Num pos)
{
 DG_Ran a = 0 , b = 0;
 DGFind(g, pos, a);
 if(pos)
 {
 DGFind(g,pos - 1,b);
 return a - b;
 }
 else
 return a;
}
//树状数组,增加节点
//参数:树状数组[out],原数组大小[in],新增线性数组值[in]
//复杂度:log(n)
DG_Ran DGAdd(DG_Ran *g,DG_Num n,DG_Ran val)
{
 *(g + n) = val;
 DG_Num a = n;
 DG_Num b = 1;
 while((a &amp;amp; (~b)) != a)
 {
 *(g + n) += *(g + a - 1);
 a &amp;amp;= (~b);
 b &amp;lt;&amp;lt;= 1;
 }
 return n + 1;
}
//构建树状数组
//参数:线性数组[in],数组大小[in],树状数组[out]
//复杂度:nlog(n)
DG_Ran DGCreate(DG_Ran *g,DG_Num n,DG_Ran *tg)
{
 DG_Num i;
 *tg = *g;
 for(i = 1 ; i &amp;lt; n ; i ++)
 DGAdd(tg,i,*(g + i));
 return n;
}
//修改指定位置值
//参数:线性数组[in],数组位置[in],数组大小[in],新值[in]
//复杂度:log(n)
DG_Ran DGEdit(DG_Ran *g,DG_Num pos,DG_Num n,DG_Ran val)
{
 DG_Num f = DGFather(pos);
 DG_Ran o = *( g + pos );
 *( g + pos ) = val;
 if(f &amp;lt; n)
 {
 DG_Ran fv = val - o + *( g + f );
 DGEdit(g, f, n, fv);
 }
 return n;
}

//树状数组的翻转(树状数组的应用)
//一维 复杂度log(n)
//小于等于指定位置的元素的翻转&amp;lt;=pos
void DGDown1(DG_Ran g[],DG_Num pos,DG_Ran av)
{
 while(pos &amp;gt;= 0)
 g[pos] += av , pos = DGBrother(pos);
}
//获取位置pos的元素翻转次数
DG_Ran DGCUp1(DG_Ran g[],DG_Num pos , DG_Num n)
{
 DG_Ran t = 0;
 while(pos &amp;lt; n)
 t += g[pos] , pos = DGFather(pos);
 return t;
}
//二维 复杂度(log(n))^2
//小于等于指定位置的元素的翻转(0,0)-&amp;gt;(x,y)
void DGDown2(DG_Ran g[][DG_MAXN],DG_Num x ,DG_Num y,DG_Ran av)
{
 while(x &amp;gt;= 0)
 {
 DG_Num tmp = y;
 while (tmp &amp;gt;= 0)
 {
 g[x][tmp] += av;
 tmp = DGBrother(tmp);
 }
 x = DGBrother(x);
 }
}
//获取位置(x,y)的元素翻转次数
DG_Ran DGCUp2(DG_Ran g[][DG_MAXN],DG_Num x ,DG_Num y , DG_Num n)
{
 DG_Ran t = 0;
 while(x &amp;lt; n)
 {
 DG_Num tmp = y;
 while (tmp &amp;lt; n)
 {
 t += g[x][tmp];
 tmp = DGFather(tmp);
 }
 x = DGFather(x);
 }
 return t;
}
&lt;/code>&lt;/pre></description></item><item><title>HDU HDOJ 3398 String 解题报告</title><link>//owent.net/2010/31.html</link><pubDate>Wed, 05 May 2010 16:51:22 +0000</pubDate><guid>//owent.net/2010/31.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=3398">http://acm.hdu.edu.cn/showproblem.php?pid=3398&lt;/a>&lt;/p>
&lt;p>题目要我们计算1，0的排列方式总数，并且对任意长的字符串，1的数量大于等于0的数量&lt;/p>
&lt;p>我们可以把题目转化为从（0，0）点到（m，n）点的方法总数，且路径不经过y=x-1这条直线&lt;/p></description></item><item><title>线性筛法求质数(素数)表 及其原理</title><link>//owent.net/2010/32.html</link><pubDate>Mon, 03 May 2010 11:20:33 +0000</pubDate><guid>//owent.net/2010/32.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * 线性筛法求素数表
 * 复杂度: O(n)
 */
const long MAXP = 1000000;
long prime[MAXP] = {0},num_prime = 0;
int isNotPrime[MAXP] = {1, 1};
void GetPrime_Init()//初始化调用
{
 for(long i = 2 ; i &amp;lt; MAXP ; i ++)
 {
 if(! isNotPrime[i])
 prime[num_prime ++]=i;
 for(long j = 0 ; j &amp;lt; num_prime &amp;amp;&amp;amp; i * prime[j] &amp;lt; MAXP ; j ++)
 {
 isNotPrime[i * prime[j]] = 1;
 if( !(i % prime[j]))
 break;
 }
 }
}
&lt;/code>&lt;/pre>
&lt;p>线性筛法,即是筛选掉所有合数,留下质数&lt;/p></description></item><item><title>HDU HDOJ 3400 Line belt 解题报告</title><link>//owent.net/2010/33.html</link><pubDate>Mon, 03 May 2010 11:17:15 +0000</pubDate><guid>//owent.net/2010/33.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=3400">http://acm.hdu.edu.cn/showproblem.php?pid=3400&lt;/a>&lt;/p>
&lt;p>这题就是一道简单的两重三分&lt;/p>
&lt;p>首先设e点为从ab上离开的点，f为从cd上进入的点&lt;/p>
&lt;p>显然对固定点e,f从距c的距离的长度是一个单调函数或者先减后增的函数，这里可以三分算出最优解。这里是第一个三分&lt;/p></description></item><item><title>Southeastern European 2008 Sky Code 解题报告</title><link>//owent.net/2010/34.html</link><pubDate>Thu, 29 Apr 2010 12:08:10 +0000</pubDate><guid>//owent.net/2010/34.html</guid><description>&lt;p>又是我们的OJ&lt;/p>
&lt;p>题目链接：&lt;/p>
&lt;p>&lt;a href="http://www.cn210.com/onlinejudge/problemshow.php?pro_id=92">http://www.cn210.com/onlinejudge/problemshow.php?pro_id=92&lt;/a>&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>tancu likes space travels but he is a poor software developer and will never be able to buy his own spacecraft. That is why he is preparing to steal the spacecraft of Petru. There is only one problem - Petru has locked the spacecraft with a sophisticated cryptosystem based on the ID numbers of the stars from the Milky Way Galaxy. For breaking the system Stancu has to check each subset of four stars such that the only common divisor of their numbers is 1. Nasty, isn't it? Fortunately, Stancu has succeeded to limit the number of the interesting stars to N but, any way, the possible subsets of four stars can be too many. Help him to find their number and to decide if there is a chance to break the system.&lt;!-- raw HTML omitted -->&lt;/p></description></item><item><title>GCD Determinant 解题报告</title><link>//owent.net/2010/35.html</link><pubDate>Mon, 26 Apr 2010 14:33:11 +0000</pubDate><guid>//owent.net/2010/35.html</guid><description>&lt;p>&lt;a href="http://www.cn210.com/onlinejudge/problemshow.php?pro_id=98">http://www.cn210.com/onlinejudge/problemshow.php?pro_id=98&lt;/a>&lt;/p>
&lt;p>我们的OJ&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>We say that a set $$S = {x1, x2, &amp;hellip;, xn}$$ is factor closed if for any xi ∈ S and any divisor d of xi we have d ∈ S. Let&amp;rsquo;s build a GCD matrix (S) = (sij), wheresij = GCD(xi, xj) - the greatest common divisor of xi and xj. Given the factor closed set S, find the value of the determinant:&lt;/p></description></item><item><title>PKU POJ 3757 Simple Distributed storage system 解题报告</title><link>//owent.net/2010/41.html</link><pubDate>Sat, 10 Apr 2010 17:10:47 +0000</pubDate><guid>//owent.net/2010/41.html</guid><description>&lt;p>题目链接：http://acm.pku.edu.cn/JudgeOnline/problem?id=3757&lt;/p>
&lt;p>题目大意&lt;/p>
&lt;p>第一行输入n，k，f表示从n个服务器里选k个，传输大小为f（以Mb为单位）的文件&lt;/p></description></item><item><title>PKU POJ 2976 Dropping tests 解题报告</title><link>//owent.net/2010/43.html</link><pubDate>Fri, 09 Apr 2010 17:04:09 +0000</pubDate><guid>//owent.net/2010/43.html</guid><description>&lt;p>题目链接： &lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2976">http://acm.pku.edu.cn/JudgeOnline/problem?id=2976&lt;/a>&lt;/p>
&lt;p>0-1分数规划&lt;/p>
&lt;p>最优比例生成树&lt;/p>
&lt;p>迭代法&lt;/p>
&lt;p>证明：（前几次都是看别人的，这次自己证明）&lt;/p>
&lt;p>对于集合s，令l* = max{ a(x) / b(x) } = a(x*) / b(x*).l&lt;em>为所求的最优解，x&lt;/em>为对应的集合&lt;/p></description></item><item><title>PKU POJ 2728 Desert King 解题报告</title><link>//owent.net/2010/45.html</link><pubDate>Wed, 07 Apr 2010 10:51:26 +0000</pubDate><guid>//owent.net/2010/45.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2728">http://acm.pku.edu.cn/JudgeOnline/problem?id=2728&lt;/a>&lt;/p>
&lt;p>和3757一样都是01分数规划的题，不同的是3757是用的二分，这里用的是Prim&lt;/p>
&lt;p>0-1背包部分和3757一样&lt;/p>
&lt;p>令m(l) = min{∑(1.0 * h[i][j] - l * dis[i][j] )}&lt;/p></description></item><item><title>PKU POJ 1141 Brackets Sequence 解题报告</title><link>//owent.net/2010/46.html</link><pubDate>Mon, 05 Apr 2010 16:52:28 +0000</pubDate><guid>//owent.net/2010/46.html</guid><description>&lt;p>链接: &lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1141">http://acm.pku.edu.cn/JudgeOnline/problem?id=1141&lt;/a>
题目意思是输入一些括号，补充括号使之成为没有错误的括号就是只能有括号组在括号组里面，不能出现([)]或者([)]一类的情况
方法是DP，有点绕的DP
DP方程是 &lt;em>bc[i][j] = min(bc[i][k] + bc[k][j])&lt;/em> 注：bc[i][j]表示字符i和字符j之间需要插入几个括弧
然后尽量多地分割字符串
不解释，贴代码：&lt;/p></description></item><item><title>POJ PKU 2155 Matrix 解题报告</title><link>//owent.net/2010/47.html</link><pubDate>Mon, 05 Apr 2010 11:01:59 +0000</pubDate><guid>//owent.net/2010/47.html</guid><description>&lt;p>这道题是我专门为了了解和学习树状数组而写的&lt;/p>
&lt;p>这题用树状数组记录翻转次数,然后mod一个2,也可以不断地取反&lt;/p>
&lt;p>还要用到二维的树状数组.于是我专门写了个模板用&lt;/p></description></item><item><title>PKU POJ 1720 SQUARES 解题报告</title><link>//owent.net/2010/48.html</link><pubDate>Sat, 03 Apr 2010 17:12:41 +0000</pubDate><guid>//owent.net/2010/48.html</guid><description>&lt;p>题目链接：http://acm.pku.edu.cn/JudgeOnline/problem?id=1720&lt;/p>
&lt;p>这题纯计算几何就搞定了，开始我写了个很长很长的代码，但是Wa掉，也不知道是代码那里有疏漏还是精度问题&lt;/p></description></item><item><title>PKU POJ 1724 ROADS 解题报告</title><link>//owent.net/2010/50.html</link><pubDate>Fri, 02 Apr 2010 17:07:50 +0000</pubDate><guid>//owent.net/2010/50.html</guid><description>&lt;p>看来我的搜索真的很烂，简单的搜索都搞定的这么痛苦&lt;/p>
&lt;p>题目链接：http://acm.pku.edu.cn/JudgeOnline/problem?id=1724&lt;/p></description></item><item><title>POJ PKU Let's Go to the Movies 解题报告</title><link>//owent.net/2010/52.html</link><pubDate>Wed, 31 Mar 2010 16:04:21 +0000</pubDate><guid>//owent.net/2010/52.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3513">http://acm.pku.edu.cn/JudgeOnline/problem?id=3513&lt;/a>&lt;/p>
&lt;p>题目大意是输入树状的家庭关系，问怎么买票（买家庭票还是个人票）最省钱并且票的数量最少&lt;/p>
&lt;p>这道题是一道Hash+树状DP问题。编码长度相当可观，需要较好的编码能力&lt;/p></description></item><item><title>ZOJ 3309 Search New Posts 解题报告</title><link>//owent.net/2010/53.html</link><pubDate>Mon, 15 Mar 2010 14:49:52 +0000</pubDate><guid>//owent.net/2010/53.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3309">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3309&lt;/a>&lt;/p>
&lt;p>一道典型的Hash题&lt;/p>
&lt;p>题目很好理解。这里不复述&lt;/p>
&lt;p>由于输入语句最大数量200000，不用Hash铁定TLE。然后数据量不超过10000，所以必然有很多search和reply的操作。&lt;/p></description></item><item><title>Hash模板 个人模板</title><link>//owent.net/2010/54.html</link><pubDate>Mon, 15 Mar 2010 12:58:47 +0000</pubDate><guid>//owent.net/2010/54.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * Hash模板
 * Based: 0
 * template&amp;lt;unsigned long _SZ,class _T, unsigned long *pFun(_T _Off)&amp;gt;
 * class _My_Hash_ToInt
 * 传入数据大小_SZ,传入类型_T,Hash函数
 * 传入类型_T必须重载 = 和 == 符号
 * 收录了ELFHash函数
 * 主要是为了判重的简化些的模板
 * Hash算法性能比较见 http://www.cnblogs.com/lonelycatcher/archive/2011/08/23/2150587.html
 */

const long hashsize = 51071; //Hash表大小(注意修改)
// 各种Hash算法
unsigned int SDBMHash(char *str)
{
 unsigned int hash = hashsize;

 while (*str)
 {
 // equivalent to: hash = 65599*hash + (*str++);
 hash = (*str++) + (hash &amp;lt;&amp;lt; 6) + (hash &amp;lt;&amp;lt; 16) - hash;
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// RS Hash Function
unsigned int RSHash(char *str)
{
 unsigned int b = 378551;
 unsigned int a = 63689;
 unsigned int hash = hashsize;

 while (*str)
 {
 hash = hash * a + (*str++);
 a *= b;
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// JS Hash Function
unsigned int JSHash(char *str)
{
 unsigned int hash = 1315423911;

 while (*str)
 {
 hash ^= ((hash &amp;lt;&amp;lt; 5) + (*str++) + (hash &amp;gt;&amp;gt; 2));
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// P. J. Weinberger Hash Function
unsigned int PJWHash(char *str)
{
 unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8);
 unsigned int ThreeQuarters = (unsigned int)((BitsInUnignedInt * 3) / 4);
 unsigned int OneEighth = (unsigned int)(BitsInUnignedInt / 8);
 unsigned int HighBits = (unsigned int)(0xFFFFFFFF) &amp;lt;&amp;lt; (BitsInUnignedInt - OneEighth);
 unsigned int hash = hashsize;
 unsigned int test = 0;

 while (*str)
 {
 hash = (hash &amp;lt;&amp;lt; OneEighth) + (*str++);
 if ((test = hash &amp;amp; HighBits) != 0)
 {
 hash = ((hash ^ (test &amp;gt;&amp;gt; ThreeQuarters)) &amp;amp; (~HighBits));
 }
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// ELF Hash Function
unsigned int ELFHash(char *str)
{
 unsigned int hash = hashsize;
 unsigned int x = 0;

 while (*str)
 {
 hash = (hash &amp;lt;&amp;lt; 4) + (*str++);
 if ((x = hash &amp;amp; 0xF0000000L) != 0)
 {
 hash ^= (x &amp;gt;&amp;gt; 24);
 hash &amp;amp;= ~x;
 }
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// BKDR Hash Function
unsigned int BKDRHash(char *str)
{
 unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
 unsigned int hash = hashsize;

 while (*str)
 {
 hash = hash * seed + (*str++);
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// DJB Hash Function
unsigned int DJBHash(char *str)
{
 unsigned int hash = 5381;

 while (*str)
 {
 hash += (hash &amp;lt;&amp;lt; 5) + (*str++);
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// AP Hash Function
unsigned int APHash(char *str)
{
 unsigned int hash = hashsize;
 int i;

 for (i=0; *str; i++)
 {
 if ((i &amp;amp; 1) == 0)
 {
 hash ^= ((hash &amp;lt;&amp;lt; 7) ^ (*str++) ^ (hash &amp;gt;&amp;gt; 3));
 }
 else
 {
 hash ^= (~((hash &amp;lt;&amp;lt; 11) ^ (*str++) ^ (hash &amp;gt;&amp;gt; 5)));
 }
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// 程序模板
template&amp;lt;typename _T&amp;gt;
class _My_Hash_ToInt_Data
{
public:
 _My_Hash_ToInt_Data()
 {
 times = 0;
 next = -1;
 }
 _T data;
 long times;
 long next;
};
template&amp;lt;long _SZ,class _T, unsigned long pFun(_T&amp;amp; _Off)&amp;gt;
class _My_Hash_ToInt
{
public:
 _My_Hash_ToInt()
 {
 memset(hash, -1, sizeof(hash));
 length = 0;
 };
 ~_My_Hash_ToInt(){};
 long find(_T _Off)
 {
 long pos = hash[pFun(_Off)];
 while(pos &amp;gt;= 0)
 {
 if(data[pos].data == _Off)
 return pos;
 else
 pos = data[pos].next;
 }
 return -1;
 }
 long insert(_T _Off)
 {
 long oldPos = pFun(_Off);
 long pos = hash[oldPos];
 while(pos &amp;gt;= 0)
 {
 if(data[pos].data == _Off)
 {
 data[pos].times ++;
 return pos;
 }
 else
 pos = data[pos].next;
 }
 data[length].data = _Off;
 data[length].times = 1;
 data[length].next = hash[oldPos];
 hash[oldPos] = length ;
 return length ++;
 }
 void clear()
 {
 length = 0;
 memset(hash, -1, sizeof(hash));
 memset(data, -1, sizeof(data));
 }
 //Member
 long length;
 _My_Hash_ToInt_Data&amp;lt;_T&amp;gt; data[_SZ];
 long hash[hashsize];
};

//节点类（注意修改）
class node
{
public:
 char str[60];
 bool operator == (node &amp;amp;strin)
 {
 return !strcmp(str, strin.str);
 }
 node&amp;amp; operator = (node &amp;amp;strin)
 {
 strcpy(str, strin.str);
 return (*this);
 }
};
//扩展Hash函数（注意修改）
unsigned long ELFHashEx(node &amp;amp;strIn)
{
 return ELFHash(strIn.str);
}
_My_Hash_ToInt&amp;lt;10005, node, ELFHashEx&amp;gt;hash;//Hash类例子
&lt;/code>&lt;/pre></description></item><item><title>HDU 3336 Count the string 解题报告</title><link>//owent.net/2010/55.html</link><pubDate>Mon, 15 Mar 2010 11:12:56 +0000</pubDate><guid>//owent.net/2010/55.html</guid><description>&lt;p>题目：
&lt;a href="http://acm.hdu.edu.cn/showproblem.php?pid=3336">http://acm.hdu.edu.cn/showproblem.php?pid=3336&lt;/a>&lt;/p>
&lt;p>水题一道，主要是测试数据很水&lt;/p>
&lt;p>不解释，贴代码：&lt;/p>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;

char str[200005];
vector&amp;lt;long&amp;gt;glo_Pos;
int main()
{
 int t;
 long output,i,n,j;
 scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
 while(t --)
 {
 output = 0;
 glo_Pos.clear();
 scanf(&amp;quot;%ld %s&amp;quot;, &amp;amp;n, str);

 for(i = 0; i &amp;lt; n; i ++)
 {
 if(str[i] == str[0])
 {
 glo_Pos.push_back(i);
 output ++;
 }
 }
 output = output % 10007;
 for(i = 1; i &amp;lt; n; i ++)
 {
 for(j = 0; j &amp;lt; glo_Pos.size();j ++)
 {
 if(str[i] == str[glo_Pos[j] + i])
 output = (output + 1) % 10007;
 else
 {
 glo_Pos.erase(glo_Pos.begin() + j);
 j --;
 }
 }
 }

 printf(&amp;quot;%ld\n&amp;quot;, output);
 }
 return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>POJ PKU 1065 Wooden Sticks 3636 Nested Dolls 解题报告</title><link>//owent.net/2010/57.html</link><pubDate>Wed, 24 Feb 2010 15:43:54 +0000</pubDate><guid>//owent.net/2010/57.html</guid><description>&lt;p>3636 Nested Dolls&lt;/p>
&lt;p>题目链接：[http://acm.pku.edu.cn/JudgeOnline/problem?id=3636&lt;/p>
&lt;p>](&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3636">http://acm.pku.edu.cn/JudgeOnline/problem?id=3636&lt;/a>)好吧，这题我看了解题报告。而且解题报告有错误的。只考虑w递增，没考虑w值相等的情况。&lt;/p>
&lt;p>我自己这里加进去了判断。主要是看解题报告后才知道数据这么弱，就按他的写了&lt;/p></description></item><item><title>POJ PKU 3631 Cuckoo Hashing 解题报告</title><link>//owent.net/2010/58.html</link><pubDate>Wed, 24 Feb 2010 10:14:57 +0000</pubDate><guid>//owent.net/2010/58.html</guid><description>&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3631">http://acm.pku.edu.cn/JudgeOnline/problem?id=3631&lt;/a>&lt;/p>
&lt;p>我讨厌这么长的题目&lt;/p>
&lt;p>这题是模拟那个Hash算法，有点像我之前转载的那篇文章里提到的Hash&lt;/p>
&lt;p>&lt;a href="https://www.owent.net/2009/87.html">打造最快的Hash表(转) [以暴雪的游戏的Hash为例]&lt;/a> 这里是用两个Hash函数算出两个Hash值h1和h2，如果h1位置已经被占用就检查h2位置，如果都被占用就把原来的替换掉再给原来的字符串重新计算映射。这样下去可能出现死循环。会出现死循环就输出&lt;/p></description></item><item><title>POJ PKU 2596 Dice Stacking 解题报告</title><link>//owent.net/2010/59.html</link><pubDate>Fri, 19 Feb 2010 12:31:50 +0000</pubDate><guid>//owent.net/2010/59.html</guid><description>&lt;p>状态压缩+DP&lt;/p>
&lt;p>1972的增强版&lt;/p>
&lt;p>题目链接：&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2596">http://acm.pku.edu.cn/JudgeOnline/problem?id=2596&lt;/a>&lt;/p>
&lt;p>题意是给出小于10个的骰子，要求竖着叠成一条，而且每两个相接的骰子相接的面的数字相同&lt;/p>
&lt;p>求侧面数字的最大和。如果叠不出来输出0&lt;/p></description></item><item><title>POJ PKU 1990 MooFest 解题报告</title><link>//owent.net/2009/63.html</link><pubDate>Wed, 23 Dec 2009 14:12:52 +0000</pubDate><guid>//owent.net/2009/63.html</guid><description>&lt;p>为什么我用线段数这么不灵活呢？&lt;/p>
&lt;p>大概思路是线段数记录某牛之前的坐标小于这个牛的牛的坐标和和牛的个数&lt;/p>
&lt;p>然后其他部分线性数组记录&lt;/p>
&lt;p>OK，贴代码&lt;/p>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

#define MAXN 20005
class cow
{
public:
 int v;
 int pos;
 cow(){};
 ~cow(){};
};

bool cmp(cow a,cow b)
{
 return a.v &amp;lt; b.v;
}
cow cw[MAXN];
long long belowXNT[MAXN];//树状数组，保存小于等于某坐标的牛的个数,计算时使用
long long belowXN[MAXN];//一般数组，保存小于等于某坐标和索引的牛的个数
long long velowXRT[MAXN];//树状数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和,计算时使用
long long velowXR[MAXN];//一般数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和
long long velowXRA[MAXN];//一般数组，保存小于等于某牛的坐标之和

int lowbit(int t)
{
 return t&amp;amp;(t^(t-1));
}
void setVal(int pos, int num, long long treeG[], int maxn)
{
 while (pos &amp;lt;= maxn)
 {
 treeG[pos] += num;
 pos += lowbit(pos);
 }
}
long long getSum(int pos, long long treeG[])
{
 long long sum = 0;
 while (pos &amp;gt; 0)
 {
 sum += treeG[pos];
 pos -= lowbit(pos);
 }
 return sum;
}



int main()
{
 int i,n;
 long long output = 0;
 memset(belowXN, 0, sizeof(belowXN));
 memset(belowXNT, 0, sizeof(belowXN));
 memset(velowXR, 0, sizeof(velowXR));
 memset(velowXRA, 0, sizeof(velowXRA));
 memset(velowXRT, 0, sizeof(velowXRT));
 scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
 for(i = 0 ; i &amp;lt; n ; i ++)
 scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;cw[i].v, &amp;amp;cw[i].pos);

 sort(cw, cw + n, cmp);
 for(i = 0 ; i &amp;lt; n ; i ++)
 {
 velowXRA[i] = velowXRA[i - 1] + cw[i].pos;
 setVal(cw[i].pos, 1, belowXNT, MAXN);
 setVal(cw[i].pos, cw[i].pos, velowXRT, MAXN);
 velowXR[i] = getSum(cw[i].pos, velowXRT);
 belowXN[i] = getSum(cw[i].pos, belowXNT);
 }

 for(i = 1 ; i &amp;lt; n ; i ++)
 //output += cw[i].v * ((belowXN[i] - 1) * cw[i].pos - velowXR[i] + cw[i].pos + velowXRA[i] - velowXR[i] - (i - belowXN[i] + 1) * cw[i].pos);
 output += cw[i].v * ((belowXN[i] - i + belowXN[i] - 1 ) * cw[i].pos - 2 * velowXR[i] + velowXRA[i]);//这里是上面式子的简化版

 printf(&amp;quot;%lld\n&amp;quot;,output);
 return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>POJ PKU 2378 Tree Cutting 解题报告</title><link>//owent.net/2009/64.html</link><pubDate>Wed, 23 Dec 2009 14:09:13 +0000</pubDate><guid>//owent.net/2009/64.html</guid><description>&lt;p>又来发解题报告了&lt;/p>
&lt;p>这回是树状DP&lt;/p>
&lt;pre>&lt;code class="language-cpp">/*
 * 树状DP
 * 首先把数据想象成树状的
 * 由于输入数据为树状，不需要构建树
 * 可令degree[i]为包括i且以i为根节点的所有子节点数量
 * dp[i]为删除i后的最大子节点数量或父亲节点数量 （这里我理解了很久）
 */
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
vector&amp;lt;int&amp;gt;chirld[10002];
int dp[10002] = {0}
 ,degree[10002] = {0}
 ,isJudged[10002] = {0};

int search(int pos,int &amp;amp;n);
int main()
{
 int n,i,a,b;
 bool isnone = true;
 scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
 for(i = 1 ; i &amp;lt; n ; i ++)
 {
 scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;a,&amp;amp;b);
 chirld[a].push_back(b);
 chirld[b].push_back(a);
 }

 search(1 , n);

 for(i = 1 ; i &amp;lt;= n ; i ++)
 if(dp[i] * 2 &amp;lt;= n)
 printf(&amp;quot;%d\n&amp;quot;,i) , isnone = false;

 if(isnone)
 printf(&amp;quot;NONE\n&amp;quot;);
 return 0;
}

int search(int pos,int &amp;amp;n)
{
 int i,j;
 degree[pos] = 1;
 isJudged[pos] = 1;
 dp[pos] = 0;

 for(i = 0 ; i &amp;lt; chirld[pos].size() ; i ++)
 {
 if(!isJudged[chirld[pos].at(i)])//如果已经判断过就是父亲节点了
 {
 degree[pos] += search(chirld[pos].at(i) , n);
 if(dp[pos] &amp;lt; degree[chirld[pos].at(i)])
 dp[pos] = degree[chirld[pos].at(i)];
 }
 }

 if(dp[pos] &amp;lt; n - degree[pos])//判断父亲节点数量
 dp[pos] = n - degree[pos];
 return degree[pos];
}
&lt;/code>&lt;/pre></description></item><item><title>POJ PKU 2528 Mayor's posters 解题报告</title><link>//owent.net/2009/65.html</link><pubDate>Wed, 18 Nov 2009 17:49:55 +0000</pubDate><guid>//owent.net/2009/65.html</guid><description>&lt;p>题目链接: &lt;a href="http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528">http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528&lt;/a>&lt;/p>
&lt;p>这题又是线段树+离散化&lt;/p>
&lt;p>慢慢的对离散化有点感觉了,但是这题我还是错了3次&lt;/p>
&lt;p>题目大意是一层一层地叠板子,问最后能看到几块&lt;/p>
&lt;p>输入是板子的开始和结束位置&lt;/p></description></item><item><title>POJ PKU 3277 City Horizon 解题报告</title><link>//owent.net/2009/67.html</link><pubDate>Thu, 12 Nov 2009 17:23:39 +0000</pubDate><guid>//owent.net/2009/67.html</guid><description>&lt;p>题目链接:&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3277">http://acm.pku.edu.cn/JudgeOnline/problem?id=3277&lt;/a>&lt;/p>
&lt;p>线段树+离散化&lt;/p>
&lt;p>ACM预选赛过去了,可是我们队什么都没拿到,这给我们的打击是相当大的,这也很大程度上体现了我们的不足&lt;/p>
&lt;p>一直没能静下心,来,今天决定不能再这么悲伤下去,我要奋斗,继续学习,就从之前的断点线段树开始&lt;/p></description></item><item><title>POJ PKU 2549 Sumsets 解题报告</title><link>//owent.net/2009/69.html</link><pubDate>Sun, 04 Oct 2009 15:54:36 +0000</pubDate><guid>//owent.net/2009/69.html</guid><description>&lt;p>&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2549">题目链接http://acm.pku.edu.cn/JudgeOnline/problem?id=2549&lt;/a>&lt;/p>
&lt;p>这道题伤了我很久脑筋&lt;/p>
&lt;p>因为是a+b+c=d,数据量是1000,很自然地想到a+b=d-c&lt;/p>
&lt;p>这样转化为n^2的算法.&lt;/p>
&lt;p>但是我开始枚举d-c的集合二分查找a+b的几何不知道为什么WA掉了&lt;/p></description></item><item><title>最长单调子序列 复杂度nlog(n)</title><link>//owent.net/2009/74.html</link><pubDate>Wed, 16 Sep 2009 04:44:59 +0000</pubDate><guid>//owent.net/2009/74.html</guid><description>&lt;pre>&lt;code class="language-cpp">//最长单调子序列 复杂度nlog(n)
//参数(原序列,序列长度,生成的序列),传入序列长度必须大于0
//返回值中lengthRecord中前k项表示长度为k的最小字序列
//LIScmp为关系函数,原函数表明lengthRecord为递增(不含等于)
typedef double LISTYPE;
#define LISMAXN 10000
int LIScmp(LISTYPE a,LISTYPE b)
{
 return a &amp;lt; b;
}
long LISLength(LISTYPE list[],long n,LISTYPE lengthRecord[])
{
 long length = 1,lth;
 LISTYPE lR[LISMAXN];
 lR[0] = list[0];

 for(int i = 1 ; i &amp;lt; n ; i ++)
 {
 //二分查找,复杂度 log(n)
 int b,e,m;
 b = 0;
 e = length - 1;
 while(b &amp;lt;= e &amp;amp;&amp;amp; e &amp;gt;= 0)
 {
 m = (b + e) / 2;
 if(LIScmp(lR[m],list[i]))
 b = m + 1;
 else
 e = m - 1;
 }
 lR[b] = list[i];
 if(b &amp;gt;= length)
 length ++;
 }
 /*
 *计算序列部分
 *复杂度nlog(n)
 */
 lth = 1;
 for(int i = 1 ; i &amp;lt; n ; i ++)
 {
 //二分查找,复杂度 log(n)
 int b,e,m;
 b = 0;
 e = lth - 1;
 while(b &amp;lt;= e &amp;amp;&amp;amp; e &amp;gt;= 0)
 {
 m = (b + e) / 2;
 if(LIScmp(lR[m],list[i]))
 b = m + 1;
 else
 e = m - 1;
 }
 lR[b] = list[i];
 if(b &amp;gt;= lth)
 lth ++;
 if(lth == length)
 {
 for(b = 0 ; b &amp;lt; length ; b ++)
 lengthRecord[b] = lR[b];
 break;
 }
 }
 //计算序列部分代码与之前的类似,可以直接Copy然后修改
 return length;
}
&lt;/code>&lt;/pre></description></item><item><title>Prime最小生成树(个人模板)</title><link>//owent.net/2009/75.html</link><pubDate>Tue, 15 Sep 2009 16:43:29 +0000</pubDate><guid>//owent.net/2009/75.html</guid><description>&lt;pre>&lt;code class="language-cpp">//Prime连通路模块
#define N 1000 //最大数据规模
#define MAXNUM 3000000 //最大路径长度
typedef double PrimeType;//路径类型

PrimeType PrimeRecord[N];
PrimeType dis[N][N];
int isLined[N] = {1,0};

PrimeType GetPrimeLength(const long n)
{
 PrimeType tmpLen = MAXNUM;
 long tmpPos = 0,left = n - 1;
 PrimeType sumLen = 0;

 for(long i = 1 ; i &amp;lt; n ; i ++)
 PrimeRecord[i] = dis[0][i];
 while(left --)
 {
 tmpLen = MAXNUM;
 for(long i = 1 ; i &amp;lt; n ; i ++)
 if(!isLined[i] &amp;amp;&amp;amp; PrimeRecord[i] &amp;lt; tmpLen)
 tmpPos = i,tmpLen = PrimeRecord[i];

 sumLen += tmpLen;
 isLined[tmpPos] ++;
 for(long i = 1 ; i &amp;lt; n ; i ++)
 if(dis[tmpPos][i] &amp;lt; PrimeRecord[i])
 PrimeRecord[i] = dis[tmpPos][i];
 }

 return sumLen;
}
&lt;/code>&lt;/pre></description></item><item><title>矩阵相关 (增强中)</title><link>//owent.net/2009/76.html</link><pubDate>Tue, 15 Sep 2009 16:39:11 +0000</pubDate><guid>//owent.net/2009/76.html</guid><description>&lt;pre>&lt;code class="language-cpp">//MULDATATYPE为矩阵元素类型,MAXMAT为最大矩阵大小

typedef long MULDATATYPE;
#define MAXMAT 100
#define inf 1000000000

#define fabs(x) ((x)&amp;gt;0?(x):-(x))
#define zero(x) (fabs(x)&amp;lt;1e-10)

struct mat
{
 long n,m;
 MULDATATYPE data[MAXMAT][MAXMAT];
 void operator =(const mat&amp;amp; a);
 mat operator +(const mat&amp;amp; a);
 mat operator -(const mat&amp;amp; a);
 //0-1邻接矩阵
 mat operator &amp;amp;(const mat&amp;amp; a);
 mat operator |(const mat&amp;amp; a);
};

//c=a*b
//注意引用
int Mat_MulMode(mat&amp;amp; c,const mat&amp;amp; a,const mat&amp;amp; b,MULDATATYPE mod)
{
 long i,j,k;
 if (a.m != b.n)
 return 0;
 c.n = a.n , c.m = b.m;
 for (i = 0 ; i &amp;lt; c.n ; i ++)
 for (j = 0 ; j &amp;lt; c.m ; j ++)
 for (c.data[i][j] = k = 0 ; k &amp;lt; a.m ; k ++)
 c.data[i][j] = (c.data[i][j] + a.data[i][k] * b.data[k][j]) % mod;
 return 1;
}
//c=a^b(其中必须满足b&amp;gt;0)
int Mat_PowMode(mat&amp;amp; c,mat a,long b,MULDATATYPE mod)
{
 c = a;
 b --;
 while(b)
 {
 mat tmp;
 if(b &amp;amp; 1)
 {
 tmp = c;
 Mat_MulMode(c,tmp,a,mod);
 }
 tmp = a;
 Mat_MulMode(a,tmp,tmp,mod);
 b = b&amp;gt;&amp;gt;1;
 }
 return 1;
}
//c=a+b
int Mat_AddMode(mat&amp;amp; c,const mat&amp;amp; a,const mat&amp;amp; b,MULDATATYPE mod)
{
 long i,j;
 if (a.n != b.n || a.m != b.m)
 return 0;
 c.n = a.n , c.m = b.m;
 for (i = 0 ; i &amp;lt; c.n ; i ++)
 for (j = 0 ; j &amp;lt; c.m ; j ++)
 c.data[i][j] = (a.data[i][j] + b.data[i][j]) % mod;
 return 1;
}
//c=a-b
int Mat_SubMode(mat&amp;amp; c,const mat&amp;amp; a,const mat&amp;amp; b,MULDATATYPE mod)
{
 long i,j;
 if (a.n != b.n || a.m != b.m)
 return 0;
 c.n = a.n , c.m = b.m;
 for (i = 0 ; i &amp;lt; c.n ; i ++)
 for (j = 0 ; j &amp;lt; c.m ; j ++)
 c.data[i][j] = (a.data[i][j] - b.data[i][j]) % mod;
 return 1;
}


void mat::operator =(const mat&amp;amp; a)
{
 n = a.n;
 m = a.m;
 for(int i = 0 ; i &amp;lt; n ; i ++)
 for(int j = 0 ; j &amp;lt; m ; j ++)
 data[i][j] = a.data[i][j];
}
mat mat::operator +(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] + a.data[i][j];
 return tmpMat;
}
mat mat::operator -(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] - a.data[i][j];
 return tmpMat;
}
mat mat::operator &amp;amp;(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] &amp;amp; a.data[i][j];
 return tmpMat;
}
mat mat::operator |(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] | a.data[i][j];
 return tmpMat;
}
&lt;/code>&lt;/pre></description></item><item><title>09年8月14日 ECUST ACM 练习赛总结</title><link>//owent.net/2009/77.html</link><pubDate>Sun, 16 Aug 2009 16:57:22 +0000</pubDate><guid>//owent.net/2009/77.html</guid><description>&lt;p>今天在湖南的OJ上做题,发现不到两小时,他服务器就挂了,但是发现他和POJ上的一些题一样而且是连号的,就到POJ上继续了，我们队出了6题。&lt;/p>
&lt;p>A题是&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3507">POJ的3507 Judging Olympia&lt;/a>这题是队友干掉的,我没看&lt;/p></description></item><item><title>ECUST 09年 校赛个人赛第八场（最后一场）总结</title><link>//owent.net/2009/78.html</link><pubDate>Fri, 14 Aug 2009 11:41:45 +0000</pubDate><guid>//owent.net/2009/78.html</guid><description>&lt;p>懒惰了，暂时休息一下&lt;/p>
&lt;p>这次我只AC了一题（在结束的那一刻，另一题在题目来源地网站上AC了，我们的OJ上仍然WA，我们OJ的Special Judge真是—_—!）&lt;/p></description></item><item><title>ECUST 09年 校赛个人训练赛第五场总结</title><link>//owent.net/2009/79.html</link><pubDate>Fri, 14 Aug 2009 11:40:56 +0000</pubDate><guid>//owent.net/2009/79.html</guid><description>&lt;h1 id="校赛个人训练赛第五场报告">校赛个人训练赛第五场报告&lt;/h1>
&lt;p>今天战绩还行，AC了5题，今天总体没有太复杂的算法题，不过测试数据强度比之前有所增加
我的钱四题很早就过了，但是第五题很晚才出主要是代码写得太混乱，思路也错了两次
我过的题有五道，分别是ABCDG&lt;/p></description></item><item><title>点到直线距离 和 线段间最短距离 (OWenT 模板)</title><link>//owent.net/2009/80.html</link><pubDate>Fri, 14 Aug 2009 11:33:38 +0000</pubDate><guid>//owent.net/2009/80.html</guid><description>&lt;p>点到直线距离&lt;/p>
&lt;pre>&lt;code class="language-cpp">// (x0,y0)到(x1,y1)和(x2,y2)确定的直线的距离

double disBetweenPointAndLine(double x0,double y0,double x1,double y1,double x2,double y2)
{
 //化为ax+by+c=0的形式
 double a = y1-y2;
 double b = x2-x1;
 double c = x1*y2-x2*y1;
 double d = (a*x0+b*y0+c)/sqrt(a*a+b*b);
 /*
 如果是线段判断垂足

 double xp = (b*b*x0-a*b*y0-a*c)/(a*a+b*b);
 double yp = (-a*b*x0+a*a*y0-b*c)/(a*a+b*b);
 double xb = (x1&amp;gt;x2)?x1:x2;
 double yb = (y1&amp;gt;y2)?y1:y2;
 double xs = x1+x2-xb;
 double ys = y1+y2-yb;
 if(xp &amp;gt; xb || xp &amp;lt; xs || yp &amp;gt; yb || yp &amp;lt; ys)
 {
 d = sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
 if(d &amp;gt; sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2)))
 d = sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2));
 }
 */
 return fabs(d);
}
&lt;/code>&lt;/pre>
&lt;p>线段间最短距离&lt;/p></description></item><item><title>连接最多点直线 (OWenT 个人模板)</title><link>//owent.net/2009/81.html</link><pubDate>Fri, 14 Aug 2009 11:30:49 +0000</pubDate><guid>//owent.net/2009/81.html</guid><description>&lt;pre>&lt;code class="language-cpp">//n每个用例的点个数
//MAXN为最大点个数
//PTYPE为坐标值类型
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;

#define MAXN 1005
#define EPS 1e-10
typedef double PTYPE;

struct point
{
 PTYPE x,y;
};
struct node
{
 PTYPE k;
};
int cmp(const void * a, const void * b)
{
 return((*(PTYPE*)a-*(PTYPE*)b&amp;gt;0)?1:-1);
}
node numK[MAXN * MAXN / 2];
point pt[MAXN];
int main()
{

 int n , maxNum = 1 , tmpNum = 0;
 while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n),n)
 {
 for(int i = 0 ; i &amp;lt; n ; i ++)
 scanf(&amp;quot;%lf %lf&amp;quot;,&amp;amp;pt[i].x,&amp;amp;pt[i].y);
 for(int i = 0 ; i &amp;lt; n ; i ++)
 {
 int pos = 0;
 for(int j = i + 1 ; j &amp;lt; n ; j ++)
 if((pt[i].x - pt[j].x) &amp;gt; EPS)
 numK[pos ++].k = (pt[j].y - pt[i].y) / (pt[j].x - pt[i].x);
 else
 numK[pos ++].k = 100000;

 qsort(numK,pos,sizeof(numK[0]),cmp);
 int tmpNum = 2;
 for(int j = 1 ; j &amp;lt; pos ; j ++)
 {
 if(numK[j].k == numK[j - 1].k)
 tmpNum ++;
 else
 {
 if(tmpNum &amp;gt; maxNum)
 maxNum = tmpNum;
 tmpNum = 2;
 }
 }
 if(tmpNum &amp;gt; maxNum)
 maxNum = tmpNum;
 }


 printf(&amp;quot;%d\n&amp;quot;,maxNum);
 maxNum = 1;
 }
 return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>09年8月9日 ECUST ACM 练习赛总结</title><link>//owent.net/2009/82.html</link><pubDate>Mon, 10 Aug 2009 16:14:16 +0000</pubDate><guid>//owent.net/2009/82.html</guid><description>&lt;h2 id="problem-a">&lt;a href="http://acm.hdu.edu.cn/diy/contest_showproblem.php?pid=1001&amp;amp;cid=3627&amp;amp;hide=1&amp;amp;problem=Problem%20%20A">Problem A&lt;/a>&lt;/h2>
&lt;p>我没看题,队友很快AC我就没花时间看&lt;/p>
&lt;h2 id="problem-b">&lt;a href="http://acm.hdu.edu.cn/diy/contest_showproblem.php?pid=1002&amp;amp;cid=3627&amp;amp;hide=1&amp;amp;problem=Problem%20%20B">Problem B&lt;/a>&lt;/h2>
&lt;p>DP题,但是我们确实都没想到方法,实在是我们的经验不足&lt;/p>
&lt;p>B题补充:
B题的DP方法比较诡异(起码我理解了很久)
令fn[i][j]为有i个数j次交换位置的排列数量
很明显,当i+1时,如果把新增的数放在最后一位,那么交换次数不变(新增的数为i+1,最大).
如果把新增的数放在第1到i位之间的话有i种放法,
对于每一种fn[i][j]的排列中我们总能找到一种序列使得{(.)(.)(&lt;em>)(.)(.)…(i+1)},[&amp;quot;()表示一个元素&amp;quot;]
中(i+1)和(&lt;/em>)交换位置后前i个元素的排列和其相同
又因为(*)的位置可以有i种放法,以此我们发现,fn[i+1][j]=fn[i][j]+fn[i][j-1]×i
继续贴代码:&lt;/p></description></item><item><title>牛顿迭代解方程 ax^3+bX^2+cx+d=0</title><link>//owent.net/2009/83.html</link><pubDate>Wed, 05 Aug 2009 16:27:32 +0000</pubDate><guid>//owent.net/2009/83.html</guid><description>&lt;p>$$ ax^3+bX^2+cx+d=0 $$&lt;/p>
&lt;p>根的关系:&lt;/p>
&lt;p>$$ x1 + x2 + x3 = (-\frac{b}{a}) $$&lt;/p>
&lt;p>$$ x1 \times x2 + x1 \times x3 + x2 \times x3 = \frac{c}{a} $$&lt;/p>
&lt;p>$$ x1 \times x2 \times x3 = (-\frac{d}{a}) $$&lt;/p>
&lt;p>牛顿迭代解方程(x0附近的根)&lt;/p>
&lt;pre>&lt;code class="language-cpp">double Newton_Iterative(double a,double b,double c,double d,double x0)
{
 double f0,f0d,x;
 x = x0;
 do
 {
 x0 = x;
 f0 = ((a * x + b) * x + c) * x + d;
 f0d = ( 3 * a * x + 2 * b ) * x + c;
 x = x0 - f0 / f0d;
 }
 while(fabs(f0) &amp;gt;= 1e-12);
 return x;
}
&lt;/code>&lt;/pre>
&lt;p>牛顿迭代法&lt;/p></description></item><item><title>ECUST 09年 校赛个人赛第三场部分解题报告(A,D,F,I)</title><link>//owent.net/2009/84.html</link><pubDate>Thu, 30 Jul 2009 09:58:51 +0000</pubDate><guid>//owent.net/2009/84.html</guid><description>&lt;p>校赛个人赛第三场部分解题报告（A,D,F,I）&lt;/p>
&lt;p>这次我完成了四道题分别是A,D,F,I&lt;/p>
&lt;p>一大半时间我都花在了A上，我犯了很究级的错误&lt;/p>
&lt;p>首先是VC6.0的algorithm里没有min函数，而我用min做变量名导致CE4次，找了半天才找出来&lt;/p></description></item><item><title>ECUST 09年 校赛个人赛第六，七场总结</title><link>//owent.net/2009/85.html</link><pubDate>Thu, 30 Jul 2009 09:58:00 +0000</pubDate><guid>//owent.net/2009/85.html</guid><description>&lt;p>校赛个人赛第六，七场总结&lt;/p>
&lt;p>这两场比赛体现了英文水平的重要性&lt;/p>
&lt;p>第六场的题目超长，用词还诡异，话了很长时间才看懂&lt;/p>
&lt;p>这两场题目都比较有难度，第六场我只出了2题&lt;/p>
&lt;h2 id="a-grey-area">A Grey Area&lt;/h2>
&lt;p>A题是很诡异的统计，是一道纯模拟就能过的题，其他的不多说了&lt;/p></description></item><item><title>POJ 2606 Rabbit hunt 2780 Linearity 1118 Lining Up 解题报告</title><link>//owent.net/2009/88.html</link><pubDate>Mon, 20 Jul 2009 14:50:15 +0000</pubDate><guid>//owent.net/2009/88.html</guid><description>&lt;p>POJ打破传统,以前是做一题送一题,现在是做一题送两题,那么我们就不用客气了&lt;/p>
&lt;p>言归正传 题号:&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2606">2606 Rabbit hunt&lt;/a> &lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2780">2780 Linearity&lt;/a> &lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1118">1118 Lining Up&lt;/a>&lt;/p>
&lt;p>大致题意是输入N个点.计算能穿过最多的点的直线,并输出最大点的个数&lt;/p></description></item><item><title>POJ 3267 The Cow Lexicon 解题报告</title><link>//owent.net/2009/90.html</link><pubDate>Wed, 15 Jul 2009 15:51:39 +0000</pubDate><guid>//owent.net/2009/90.html</guid><description>&lt;p>&lt;a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3267">POJ 3267 The Cow Lexicon&lt;/a>&lt;/p>
&lt;p>这题是一道DP问题,我的想法如下:&lt;/p>
&lt;p>1.可以令
deleteNum[pos]为输入字符串在pos处需要删除的最少字符数量;&lt;/p>
&lt;p>2.如果输入字符串长度为len,则初始化deleteNum[len] = 0;(字符串由0开始计数)&lt;/p></description></item><item><title>并查集 模板</title><link>//owent.net/2009/91.html</link><pubDate>Wed, 15 Jul 2009 09:05:54 +0000</pubDate><guid>//owent.net/2009/91.html</guid><description>&lt;pre>&lt;code class="language-cpp">//并查集
//注意类型匹配
const int maxn = 100002;
int DSet[maxn];
void init(int n) {
 for(int i = 0 ; i &amp;lt;= n ; i ++)
 DSet[i] = i;
}
int findP(int id) {
if(DSet[id] != id)
 DSet[id] = findP(DSet[id]);
 return DSet[id];
}
//返回根节点ID
int UnionEle(int a,int b) {
 a = findP(a);
 b = findP(b);
 if(a &amp;gt; b)
 a ^= b ^= a ^= b;
 DSet[b] = a;
 return a;
}
&lt;/code>&lt;/pre></description></item><item><title>模式匹配(kmp)个人模板</title><link>//owent.net/2009/92.html</link><pubDate>Mon, 06 Jul 2009 20:34:01 +0000</pubDate><guid>//owent.net/2009/92.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * KMP模式匹配
 * 算法复杂度O(m+n)
 * ACM 模板 
 *
 * @Author OWenT
 * @link http://www.owent.net
 */

// 最大字符串长度
const int maxLen = 10000;
// 前一个匹配位置,多次匹配注意要重新初始化
// 注：preMatch[i]表示0~preMatch[i-1]能和?~i匹配
int preMatch[maxLen]={0};

/**
 * kmp匹配算法
 * @param char[] source 查找源
 * @param char[] checked 查找目标
 * @return int 根据以下两个分支返回值分别表示不同的含义
 */
int kmp_match(char source[],char checked[]) {
 int i = 0, j = 0;
 memset(preMatch, 0, sizeof(preMatch));

 if(!checked[i]) // 被匹配串为空串，直接返回 0
 return 0;

 ++ i;
 while(checked[i]) {
 for(j = preMatch[i - 1]; checked[i] != checked[j] &amp;amp;&amp;amp; j; j = preMatch[j - 1]);
 preMatch[i] = (checked[i] == checked[j])? j + 1 : 0 ;
 ++ i;
 }
 //计算匹配子串个数(子串间无重叠)(与以下一起二选一)
 int num = 0;//计数变量
 for(i = j = 0; source[i]; ++ i) {
 if(checked[j] == source[i])
 ++ j;
 else if(j)
 -- i, j = preMatch[j - 1];

 if(!checked[j])
 ++ num, j = 0;//如果要子串间重叠 则此句中j = 0 改成 j = preMatch[j - 1]
 }
 return num;

 //计算首个匹配子串位置(与以上一起二选一)
 for(i = j = 0; checked[j] &amp;amp;&amp;amp; source[i]; ++ i) {
 if(checked[j] == source[i])
 ++ j;
 else if(j)
 -- i, j = preMatch[j - 1];
 }

 //返回匹配的串的第一个字符出现位置(从1开始计数,0表示无匹配)
 if(!checked[j])
 return i - j + 1;
 else
 return 0;

 return 0;
}
&lt;/code>&lt;/pre></description></item></channel></rss>