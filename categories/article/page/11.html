<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Article|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/categories/article.html><link rel=alternate type=application/rss+xml href=//owent.net/categories/article/index.xml title="I'm OWenT"><link rel=icon href=../../../favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><script type=text/javascript src=//unpkg.com/jquery@latest/dist/jquery.slim.min.js crossorigin=anonymous></script><link rel=stylesheet href=//owent.net/css/syntax.css><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><script async custom-element=amp-ad src=https://cdn.ampproject.org/v0/amp-ad-0.1.js></script><meta name=baidu-site-verification content="codeva-4M5iohb9TW"></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=../../../ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=../../../archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=../../../about.html title=About>About</a></li><li class=nav-item><a id=nav-rss-link class=nav-link href=//owent.net/categories/article/index.xml title=RSS订阅>RSS订阅</a></li><li class="nav-item nav-ads ads-placeholder ads-container"><amp-ad layout=fixed width=120 height=52 type=adsense data-ad-client=ca-pub-8180054975285991 data-ad-slot=4450372783></amp-ad></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=archive-content><article class="article-panel archive-article archive-type-45"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/45.html target=_blank itemprop=url>PKU POJ 2728 Desert King 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2728">http://acm.pku.edu.cn/JudgeOnline/problem?id=2728</a></p><p>和3757一样都是01分数规划的题，不同的是3757是用的二分，这里用的是Prim</p><p>0-1背包部分和3757一样</p><p>令m(l) = min{∑(1.0 * h[i][j] - l * dis[i][j] )}</p></div><div class=article-more><a href=//owent.net/2010/45.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-04-07T10:51:26.000+00:00 itemprop=datePublished>2010-04-07</time></div></div></article><article class="article-panel archive-article archive-type-46"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/46.html target=_blank itemprop=url>PKU POJ 1141 Brackets Sequence 解题报告</a></h1></header><div class=article-summary><p>链接: <a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1141">http://acm.pku.edu.cn/JudgeOnline/problem?id=1141</a>
题目意思是输入一些括号，补充括号使之成为没有错误的括号就是只能有括号组在括号组里面，不能出现([)]或者([)]一类的情况
方法是DP，有点绕的DP
DP方程是 <em>bc[i][j] = min(bc[i][k] + bc[k][j])</em> 注：bc[i][j]表示字符i和字符j之间需要插入几个括弧
然后尽量多地分割字符串
不解释，贴代码：</p></div><div class=article-more><a href=//owent.net/2010/46.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-04-05T16:52:28.000+00:00 itemprop=datePublished>2010-04-05</time></div></div></article><article class="article-panel archive-article archive-type-47"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/47.html target=_blank itemprop=url>POJ PKU 2155 Matrix 解题报告</a></h1></header><div class=article-summary><p>这道题是我专门为了了解和学习树状数组而写的</p><p>这题用树状数组记录翻转次数,然后mod一个2,也可以不断地取反</p><p>还要用到二维的树状数组.于是我专门写了个模板用</p></div><div class=article-more><a href=//owent.net/2010/47.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-04-05T11:01:59.000+00:00 itemprop=datePublished>2010-04-05</time></div></div></article><article class="article-panel archive-article archive-type-48"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/48.html target=_blank itemprop=url>PKU POJ 1720 SQUARES 解题报告</a></h1></header><div class=article-summary><p>题目链接：http://acm.pku.edu.cn/JudgeOnline/problem?id=1720</p><p>这题纯计算几何就搞定了，开始我写了个很长很长的代码，但是Wa掉，也不知道是代码那里有疏漏还是精度问题</p></div><div class=article-more><a href=//owent.net/2010/48.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-04-03T17:12:41.000+00:00 itemprop=datePublished>2010-04-03</time></div></div></article><article class="article-panel archive-article archive-type-50"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/50.html target=_blank itemprop=url>PKU POJ 1724 ROADS 解题报告</a></h1></header><div class=article-summary><p>看来我的搜索真的很烂，简单的搜索都搞定的这么痛苦</p><p>题目链接：http://acm.pku.edu.cn/JudgeOnline/problem?id=1724</p></div><div class=article-more><a href=//owent.net/2010/50.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-04-02T17:07:50.000+00:00 itemprop=datePublished>2010-04-02</time></div></div></article><article class="article-panel archive-article archive-type-51"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/51.html target=_blank itemprop=url>注册表常用键值意义</a></h1></header><div class=article-summary><p>注册表常用键值意义</p><p>[HKEY_CURRENT_USER\Software\Policies\Microsoft\Internet Explorer\Control Panel]</p><p>;〖Internet Explorer选项类〗</p><p>&ldquo;HomePage&rdquo;=dword:00000001 ;禁止更改主页设置〖0=可修改〗</p><p>&ldquo;Cache&rdquo;=dword:00000001 ;禁止更改Internet临时文件设置〖0=可修改〗</p></div><div class=article-more><a href=//owent.net/2010/51.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-04-02T05:50:53.000+00:00 itemprop=datePublished>2010-04-02</time></div></div></article><article class="article-panel archive-article archive-type-52"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/52.html target=_blank itemprop=url>POJ PKU Let's Go to the Movies 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3513">http://acm.pku.edu.cn/JudgeOnline/problem?id=3513</a></p><p>题目大意是输入树状的家庭关系，问怎么买票（买家庭票还是个人票）最省钱并且票的数量最少</p><p>这道题是一道Hash+树状DP问题。编码长度相当可观，需要较好的编码能力</p></div><div class=article-more><a href=//owent.net/2010/52.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-31T16:04:21.000+00:00 itemprop=datePublished>2010-03-31</time></div></div></article><article class="article-panel archive-article archive-type-53"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/53.html target=_blank itemprop=url>ZOJ 3309 Search New Posts 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3309">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3309</a></p><p>一道典型的Hash题</p><p>题目很好理解。这里不复述</p><p>由于输入语句最大数量200000，不用Hash铁定TLE。然后数据量不超过10000，所以必然有很多search和reply的操作。</p></div><div class=article-more><a href=//owent.net/2010/53.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-15T14:49:52.000+00:00 itemprop=datePublished>2010-03-15</time></div></div></article><article class="article-panel archive-article archive-type-54"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/54.html target=_blank itemprop=url>Hash模板 个人模板</a></h1></header><div class=article-summary><pre><code class=language-cpp>/**
 * Hash模板
 * Based: 0
 * template&lt;unsigned long _SZ,class _T, unsigned long *pFun(_T _Off)&gt;
 * class _My_Hash_ToInt
 * 传入数据大小_SZ,传入类型_T,Hash函数
 * 传入类型_T必须重载 = 和 == 符号
 * 收录了ELFHash函数
 * 主要是为了判重的简化些的模板
 * Hash算法性能比较见 http://www.cnblogs.com/lonelycatcher/archive/2011/08/23/2150587.html
 */

const long hashsize = 51071; //Hash表大小(注意修改)
// 各种Hash算法
unsigned int SDBMHash(char *str)
{
    unsigned int hash = hashsize;

    while (*str)
    {
        // equivalent to: hash = 65599*hash + (*str++);
        hash = (*str++) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;
    }

    return (hash &amp; 0x7FFFFFFF);
}

// RS Hash Function
unsigned int RSHash(char *str)
{
    unsigned int b = 378551;
    unsigned int a = 63689;
    unsigned int hash = hashsize;

    while (*str)
    {
        hash = hash * a + (*str++);
        a *= b;
    }

    return (hash &amp; 0x7FFFFFFF);
}

// JS Hash Function
unsigned int JSHash(char *str)
{
    unsigned int hash = 1315423911;

    while (*str)
    {
        hash ^= ((hash &lt;&lt; 5) + (*str++) + (hash &gt;&gt; 2));
    }

    return (hash &amp; 0x7FFFFFFF);
}

// P. J. Weinberger Hash Function
unsigned int PJWHash(char *str)
{
    unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8);
    unsigned int ThreeQuarters    = (unsigned int)((BitsInUnignedInt  * 3) / 4);
    unsigned int OneEighth        = (unsigned int)(BitsInUnignedInt / 8);
    unsigned int HighBits         = (unsigned int)(0xFFFFFFFF) &lt;&lt; (BitsInUnignedInt - OneEighth);
    unsigned int hash             = hashsize;
    unsigned int test             = 0;

    while (*str)
    {
        hash = (hash &lt;&lt; OneEighth) + (*str++);
        if ((test = hash &amp; HighBits) != 0)
        {
            hash = ((hash ^ (test &gt;&gt; ThreeQuarters)) &amp; (~HighBits));
        }
    }

    return (hash &amp; 0x7FFFFFFF);
}

// ELF Hash Function
unsigned int ELFHash(char *str)
{
    unsigned int hash = hashsize;
    unsigned int x    = 0;

    while (*str)
    {
        hash = (hash &lt;&lt; 4) + (*str++);
        if ((x = hash &amp; 0xF0000000L) != 0)
        {
            hash ^= (x &gt;&gt; 24);
            hash &amp;= ~x;
        }
    }

    return (hash &amp; 0x7FFFFFFF);
}

// BKDR Hash Function
unsigned int BKDRHash(char *str)
{
    unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
    unsigned int hash = hashsize;

    while (*str)
    {
        hash = hash * seed + (*str++);
    }

    return (hash &amp; 0x7FFFFFFF);
}

// DJB Hash Function
unsigned int DJBHash(char *str)
{
    unsigned int hash = 5381;

    while (*str)
    {
        hash += (hash &lt;&lt; 5) + (*str++);
    }

    return (hash &amp; 0x7FFFFFFF);
}

// AP Hash Function
unsigned int APHash(char *str)
{
    unsigned int hash = hashsize;
    int i;

    for (i=0; *str; i++)
    {
        if ((i &amp; 1) == 0)
        {
            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));
        }
        else
        {
            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));
        }
    }

    return (hash &amp; 0x7FFFFFFF);
}

// 程序模板
template&lt;typename _T&gt;
class _My_Hash_ToInt_Data
{
public:
    _My_Hash_ToInt_Data()
    {
        times = 0;
        next = -1;
    }
    _T data;
    long times;
    long next;
};
template&lt;long _SZ,class _T, unsigned long pFun(_T&amp; _Off)&gt;
class _My_Hash_ToInt
{
public:
    _My_Hash_ToInt()
    {
        memset(hash, -1, sizeof(hash));
        length = 0;
    };
    ~_My_Hash_ToInt(){};
    long find(_T _Off)
    {
        long pos = hash[pFun(_Off)];
        while(pos &gt;= 0)
        {
            if(data[pos].data == _Off)
                return pos;
            else
                pos = data[pos].next;
        }
        return -1;
    }
    long insert(_T _Off)
    {
        long oldPos = pFun(_Off);
        long pos = hash[oldPos];
        while(pos &gt;= 0)
        {
            if(data[pos].data == _Off)
            {
                data[pos].times ++;
                return pos;
            }
            else
                pos = data[pos].next;
        }
        data[length].data = _Off;
        data[length].times = 1;
        data[length].next = hash[oldPos];
        hash[oldPos] = length ;
        return length ++;
    }
    void clear()
    {
        length = 0;
        memset(hash, -1, sizeof(hash));
        memset(data, -1, sizeof(data));
    }
    //Member
    long length;
    _My_Hash_ToInt_Data&lt;_T&gt; data[_SZ];
    long hash[hashsize];
};

//节点类（注意修改）
class node
{
public:
    char str[60];
    bool operator == (node &amp;strin)
    {
        return !strcmp(str, strin.str);
    }
    node&amp; operator = (node &amp;strin)
    {
        strcpy(str, strin.str);
        return (*this);
    }
};
//扩展Hash函数（注意修改）
unsigned long ELFHashEx(node &amp;strIn)
{
    return ELFHash(strIn.str);
}
_My_Hash_ToInt&lt;10005, node, ELFHashEx&gt;hash;//Hash类例子
</code></pre></div><div class=article-more><a href=//owent.net/2010/54.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-15T12:58:47.000+00:00 itemprop=datePublished>2010-03-15</time></div></div></article><article class="article-panel archive-article archive-type-55"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/55.html target=_blank itemprop=url>HDU 3336 Count the string 解题报告</a></h1></header><div class=article-summary><p>题目：
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3336">http://acm.hdu.edu.cn/showproblem.php?pid=3336</a></p><p>水题一道，主要是测试数据很水</p><p>不解释，贴代码：</p><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
using namespace std;

char str[200005];
vector&lt;long&gt;glo_Pos;
int main()
{
    int t;
    long output,i,n,j;
    scanf(&quot;%d&quot;,&amp;t);
    while(t --)
    {
        output = 0;
        glo_Pos.clear();
        scanf(&quot;%ld %s&quot;, &amp;n, str);

        for(i = 0; i &lt; n; i ++)
        {
            if(str[i] == str[0])
            {
                glo_Pos.push_back(i);
                output ++;
            }
        }
        output = output % 10007;
        for(i = 1; i &lt; n; i ++)
        {
            for(j = 0; j &lt; glo_Pos.size();j ++)
            {
                if(str[i] == str[glo_Pos[j] + i])
                    output = (output + 1) % 10007;
                else
                {
                    glo_Pos.erase(glo_Pos.begin() + j);
                    j --;
                }
            }
        }

        printf(&quot;%ld\n&quot;, output);
    }
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2010/55.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-15T11:12:56.000+00:00 itemprop=datePublished>2010-03-15</time></div></div></article><article class="article-panel archive-article archive-type-57"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/57.html target=_blank itemprop=url>POJ PKU 1065 Wooden Sticks 3636 Nested Dolls 解题报告</a></h1></header><div class=article-summary><p>3636 Nested Dolls</p><p>题目链接：[http://acm.pku.edu.cn/JudgeOnline/problem?id=3636</p><p>](<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3636">http://acm.pku.edu.cn/JudgeOnline/problem?id=3636</a>)好吧，这题我看了解题报告。而且解题报告有错误的。只考虑w递增，没考虑w值相等的情况。</p><p>我自己这里加进去了判断。主要是看解题报告后才知道数据这么弱，就按他的写了</p></div><div class=article-more><a href=//owent.net/2010/57.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-02-24T15:43:54.000+00:00 itemprop=datePublished>2010-02-24</time></div></div></article><article class="article-panel archive-article archive-type-58"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/58.html target=_blank itemprop=url>POJ PKU 3631 Cuckoo Hashing 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3631">http://acm.pku.edu.cn/JudgeOnline/problem?id=3631</a></p><p>我讨厌这么长的题目</p><p>这题是模拟那个Hash算法，有点像我之前转载的那篇文章里提到的Hash</p><p><a href=https://www.owent.net/2009/87.html>打造最快的Hash表(转) [以暴雪的游戏的Hash为例]</a> 这里是用两个Hash函数算出两个Hash值h1和h2，如果h1位置已经被占用就检查h2位置，如果都被占用就把原来的替换掉再给原来的字符串重新计算映射。这样下去可能出现死循环。会出现死循环就输出</p></div><div class=article-more><a href=//owent.net/2010/58.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-02-24T10:14:57.000+00:00 itemprop=datePublished>2010-02-24</time></div></div></article><article class="article-panel archive-article archive-type-59"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/59.html target=_blank itemprop=url>POJ PKU 2596 Dice Stacking 解题报告</a></h1></header><div class=article-summary><p>状态压缩+DP</p><p>1972的增强版</p><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2596">http://acm.pku.edu.cn/JudgeOnline/problem?id=2596</a></p><p>题意是给出小于10个的骰子，要求竖着叠成一条，而且每两个相接的骰子相接的面的数字相同</p><p>求侧面数字的最大和。如果叠不出来输出0</p></div><div class=article-more><a href=//owent.net/2010/59.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-02-19T12:31:50.000+00:00 itemprop=datePublished>2010-02-19</time></div></div></article><article class="article-panel archive-article archive-type-63"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/63.html target=_blank itemprop=url>POJ PKU 1990 MooFest 解题报告</a></h1></header><div class=article-summary><p>为什么我用线段数这么不灵活呢？</p><p>大概思路是线段数记录某牛之前的坐标小于这个牛的牛的坐标和和牛的个数</p><p>然后其他部分线性数组记录</p><p>OK，贴代码</p><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

#define MAXN 20005
class cow
{
public:
    int v;
    int pos;
    cow(){};
    ~cow(){};
};

bool cmp(cow a,cow b)
{
    return a.v &lt; b.v;
}
cow cw[MAXN];
long long belowXNT[MAXN];//树状数组，保存小于等于某坐标的牛的个数,计算时使用
long long belowXN[MAXN];//一般数组，保存小于等于某坐标和索引的牛的个数
long long velowXRT[MAXN];//树状数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和,计算时使用
long long velowXR[MAXN];//一般数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和
long long velowXRA[MAXN];//一般数组，保存小于等于某牛的坐标之和

int lowbit(int t)
{
    return t&amp;(t^(t-1));
}
void setVal(int pos, int num, long long treeG[], int maxn)
{
    while (pos &lt;= maxn)
    {
        treeG[pos] += num;
        pos += lowbit(pos);
    }
}
long long getSum(int pos, long long treeG[])
{
    long long sum = 0;
    while (pos &gt; 0)
    {
        sum += treeG[pos];
        pos -= lowbit(pos);
    }
    return sum;
}



int main()
{
    int i,n;
    long long output = 0;
    memset(belowXN, 0, sizeof(belowXN));
    memset(belowXNT, 0, sizeof(belowXN));
    memset(velowXR, 0, sizeof(velowXR));
    memset(velowXRA, 0, sizeof(velowXRA));
    memset(velowXRT, 0, sizeof(velowXRT));
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 0 ; i &lt; n ; i ++)
        scanf(&quot;%d %d&quot;, &amp;cw[i].v, &amp;cw[i].pos);

    sort(cw, cw + n, cmp);
    for(i = 0 ; i &lt; n ; i ++)
    {
        velowXRA[i] = velowXRA[i - 1] + cw[i].pos;
        setVal(cw[i].pos, 1, belowXNT, MAXN);
        setVal(cw[i].pos, cw[i].pos, velowXRT, MAXN);
        velowXR[i] = getSum(cw[i].pos, velowXRT);
        belowXN[i] = getSum(cw[i].pos, belowXNT);
    }

    for(i = 1 ; i &lt; n ; i ++)
        //output += cw[i].v * ((belowXN[i] - 1) * cw[i].pos - velowXR[i] + cw[i].pos + velowXRA[i] - velowXR[i] - (i - belowXN[i] + 1) * cw[i].pos);
        output += cw[i].v * ((belowXN[i] - i + belowXN[i] - 1 ) * cw[i].pos - 2 * velowXR[i] + velowXRA[i]);//这里是上面式子的简化版

    printf(&quot;%lld\n&quot;,output);
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/63.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-12-23T14:12:52.000+00:00 itemprop=datePublished>2009-12-23</time></div></div></article><article class="article-panel archive-article archive-type-64"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/64.html target=_blank itemprop=url>POJ PKU 2378 Tree Cutting 解题报告</a></h1></header><div class=article-summary><p>又来发解题报告了</p><p>这回是树状DP</p><pre><code class=language-cpp>/*
 * 树状DP
 * 首先把数据想象成树状的
 * 由于输入数据为树状，不需要构建树
 * 可令degree[i]为包括i且以i为根节点的所有子节点数量
 * dp[i]为删除i后的最大子节点数量或父亲节点数量 （这里我理解了很久）
 */
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt;chirld[10002];
int dp[10002] = {0}
    ,degree[10002] = {0}
    ,isJudged[10002] = {0};

int search(int pos,int &amp;n);
int main()
{
    int n,i,a,b;
    bool isnone = true;
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 1 ; i &lt; n ; i ++)
    {
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        chirld[a].push_back(b);
        chirld[b].push_back(a);
    }

    search(1 , n);

    for(i = 1 ; i &lt;= n ; i ++)
        if(dp[i] * 2 &lt;= n)
            printf(&quot;%d\n&quot;,i) , isnone = false;

    if(isnone)
        printf(&quot;NONE\n&quot;);
    return 0;
}

int search(int pos,int &amp;n)
{
    int i,j;
    degree[pos] = 1;
    isJudged[pos] = 1;
    dp[pos] = 0;

    for(i = 0 ; i &lt; chirld[pos].size() ; i ++)
    {
        if(!isJudged[chirld[pos].at(i)])//如果已经判断过就是父亲节点了
        {
            degree[pos] += search(chirld[pos].at(i) , n);
            if(dp[pos] &lt; degree[chirld[pos].at(i)])
                dp[pos] = degree[chirld[pos].at(i)];
        }
    }

    if(dp[pos] &lt; n - degree[pos])//判断父亲节点数量
        dp[pos] = n - degree[pos];
    return degree[pos];
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/64.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-12-23T14:09:13.000+00:00 itemprop=datePublished>2009-12-23</time></div></div></article><article class="article-panel archive-article archive-type-65"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/65.html target=_blank itemprop=url>POJ PKU 2528 Mayor's posters 解题报告</a></h1></header><div class=article-summary><p>题目链接: <a href="http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528">http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528</a></p><p>这题又是线段树+离散化</p><p>慢慢的对离散化有点感觉了,但是这题我还是错了3次</p><p>题目大意是一层一层地叠板子,问最后能看到几块</p><p>输入是板子的开始和结束位置</p></div><div class=article-more><a href=//owent.net/2009/65.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-18T17:49:55.000+00:00 itemprop=datePublished>2009-11-18</time></div></div></article><article class="article-panel archive-article archive-type-66"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/66.html target=_blank itemprop=url>我的ACM生涯</a></h1></header><div class=article-summary><p>在ACM的竞技场上走过了一年。这一年是充满艰难的一年，这一年是充满困惑的一年。这也是充满激情的一年。这之间有欢笑，有惊喜,也有黯然失色的悲伤.苦战一年，却没有拿到任何的成绩， regional的失败让我刻骨铭心也深深感受到了实力的差距。伤感之余也让我想起了我们ECUST的ACM之歌,我又看了一遍，每次看这篇文章都会有种说不出的感动与激情。让我有了继续走下去的力量。明年，再战ACM，等着我们，我们要成为明年名副其实的ACMer。</p></div><div class=article-more><a href=//owent.net/2009/66.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-17T17:57:31.000+00:00 itemprop=datePublished>2009-11-17</time></div></div></article><article class="article-panel archive-article archive-type-67"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/67.html target=_blank itemprop=url>POJ PKU 3277 City Horizon 解题报告</a></h1></header><div class=article-summary><p>题目链接:<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3277">http://acm.pku.edu.cn/JudgeOnline/problem?id=3277</a></p><p>线段树+离散化</p><p>ACM预选赛过去了,可是我们队什么都没拿到,这给我们的打击是相当大的,这也很大程度上体现了我们的不足</p><p>一直没能静下心,来,今天决定不能再这么悲伤下去,我要奋斗,继续学习,就从之前的断点线段树开始</p></div><div class=article-more><a href=//owent.net/2009/67.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-12T17:23:39.000+00:00 itemprop=datePublished>2009-11-12</time></div></div></article><article class="article-panel archive-article archive-type-69"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/69.html target=_blank itemprop=url>POJ PKU 2549 Sumsets 解题报告</a></h1></header><div class=article-summary><p><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2549">题目链接http://acm.pku.edu.cn/JudgeOnline/problem?id=2549</a></p><p>这道题伤了我很久脑筋</p><p>因为是a+b+c=d,数据量是1000,很自然地想到a+b=d-c</p><p>这样转化为n^2的算法.</p><p>但是我开始枚举d-c的集合二分查找a+b的几何不知道为什么WA掉了</p></div><div class=article-more><a href=//owent.net/2009/69.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-10-04T15:54:36.000+00:00 itemprop=datePublished>2009-10-04</time></div></div></article><article class="article-panel archive-article archive-type-74"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/74.html target=_blank itemprop=url>最长单调子序列 复杂度nlog(n)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//最长单调子序列 复杂度nlog(n)
//参数(原序列,序列长度,生成的序列),传入序列长度必须大于0
//返回值中lengthRecord中前k项表示长度为k的最小字序列
//LIScmp为关系函数,原函数表明lengthRecord为递增(不含等于)
typedef double LISTYPE;
#define LISMAXN 10000
int LIScmp(LISTYPE a,LISTYPE b)
{
    return a &lt; b;
}
long LISLength(LISTYPE list[],long n,LISTYPE lengthRecord[])
{
    long length = 1,lth;
    LISTYPE lR[LISMAXN];
    lR[0] = list[0];

    for(int i = 1 ; i &lt; n ; i ++)
    {
        //二分查找,复杂度 log(n)
        int b,e,m;
        b = 0;
        e = length - 1;
        while(b &lt;= e &amp;&amp; e &gt;= 0)
        {
            m = (b + e) / 2;
            if(LIScmp(lR[m],list[i]))
                b = m + 1;
            else
                e = m - 1;
        }
        lR[b] = list[i];
        if(b &gt;= length)
            length ++;
    }
    /*
    *计算序列部分
    *复杂度nlog(n)
    */
    lth = 1;
    for(int i = 1 ; i &lt; n ; i ++)
    {
        //二分查找,复杂度 log(n)
        int b,e,m;
        b = 0;
        e = lth - 1;
        while(b &lt;= e &amp;&amp; e &gt;= 0)
        {
            m = (b + e) / 2;
            if(LIScmp(lR[m],list[i]))
                b = m + 1;
            else
                e = m - 1;
        }
        lR[b] = list[i];
        if(b &gt;= lth)
            lth ++;
        if(lth == length)
        {
            for(b = 0 ; b &lt; length ; b ++)
                lengthRecord[b] = lR[b];
            break;
        }
    }
    //计算序列部分代码与之前的类似,可以直接Copy然后修改
    return length;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/74.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-16T04:44:59.000+00:00 itemprop=datePublished>2009-09-16</time></div></div></article></div><hr><nav id=page-nav><ul class=pagination><li class=page-item><a class=page-link href=../../../categories/article/page/10.html>&#171;上一页</a></li><li class=page-item><a class=page-link href=../../../categories/article.html>1</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/2.html>2</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/3.html>3</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/4.html>4</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/5.html>5</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/6.html>6</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/7.html>7</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/8.html>8</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/9.html>9</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/10.html>10</a></li><li class='page-item disabled'><a class=page-link href=../../../categories/article/page/11.html>11</a><span class=sr-only>(current)</span></li><li class=page-item><a class=page-link href=../../../categories/article/page/12.html>12</a></li><li class=page-item><a class=page-link href=../../../categories/article/page/12.html>下一页&#187;</a></li></ul></nav></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>
2024
OWenT
</strong><strong id=footer-right class="float-right float-end"><a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=text/javascript src=//unpkg.com/@popperjs/core@latest/dist/umd/popper.min.js crossorigin=anonymous></script><script type=text/javascript src=//unpkg.com/bootstrap@latest/dist/js/bootstrap.min.js crossorigin=anonymous></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>jQuery(function(){jQuery("head").append('<link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css" />'),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const e={};for(const t of hljs.listLanguages())e[t.toLowerCase()]=!0;jQuery("pre>code").each(function(e,t){try{if(t.className.match(/\bnohighlight\b|\bmermaid\b/i))return;const e=t.className.match(/language-([^\s]+)/i);if(e&&e.length>=2&&hljs.getLanguage(e[1]))hljs.highlightElement(t);else{const e=jQuery(t),n=hljs.highlightAuto(e.text(),hljs.listLanguages());n&&n.value&&(e.html(n.value),e.addClass("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>jQuery(function(){jQuery("head").append('<link rel="stylesheet" href="//unpkg.com/katex@latest/dist/katex.min.css" />'),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
    import mermaid from "\/\/unpkg.com\/mermaid@latest\/dist\/mermaid.esm.min.mjs";
    const config = {
        theme: 'neutral',
        logLevel: 'fatal',
        securityLevel: 'loose', 
        startOnLoad: true,
        arrowMarkerAbsolute: false,
        

    };
    mermaid.initialize(config);
</script></div></body></html>