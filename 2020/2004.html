<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>libcopp接入C++20 Coroutine和一些过渡期的设计|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/2020/2004.html><link rel=icon href=../favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><script type=text/javascript src=//unpkg.com/jquery@latest/dist/jquery.slim.min.js crossorigin=anonymous></script><link rel=stylesheet href=//owent.net/css/syntax.css><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-toggle=collapse data-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=../ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=../archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=../about.html title=About>About</a></li></ul><div class="col-2 position-absolute end-0"><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-2 my-sm-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=post-content><article id=post-64020648bd583e76b73ec35e035ea92d class="article-panel article article-type-post" itemscope itemprop=blogPost><div class="article-panel-inner article-inner"><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=//owent.net/2020/2004.html target=_blank itemprop=url>libcopp接入C++20 Coroutine和一些过渡期的设计</a></h1></header><hr><div id=toc class="well toc m-3 p-1 pr-1 pt-1 pb-2 float-md-right float-md-end"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#c20-协程>C++20 协程</a></li><li><a href=#rust的零开销抽象协程>Rust的零开销抽象协程</a></li><li><a href=#libcopp对-c20-协程的设计抽象>libcopp对 C++20 协程的设计抽象</a><ul><li><a href=#为平滑迁移而设计的-future_t--poll_t-和-context_t>为平滑迁移而设计的 future_t 、 poll_t 和 context_t</a></li><li><a href=#coppfutureresult_t成功类型错误类型><code>copp::future::result_t&lt;成功类型,错误类型></code></a></li><li><a href=#协程任务-task_t>协程任务 task_t</a></li><li><a href=#生成器-generator_t>生成器 generator_t</a></li><li><a href=#我们来个完整的example>我们来个完整的example</a></li><li><a href=#压力测试>压力测试</a></li><li><a href=#原task对象的接入>原task对象的接入</a></li></ul></li><li><a href=#关于msvc的-stdexperimentalgenerator-和-cppcoro6-的-cppcorogenerator>关于MSVC的 <code>std::experimental::generator</code> 和 <a href=https://github.com/lewissbaker/cppcoro>cppcoro</a> 的 <code>cppcoro::generator</code></a></li><li><a href=#gcc-1010-的坑>GCC 10.1.0 的坑</a><ul><li><a href=#符号问题>符号问题</a></li><li><a href=#生命周期和析构>生命周期和析构</a></li></ul></li><li><a href=#apple-clang-9-和-clang-6-开编译优化后访问协程栈变量崩溃问题>Apple clang 9 和 Clang 6 开编译优化后访问协程栈变量崩溃问题</a></li><li><a href=#写在最后>写在最后</a></li></ul></nav></div><br><div class=article-entry itemprop=articleBody><h2 id=前言>前言</h2><p>最近GCC 10.1.0 发布，三大编译器（MSVC、GCC、Clang）都已经支持了<a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a>，之前给 <a href=https://github.com/owent/libcopp/>libcopp</a> 接入 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 的计划也就提上了日程。<a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 在创建、切换开销和内存分配上和传统有栈协程相比有着无可比拟的优势。但是C++20全面普及还有相当长一段时间，所以我们设计的重要目标之一就是能够让以后的迁移更容易且更平滑地进行，本文则是记录了 <a href=https://github.com/owent/libcopp/>libcopp</a> 接入 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 时地一些性能上和平滑接入上的思考和成果。</p><p>设计 <a href=https://github.com/owent/libcopp/>libcopp</a> 接入<a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a>的结构的时候主要参考了 <a href=https://www.rust-lang.org/>Rust语言</a> 里号称零开销抽象的设计（其中一个重要原因是 <a href=https://www.rust-lang.org/>Rust</a> 的很多设计哲学和设计思路和C++一样）和 CppCon 2019 上一位演讲者分享的 <a href=https://github.com/lewissbaker/cppcoro>cppcoro</a> ，特此感谢。</p><h2 id=c20-协程>C++20 协程</h2><p>C++20的协程基本介绍可以见我之前写得一个小体验 <a href=https://owent.net/2019/1904.html>《C++20 Coroutine》</a> 和 <a href=https://en.cppreference.com/>https://en.cppreference.com/</a> 上的文档 <a href=https://en.cppreference.com/w/cpp/language/coroutines>《Coroutines (C++20)》</a> 。 简单地说， C++20协程主要分为 <strong>函数返回值类型</strong> 、 <strong>存放协程上下文数据的promise_type</strong> 和 <strong>用于判定是否需要切出的awaitable</strong> 。</p><p>之前看CppCon 2019的分享视频的时候看到了 <a href=https://github.com/lewissbaker/cppcoro>cppcoro</a> 这个库，其实就是一个典型的C++风格的协程封装，增加了一些对各项STL操作和IO更友好的基础设施，没啥太多可说的，有兴趣的小伙伴可以直接去看它的源码。</p><h2 id=rust的零开销抽象协程>Rust的零开销抽象协程</h2><p>为什么要参考 <a href=https://www.rust-lang.org/>Rust</a> 的设计呢？<a href=https://www.rust-lang.org/>Rust</a> 的很多设计哲学和设计思路和C++一样，并且它的很多设计就是为了解决C++的坑。而且 <a href=https://www.rust-lang.org/>Rust</a> 的标准库支持 <code>await</code> 比较晚，它的标准库协程方面的设计也综合考虑了老的一些库层面的协程实现和新的内置机制的迁移和融合，也考虑了低开销和经过了很多人在很多应用场景上的讨论。和我计划给 <a href=https://github.com/owent/libcopp/>libcopp</a> 当前接入C++20协程的目标是一样的，所以一开始我是想尽可能设计成类似 <a href=https://www.rust-lang.org/>Rust</a> 的结构。但是后来分析了一下我发现C++20协程是做不到 <a href=https://www.rust-lang.org/>Rust</a> 那样的零开销抽象的，其中一个很重要的原因是 <a href=https://www.rust-lang.org/>Rust</a> 引入了生命周期概念，一个对象的生命周期只有一个， 那么比如 <code>a.then(b)</code> （ <code>a</code> 和 <code>b</code> 都是Future）在 <a href=https://www.rust-lang.org/>Rust</a> 里的主流实现是创建一个Future <code>c</code> ，然后把 <code>a</code> 和 <code>b</code> move进来。 因为<a href=https://www.rust-lang.org/>Rust</a> 可以在编译阶段分析出生命周期，并且一个对象的生命周期只有一个。那么创建 <code>a</code> 和 <code>b</code> 对象的时候就可以直接创建在 <code>c</code> 里，额外创建的 <code>c</code> 就不会有任何的开销。 而在C++里，虽然现在有move和右值，但是这个其实说白了只是个约定和编译器提供的一种非强制性语义。要实现把 <code>a</code> 和 <code>b</code> move进来这种操作，多多少少还是有开销的，如果 <code>a</code> 和 <code>b</code> 地址不变就得分配在堆上，就有堆管理和至少一个 <code>unique_ptr</code> 的开销，如果分配在栈上，那要执行整个 <code>a</code> 和 <code>b</code> 的move构造或者move赋值。两种方法都是只能做到降低开销但无法做到零开销。</p><p>同时，我个人觉得 <a href=https://www.rust-lang.org/>Rust</a> 的抽象在运行时性能和无缝迁移的 <strong>我全都要</strong> 的设计，导致接入和理解成本太高，而且所有的调用组合最终都是一个大 Future，里面包含了很多子Future，这导致每一种调用方式都是一个全新的模板实例化，对编译器的负担太重了。我们来看个最简单的接入的例子:</p><pre><code class=language-rust>use std::boxed::Box;
use std::collections::HashMap;
use std::future::Future;
use std::mem::size_of_val;
use std::pin::Pin;
use std::sync::mpsc::{channel, Receiver, Sender};
use std::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};
use std::vec::Vec;

// 用户调度层接入
struct MessageEvent {
    tx: Sender&lt;i32&gt;,
    waker: Waker,
}

// 因为全局变量访问默认不是线程安全，不标记unsafe无法直接访问
// Mutex不能静态构造，使用 lazy_static 模块再加Mutex可以把这里的全局变量访问转为safe的
static mut USER_DISPATCHER: Vec&lt;MessageEvent&gt; = vec![];

// 用于异步调用层接入
struct Message {
    rx: Option&lt;Receiver&lt;i32&gt;&gt;,
}

impl Future for Message {
    type Output = i32;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, ctx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt; {
        if let Some(ref rx) = self.rx {
            if let Ok(x) = rx.try_recv() {
                Poll::Ready(x)
            } else {
                Poll::Pending
            }
        } else {
            let (tx, rx) = channel();
            unsafe {
                self.get_unchecked_mut().rx = Some(rx);
                USER_DISPATCHER.push(MessageEvent {
                    tx: tx,
                    waker: ctx.waker().clone(),
                });
            }
            Poll::Pending
        }
    }
}

// 使用者示例
async fn call_1(prefix: &amp;str) -&gt; i32 {
    let msg = Message { rx: Option::None };

    let ret = msg.await;
    println!(&quot;{}call_1: await and got {}!&quot;, prefix, ret);
    ret
}

async fn call_2(prefix: &amp;str) -&gt; i32 {
    println!(&quot;{}call_2&quot;, prefix);

    let sub_prefix = format!(&quot;{}{}&quot;, prefix, prefix);
    let sub_fut1 = call_1(&amp;sub_prefix);
    let sub_fut2 = call_1(&amp;sub_prefix);
    println!(
        &quot;{}call_2 sub_fut1 {:?}:{}&quot;,
        prefix,
        &amp;sub_fut1 as *const _,
        size_of_val(&amp;sub_fut1)
    );
    println!(
        &quot;{}call_2 sub_fut2 {:?}:{}&quot;,
        prefix,
        &amp;sub_fut2 as *const _,
        size_of_val(&amp;sub_fut2)
    );
    let mut ret = sub_fut1.await;
    ret += sub_fut2.await;

    println!(&quot;{}call_2 result: {}.&quot;, prefix, ret);
    ret
}

async fn call_3(prefix: &amp;str) -&gt; i32 {
    println!(&quot;{}call_3&quot;, prefix);

    let sub_prefix = format!(&quot;{}{}&quot;, prefix, prefix);
    let sub_fut1 = call_1(&amp;sub_prefix);
    let sub_fut2 = call_2(&amp;sub_prefix);
    println!(
        &quot;{}call_3 sub_fut1 {:?}:{}&quot;,
        prefix,
        &amp;sub_fut1 as *const _,
        size_of_val(&amp;sub_fut1)
    );
    println!(
        &quot;{}call_3 sub_fut2 {:?}:{}&quot;,
        prefix,
        &amp;sub_fut2 as *const _,
        size_of_val(&amp;sub_fut2)
    );
    let mut ret = sub_fut1.await;
    ret += sub_fut2.await;

    println!(&quot;{}call_2 result: {}.&quot;, prefix, ret);
    ret
}

// 框架调度层接入
struct TaskData {
    waker: Option&lt;Waker&gt;,
    future: Pin&lt;Box&lt;dyn Future&lt;Output = i32&gt;&gt;&gt;,
    owner: *mut Executor,
}

// 因为全局变量访问默认不是线程安全，不标记unsafe无法直接访问
// Mutex不能静态构造，使用 lazy_static 模块再加Mutex可以把这里的全局变量访问转为safe的
static USER_WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(
    user_clone_fn,
    user_wake_fn,
    user_wake_by_ref_fn,
    user_drop_fn,
);

struct Executor {
    tasks: HashMap&lt;*const TaskData, Pin&lt;Box&lt;TaskData&gt;&gt;&gt;,
}

fn user_wake_fn(task_raw: *const ()) {
    println!(&quot;wake! with {:?}&quot;, &amp;task_raw);
    // 这里透传参数是裸指针，只能unsafe了，
    let task = task_raw as *mut TaskData;
    unsafe {
        if let Some(ref waker) = (*task).waker {
            let mut context = &amp;mut Context::from_waker(&amp;waker);
            if let Poll::Ready(_) = (*task).future.as_mut().poll(&amp;mut context) {
                (*(*task).owner).tasks.remove(&amp;(task as *const TaskData));
            }
        }
    }
}

fn user_wake_by_ref_fn(task_raw: *const ()) {
    println!(&quot;wake_by_ref! with {:?}&quot;, &amp;task_raw);
    // 这里透传参数是裸指针，只能unsafe了，
    let task = task_raw as *mut TaskData;
    unsafe {
        if let Some(ref waker) = (*task).waker {
            let mut context = &amp;mut Context::from_waker(&amp;waker);
            if let Poll::Ready(_) = (*task).future.as_mut().poll(&amp;mut context) {
                (*(*task).owner).tasks.remove(&amp;(task as *const TaskData));
            }
        }
    }
}

fn user_create_fn(
    owner: *mut Executor,
    future: Pin&lt;Box&lt;dyn Future&lt;Output = i32&gt;&gt;&gt;,
) -&gt; Pin&lt;Box&lt;TaskData&gt;&gt; {
    println!(
        &quot;Pined address of future {:?}&quot;,
        (&amp;future).as_ref().get_ref() as *const _
    );
    let mut task_data = Box::pin(TaskData {
        waker: Option::None,
        future: future,
        owner: owner,
    });

    let task_ptr = (&amp;mut *task_data.as_mut()) as *mut TaskData;
    let waker;
    unsafe {
        waker = Waker::from_raw(RawWaker::new(task_ptr as *const (), &amp;USER_WAKER_VTABLE));
    }

    task_data.as_mut().waker = Some(waker);
    if let Some(current_waker) = &amp;task_data.as_ref().waker {
        current_waker.wake_by_ref();
    }

    task_data
}

fn user_clone_fn(task_raw: *const ()) -&gt; RawWaker {
    println!(&quot;clone waker with {:?}&quot;, &amp;task_raw);
    RawWaker::new(task_raw, &amp;USER_WAKER_VTABLE)
}

fn user_drop_fn(task_raw: *const ()) {
    println!(&quot;drop waker with {:?}&quot;, &amp;task_raw);
}

impl Executor {
    fn run(&amp;mut self) {
        let mut allocator: i32 = 1;

        loop {
            let mut has_success = false;
            unsafe {
                // 模拟有数据
                if let Some(evt) = USER_DISPATCHER.pop() {
                    if let Ok(_) = evt.tx.send(allocator) {
                        allocator = allocator + 1;
                        has_success = true;
                        evt.waker.wake_by_ref();
                    }
                }
            }

            if !has_success {
                break;
            }
        }
    }

    fn spawn(&amp;mut self, future: Pin&lt;Box&lt;dyn Future&lt;Output = i32&gt;&gt;&gt;) {
        let task = user_create_fn(self, future);
        self.tasks.insert(&amp;*task.as_ref(), task);
    }
}

fn main() {
    println!(&quot;Hello, world!&quot;);
    let future1 = call_1(&quot;-&quot;);
    let future2 = call_2(&quot;+&quot;);
    let future3 = call_3(&quot;#&quot;);
    println!(
        &quot;Sizeof(call_1()): {:?}:{}&quot;,
        &amp;future1 as *const _,
        size_of_val(&amp;future1)
    );
    println!(
        &quot;Sizeof(call_2()): {:?}:{}&quot;,
        &amp;future2 as *const _,
        size_of_val(&amp;future2)
    );
    println!(
        &quot;Sizeof(call_3()): {:?}:{}&quot;,
        &amp;future3 as *const _,
        size_of_val(&amp;future3)
    );
    let mut exec = Executor {
        tasks: HashMap::new(),
    };

    // Move 到堆上并且 pin（不允许再move）
    exec.spawn(Box::pin(future1));
    exec.spawn(Box::pin(future2));
    exec.spawn(Box::pin(future3));
    exec.run();
}
</code></pre><p>大致的结构如下:</p><p><img src=2004-rust-future-context-waker.png alt></p><p>上面的代码打印了比较多的日志，也是为了方便查看Future之间的结构关系。有兴趣的童鞋可以去 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2e28a6da5d6646fd93a023b5ea97d774">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2e28a6da5d6646fd93a023b5ea97d774</a> 这里自己看运行结果。</p><h2 id=libcopp对-c20-协程的设计抽象>libcopp对 C++20 协程的设计抽象</h2><h3 id=为平滑迁移而设计的-future_t--poll_t-和-context_t>为平滑迁移而设计的 future_t 、 poll_t 和 context_t</h3><p>C++并没有在语言层面保证生命周期唯一性，如果为了防止误用和生命周期混乱，要么引入引用计数来保证生命周期得可靠性，要么禁止复制。我们这里为了减少不必要的开销选择了禁止复制。</p><p>提供的基本组件如下:</p><ul><li><code>future_t&lt;T></code> : 用户数据层抽象，指示未来完成以后返回类型 <code>T</code></li><li><code>poll_t&lt;T></code> : <code>future_t&lt;T></code> 中的存储结构， 提供了低开销的 <strong>转移</strong> 语义、is_ready语义、存储结构和一系列辅助函数。 有点像 <a href=https://www.rust-lang.org/>Rust</a> 里的 <code>std::option::Option&lt;T></code> : 同时提供了C++的低开销的存储结构、转移、赋值和小对象优化等等，下面会提到。</li><li><code>context_t&lt;TPD></code> : 用户调度层抽象，用于创建用户自定义类型(<code>TPD</code>)的执行状态机和通过提供构造、析构等函数提供功能性接口。</li><li><code>TPD::operator(...)</code> : 用户异步调用事件通知抽象，用来通知 <code>future_t&lt;T></code> 的状态变化和如何变化。目前的设计中， <code>future_t&lt;T>::poll(context_t&lt;TPD>)</code> 也会自动设置 <code>context_t&lt;TPD></code> 的wake行为，并且最终回调到 <code>TPD::operator(...)</code></li></ul><p>按目前的设计，引入 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 以后几乎不需要修改接入代码，接入样例如下:</p><pre><code class=language-cpp>#include &lt;assert.h&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;

#include &lt;libcopp/future/future.h&gt;
#include &lt;libcopp/future/context.h&gt;

// 自定义成功的数据类型
struct example_result_message_t {
    int return_code;
    int response_code;
};
struct example_poller;

// libcopp中提供一个比较通用的组件 copp::future::result_t , 用于辅助管理future的成功/失败的存储和内部的数据结构
typedef copp::future::result_t&lt;
    example_result_message_t, // future执行成功的数据类型
    int                       // future执行失败的数据类型，假设是错误码
&gt; example_result_t;
typedef copp::future::future_t&lt;example_result_t&gt; example_future_t;
typedef copp::future::context_t&lt;example_poller&gt; example_context_t;

std::list&lt;example_context_t*&gt; g_executor;

struct example_poller {
    example_result_t::storage_type* result;
    std::list&lt;example_context_t*&gt;::iterator iter;
    example_poller(): result(NULL) {
        iter = g_executor.end();
    }
    ~example_poller() {
        // 如果未产生消息就结束了，清理数据
        // 相当于Rust的Waker里的drop接口
        if (iter != g_executor.end()) {
            g_executor.erase(iter);
        }
    }
    void operator()(example_future_t&amp; future, example_context_t &amp;ctx) {
        // 类似于Rust的Future里的poll接口
        // 第一次调用poll的时候，我们会自动设置ctx的wake接口来再次触发到这里
        if (NULL != result) {
            // 给 poll_data 赋值即为标记future为ready状态。
            future.poll_data() = *result;
            result = NULL;
            // 已经调度完了，就可以移除
            if (iter != g_executor.end()) {
                g_executor.erase(iter);
                iter = g_executor.end();
            }
        } else {
            // 第一次执行poll，加入到等待事件的列表
            if (iter == g_executor.end()) {
                iter = g_executor.insert(g_executor.end(), &amp;ctx);
            }
        }
    }
};

int main() {
    copp::future::future_t&lt;example_result_t&gt; future;
    example_context_t context;

    assert(future.is_ready() == false);

    // 第一次调用poll函数会自动绑定context的wake行为为继续回调这个future.poll(context)
    // 所以用户要保证一个future对象只能poll同一个context对象
    future.poll(context);

    while (!g_executor.empty()) {
        example_result_message_t msg;
        // 虚拟的自定义消息，假定这里RPC返回了
        msg.return_code = 0;
        msg.response_code = 200;
        // 如果成功的数据类型和失败的数据类型都是trivial的而且都很小，那么storage_type会是result_t本身
        // 否则storage_type会是std::unique_ptr&lt;result_t&gt;
        // 无论哪种情况， result_t::make_success(msg) 和 result_t::make_error(msg) 都会返回一个正确的可以直接转移给
        //     future 内 poll_data() 的类型（也就是 storage_type）。
        example_result_t::storage_type result_storage = example_result_t::make_success(msg);
        (*g_executor.begin())-&gt;get_private_data().result = &amp;result_storage;
        // 调用wake函数会再次触发上面的operator()，使用者不用关心这里的调用流程
        (*g_executor.begin())-&gt;wake();
    }

    // Then future is ready
    assert(future.is_ready() == true);
    example_result_t* result = future.data();
    assert(result != NULL);
    
    assert(result-&gt;is_success());
    assert(200 == result-&gt;get_success()-&gt;response_code);
    assert(false == result-&gt;is_error());
    assert(NULL == result-&gt;get_error());

    std::cout&lt;&lt; &quot;Got future success response code: &quot;&lt;&lt; result-&gt;get_success()-&gt;response_code&lt;&lt; std::endl;
    return 0;
}
</code></pre><p>看起来代码也不少，实际上就下面这个结构:</p><p><img src=2004-future-context.png alt></p><p>我们提供了更多的辅助工具以适应各种使用场景的，更多详情见<a href=https://github.com/owent/libcopp/tree/dev>libcopp dev分支</a>的单元测试 <a href=https://github.com/owent/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp>https://github.com/owent/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp</a> 和 <a href=https://github.com/owent/libcopp/tree/dev>README</a> 。</p><h4 id=小对象优化>小对象优化</h4><p>future的实现需要一个重要的设施，那就是在未完成前是空状态，完成后需要把执行的结果 <strong>转移</strong> 到future中。那么为了一方面高效地实现 <strong>转移</strong> 语义，另一方面对小数据对象又不想分配在堆上浪费开销。所以我们在实际决定future内的poll_type的存储结构时会根据对象的大小(未来也可能修订这个大小的限定，但是如果使用下面提到的 <code>result_t</code> 的话用户层接口可以不变)以及是否是trivial来决定是否走小对象优化。这个优化有点像 <a href=https://shaharmike.com/cpp/std-string/><code>std::string</code> 的 SSO 机制</a> 。对于大的数据结构或者非trivial的数据结构，poll_type中我们采用 <code>std::unique_ptr&lt;T, std::default_delete&lt;T> ></code> 来保存。对于 <code>result_t</code> 中的数据，我们采用 <code>std::shared_ptr&lt;T></code> 来保存。</p><h3 id=coppfutureresult_t成功类型错误类型><code>copp::future::result_t&lt;成功类型,错误类型></code></h3><p>在实际项目中，我们对一段future代码执行结果最通用的设计就是成功了怎么怎么样，然后失败了怎么怎么样。另外由于上面提到的小对象优化，给我们future的结果的数据类型和用户的使用上带来了一定的复杂度。为了解决这个问题，我在 <a href=https://github.com/owent/libcopp/>libcopp</a> 中引入了 <code>copp::future::result_t&lt;成功类型,错误类型></code> 的辅助类。这里面会根据自定义类型的具体情形来决定使用哪种存储结构，也提供了函数来取成功或失败的数据结构和状态。功能类似 <a href=https://www.rust-lang.org/>Rust</a> 的 <code>std::result::Result</code> 。</p><p>然后 <code>result_t</code> 额外提供了 <code>result_t::make_success(...)</code> 和 <code>result_t::make_error(...)</code> 来创建可以直接移动赋值给 <code>future_t::poll_type</code> 的简化接口。</p><h3 id=协程任务-task_t>协程任务 task_t</h3><p>后面就是按<a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a>的方式接入，可以做到接入层不需要改变。整体结构设计如下：</p><p><img src=2004-std-coroutine-task.png alt></p><p>上面有一些数据结构是为了嵌套 <code>co_await</code> 而存在，自动记录了引用关系。然后在使用过程中，我们定义协程函数就很简单了：</p><pre><code class=language-cpp>copp::future::task_t&lt;int&gt; call_for_coroutine_fn_runtime_trivial() {
    // ... any code
    co_return 123;
}

copp::future::task_t&lt;void&gt; call_for_coroutine_fn_runtime_void() {
    // ... any code
    co_return;
}
</code></pre><p>更多的细节可以参照 <a href=https://github.com/owent/libcopp/tree/dev>libcopp dev分支</a> 的单元测试 <a href=https://github.com/owent/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp>https://github.com/owent/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp</a> 和 <a href=https://github.com/owent/libcopp/tree/dev>README</a></p><h3 id=生成器-generator_t>生成器 generator_t</h3><p>其实 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 创建开销还是比较高的。很多情况下我们只是需要提供调度层机制在RPC或者慢操作完成以后通知协程恢复，这时候就不必要去创建一个协程。于是 <a href=https://github.com/owent/libcopp/>libcopp</a> 里还提供了一个 <code>copp::future::generator_t&lt;T, TPD></code> 对象。用于提供统一的方式接入 <code>co_await</code> 。大致结构如下:</p><p><img src=2004-std-coroutine-generator.png alt></p><h3 id=我们来个完整的example>我们来个完整的example</h3><pre><code class=language-cpp>#include &lt;assert.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

// include manager header file
#include &lt;libcopp/future/std_coroutine_task.h&gt;
#include &lt;libcopp/future/std_coroutine_generator.h&gt;

// 定义一个自定义的消息类型，作为异步调用的结果，这里是非trivial类型
struct sample_message_t {
    int ret_code;
    std::string response;
};

struct sample_generator_waker_t;

typedef copp::future::result_t&lt;sample_message_t, int32_t&gt; sample_result_t;
typedef copp::future::task_t&lt;sample_result_t&gt;             sample_task_t;
typedef copp::future::generator_future_t&lt;sample_result_t&gt; sample_future_t;
typedef copp::future::generator_context_t&lt;sample_generator_waker_t&gt; sample_generator_context_t;


std::list&lt;std::pair&lt;sample_generator_context_t *, std::string&gt; &gt; g_sample_executor;

struct sample_generator_waker_t {
    int32_t code;
    std::list&lt;std::pair&lt;sample_generator_context_t *, std::string&gt; &gt;::iterator refer_to;

    // 所有传给 generator_t 的参数都会被透传过来
    // 如果允许接受和忽略任意参数且仅在协程函数里使用，可以申明一个 template&lt;class... ARGS&gt; 构造函数然后仅仅忽略参数
    sample_generator_waker_t(int32_t c) : code(c) {
        refer_to = g_sample_executor.end();
    }

    ~sample_generator_waker_t() {
        // 析构释放资源，如果 generator_t 未完成，但是协程任务被外部 kill 可能会触发强制resume，这时候没有数据，也不会走operator()里的释放流程
        if (refer_to != g_sample_executor.end()) {
            g_sample_executor.erase(refer_to);
        }
    }

    void operator()(sample_future_t &amp;fut, sample_generator_context_t &amp;ctx) {
        if (refer_to == g_sample_executor.end()) {
            // 第一次poll，加入到自定义的调度器
            refer_to = g_sample_executor.insert(
                g_sample_executor.end(),
                std::make_pair(&amp;ctx, std::string())
            );
            return;
        }

        if (!(*refer_to).second.empty()) {
            // 已经获取到数据了，给 fut.poll_data() 赋值然后从调度器移除
            sample_message_t msg;
            msg.ret_code    = code;
            msg.response.swap((*refer_to).second);

            fut.poll_data() = sample_result_t::make_success(std::move(msg));
            // 由于是非trivial类型，这里等同于:
            // auto ptr = std::make_unique&lt;sample_result_t&gt;(sample_result_t::create_success(std::move(msg)));
            // fut.poll_data() = std::move(ptr);

            g_sample_executor.erase(refer_to);
            refer_to = g_sample_executor.end();
        }
    }
};
typedef copp::future::generator_t&lt;sample_result_t, sample_generator_waker_t&gt; sample_generator_t;

static copp::future::task_t&lt;void&gt; call_for_noop_task() {
    co_return;
}

static copp::future::task_t&lt;int&gt; call_for_coroutine_task() {
    // 可以启动一个新的协程任务然后await等它完成
    copp::future::task_t&lt;void&gt; t = call_for_noop_task();
    co_await t;

    // 也可以启动一个低消耗的异步generator并等它完成
    sample_generator_t generator = copp::future::make_generator&lt;sample_generator_t&gt;(200);
    auto result = co_await generator;

    if (result) {
        if (result-&gt;is_success()) {
            std::cout&lt;&lt; &quot;Got response message: &quot;&lt;&lt; result-&gt;get_success()-&gt;response&lt;&lt; std::endl;
            co_return result-&gt;get_success()-&gt;ret_code;
        } else {
            co_return *result-&gt;get_error();
        }
    }
    co_return 0;
}

int main() {
    copp::future::task_t&lt;int&gt; t = call_for_coroutine_task();
    assert(false == t.done());
    assert(NULL == t.data());  // 任务未结束没有data数据

    while (!g_sample_executor.empty()) {
        // 模拟异步任务完成，并且产生了消息
        g_sample_executor.begin()-&gt;second = &quot;Hello World!&quot;;
        g_sample_executor.begin()-&gt;first-&gt;wake();
    }

    assert(t.done());
    assert(t.data()); // 任务结束后就有data了
    std::cout&lt;&lt; &quot;Task &quot;&lt;&lt; t.get_task_id()&lt;&lt; &quot; finished and got result: &quot;&lt;&lt; *t.data()&lt;&lt; std::endl;
    return 0;
}
</code></pre><p>这里看起来好像和 <a href=https://www.rust-lang.org/>Rust</a> 的流程差不多。实际上还是有很大区别，<a href=https://www.rust-lang.org/>Rust</a> 的协程是一个包含关系，而 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 是链式的关系。一个最显著的特点就是在 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 里一个协程 <code>co_await</code> 另一个协程的时候，被 <code>co_await</code> 的协程收到事件处理上下文并且负责完成以后resume到上一级协程。 而 <a href=https://www.rust-lang.org/>Rust</a> 的协程本质上是 Future 的嵌套，所有的poll操作都是从最外层的调用方开始的。这里影响到我们对协程的封装上最直观的结果简单来说就是 <a href=https://www.rust-lang.org/>Rust</a> 的协程的 <code>Context</code> 和 <code>Waker</code> 由框架层封装，并且由于封装度高且复杂，多个框架之间的设计模型有差异的话可能很难混用；而 <a href=https://github.com/owent/libcopp/>libcopp</a> 对 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 的封装的 <code>context_t&lt;T></code> 由异步调用接口创建，并且对系统框架的调度层几乎没有要求，也支持其他的协程模型和 <a href=https://github.com/owent/libcopp/>libcopp</a> 混用。<a href=https://github.com/owent/libcopp/>libcopp</a> 和 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 的选择是用比较低的开销换取了灵活性，接入一个异步调用虽然会创建更多的对象，但是都是底层自动完成的且放在一起以减少碎片，同时对生命周期的管理做了一定的防误用。这当然也和 <a href=https://github.com/owent/libcopp/>libcopp</a> 的尽量防止被误用和误用情况下尽可能保证安全的设计原则有关。</p><p>下面是一个对比，假设异步调用的结果是 <code>RpcResult</code> ，自定义用户调度层接入类型为 <code>RpcCall</code> :</p><table><thead><tr><th style=text-align:center>对比项</th><th style=text-align:center><a href=https://www.rust-lang.org/>Rust</a> 协程</th><th style=text-align:center><a href=https://github.com/owent/libcopp/>libcopp</a> + <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a></th></tr></thead><tbody><tr><td style=text-align:center>异步调用系统底层创建的对象</td><td style=text-align:center>符合 <code>traits Future&lt;Output=RpcResult></code> 的 <code>RpcCall</code></td><td style=text-align:center><code>future_t&lt;RpcResult></code> 、<code>context_t&lt;RpcCall></code> 和用户自定数据 <code>RpcCall</code></td></tr><tr><td style=text-align:center>异步调用用户层接口</td><td style=text-align:center>调用方创建 <code>RpcCall</code></td><td style=text-align:center>调用方创建 <code>generator_t&lt;RpcResult,RpcCall></code></td></tr><tr><td style=text-align:center>异步调用调度层接入</td><td style=text-align:center>实现 <code>RpcCall</code> 的 <code>poll() -> Poll&lt;RpcResult></code> 接口</td><td style=text-align:center>实现 <code>RpcCall::operator(future, context)</code></td></tr><tr><td style=text-align:center>Waker和Future绑定关系</td><td style=text-align:center>由框架调度层实现</td><td style=text-align:center>自动绑定，用户调度层可修改替换</td></tr><tr><td style=text-align:center>协程组织结构</td><td style=text-align:center><strong>has-a 关系</strong> ，重入有低开销，组织管理无开销</td><td style=text-align:center>链式关系，重入几乎零开销，组织管理低开销</td></tr><tr><td style=text-align:center>Context/Waker生命周期</td><td style=text-align:center>跟随异步任务，多个异步调用可以复用同一个Waker</td><td style=text-align:center>跟随异步调用</td></tr><tr><td style=text-align:center>异步任务系统底层创建的对象</td><td style=text-align:center>现有的实现里大部分由额外的Task对象和管理层对象</td><td style=text-align:center>比异步调用多 <code>task_t&lt;RpcResult, RpcCall></code> 、<code>runtime_t&lt;RpcResult, RpcCall></code> 和<code>task_t&lt;RpcResult, RpcCall>::promise_type</code></td></tr><tr><td style=text-align:center>异步任务用户层接口</td><td style=text-align:center>比异步调用多一个对Future的生命周期管理（一般会包到<code>Pin&lt;Box&lt;Future&lt;Output=RpcResult>>></code> 里丢到堆上）</td><td style=text-align:center>调用方函数返回 <code>task_t&lt;RpcResult,RpcCall></code></td></tr><tr><td style=text-align:center>异步任务调度层接入</td><td style=text-align:center>非常复杂，设计多个对象的生命周期管理和调度入口管理</td><td style=text-align:center>很简单，也可以使用 <code>task_t&lt;RpcResult, void></code> 来实现零接入</td></tr><tr><td style=text-align:center>异步任务超时和错误管理</td><td style=text-align:center>只能依赖await前嵌套timeout future实现，必须转换成相同的输出类型</td><td style=text-align:center>允许外部总控超时和错误，对父子模块间无类型要求</td></tr><tr><td style=text-align:center>多个框架融合</td><td style=text-align:center>非常复杂，要合并多个框架的调度入口、事件管理和生命周期管理</td><td style=text-align:center>只要符合 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 规范，无需额外接入</td></tr></tbody></table><p>同样更多的使用细节可以参照 <a href=https://github.com/owent/libcopp/tree/dev>libcopp dev分支</a> 的单元测试 <a href=https://github.com/owent/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp>https://github.com/owent/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp</a> 和 <a href=https://github.com/owent/libcopp/tree/dev>README</a></p><h3 id=压力测试>压力测试</h3><p>压力测试机器环境:</p><table><thead><tr><th>环境名称</th><th>值</th></tr></thead><tbody><tr><td>系统</td><td>Linux kernel 3.10.107(Docker)</td></tr><tr><td>CPU</td><td>Intel(R) Xeon(R) Gold 61xx CPU @ 2.50GHz * 48</td></tr><tr><td>L1 Cache</td><td>64Bytes*64sets*8ways=32KB</td></tr><tr><td>系统负载</td><td>1.67 0.56 0.30</td></tr><tr><td>内存占用</td><td>23GB(used)/125GB(sum)</td></tr><tr><td>CMake</td><td>3.17.0</td></tr><tr><td>GCC版本</td><td>10.1.0</td></tr><tr><td>Clang版本</td><td>10.0.0</td></tr><tr><td>libcopp</td><td>dev分支(20200520)</td></tr><tr><td>librf</td><td>master分支(20200519)</td></tr></tbody></table><p>我对profile初步分析了一下开销占比发现创建task时的new runtime、no trivial对象走的new和其他一些 <code>new/delete/malloc/free</code> 的开销占比比较大。而我们主要还是要测试协程的开销，并且我们的项目中也会使用 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 来替换掉默认的内存分配器。所以跑压力测试的时候跑了两个版本，左边是编译器自带的 <code>malloc/free</code> 实现的开销，右边是是有 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 时的开销。</p><table><thead><tr><th>组件(Avg)</th><th>协程数：1 切换开销</th><th>协程数：1000 创建开销</th><th>协程数：1000 切换开销</th><th>协程数：30000 创建开销</th><th>协程数：30000 切换开销</th></tr></thead><tbody><tr><td>C++20 Coroutine - Clang</td><td>5 ns</td><td>130 ns</td><td>6 ns</td><td>136 ns</td><td>9 ns</td></tr><tr><td>C++20 Coroutine - GCC</td><td>7 ns</td><td>146 ns</td><td>7 ns</td><td>120 ns</td><td>9 ns</td></tr><tr><td><a href=https://github.com/tearshark/librf>librf</a>(C++20 Coroutine) - Clang</td><td>310 ns / 292 ns</td><td>252 ns / 245 ns</td><td>29 ns / 29 ns</td><td>281 ns / 229ns</td><td>33 ns / 31 ns</td></tr><tr><td><a href=https://github.com/owent/libcopp/>libcopp+动态栈池</a></td><td>32 ns</td><td>96 ns</td><td>77 ns</td><td>212 ns</td><td>213 ns</td></tr><tr><td><a href=https://github.com/owent/libcopp/>libcopp+libcotask+动态栈池</a></td><td>49 ns</td><td>134 ns</td><td>134 ns</td><td>256 ns</td><td>371 ns</td></tr><tr><td>libcopp future_t(no trivial) - GCC</td><td>4 ns / 4 ns</td><td>26 ns / 24 ns</td><td>4 ns / 4 ns</td><td>26 ns / 31 ns</td><td>6 ns / 5 ns</td></tr><tr><td>libcopp future_t - GCC</td><td>4 ns / 4 ns</td><td>26 ns / 25 ns</td><td>4 ns / 4 ns</td><td>30 ns / 30 ns</td><td>9 ns / 5 ns</td></tr><tr><td>libcopp task_t(no trivial) - GCC</td><td>21 ns / 23 ns</td><td>120 ns / 118 ns</td><td>25 ns / 25 ns</td><td>122 ns / 131 ns</td><td>35 ns / 33 ns</td></tr><tr><td>libcopp task_t - GCC</td><td>41 ns / 32 ns</td><td>112 ns / 120 ns</td><td>41 ns / 32 ns</td><td>122 ns / 131 ns</td><td>50 ns / 38 ns</td></tr><tr><td>libcopp future_t(no trivial) - Clang</td><td>5 ns / 5 ns</td><td>30 ns / 30 ns</td><td>5 ns / 5 ns</td><td>30 ns / 35 ns</td><td>7 ns / 6 ns</td></tr><tr><td>libcopp future_t - Clang</td><td>7 ns / 7 ns</td><td>30 ns / 30 ns</td><td>7 ns / 7 ns</td><td>30 ns / 37 ns</td><td>8 ns / 8 ns</td></tr><tr><td>libcopp task_t(no trivial) - Clang</td><td>24 ns / 24 ns</td><td>237 ns / 142 ns</td><td>24 ns / 24 ns</td><td>357 ns / 156 ns</td><td>44 ns / 33 ns</td></tr><tr><td>libcopp task_t - Clang</td><td>53 ns / 44 ns</td><td>257 ns / 155 ns</td><td>53 ns / 45 ns</td><td>357 ns / 175 ns</td><td>70 ns / 61 ns</td></tr></tbody></table><p>上面 <a href=https://github.com/tearshark/librf>librf</a> 是另一个使用<a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a>的封装库，仅用它自带的工具，用一样的编译选线给出压力测试结果对比，据作者说单协程切换慢是由于内部的定时器接口开销比较高。上面还提供了使用 <a href=https://github.com/owent/libcopp/>libcopp</a> 传统有栈协程的开销对比。和其他一些常用协程库比如 <a href=https://github.com/Tencent/libco>libco</a> 、 <a href=https://github.com/yyzybb537/libgo>libgo</a> 、 goroutine 等的对比可以见我之前一篇分享: <a href=https://owent.net/2019/1911.html>《C++20 Coroutine 性能测试 (附带和libcopp/libco/libgo/goroutine/linux ucontext对比)》</a></p><p>最后测出来的创建 <code>task_t</code> 的开销分布如下:</p><p><img src=2004-create-bench-cost.dot.png alt></p><p>最后测出来的切换（创建 <code>generator_t</code> ）的开销分布如下:</p><p><img src=2004-await-bench-cost.dot.png alt></p><p>从结果来看，使用 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 后创建开销已经比较贴近原始的协程调用了，优化空间不大，毕竟设计模式还是有一定损耗的。但是切换开销目前 <a href=https://github.com/owent/libcopp/>libcopp</a> 的切换开销比裸调用原始API大，主要原因有两个。一是 <code>generator_t</code> 仍然有创建 <code>context_t</code> 和 <code>future_t</code> 还有 <code>用户层waker</code> 对象的开销；另一方面是wake接口会过一层 <code>std::function</code> + <code>future_t::poll_as</code> + <code>context_t::poll_as</code> + <code>用户层waker::operator()</code> 导致对inline和cache命中不友好。这方面还有优化空间，不过优化出来也只是跑分好看而已。 压力测试中是复用了 <code>generator_t</code> 对象多次产出数据，如果每次都创建新的 <code>generator_t</code> 平均开销会增大 <code>10-20ns</code> 。</p><p>来个直观点的对比图(不带 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 版本):</p><canvas id=charjs-chart-0>Chart 0</canvas>
<script type=text/javascript>jQuery(function(){var e="charjs-chart-0";new Chart(document.getElementById(e),{type:"bar",data:{labels:["协程数:1,栈大小16KB","协程数:1000,栈大小2MB","协程数:30000,栈大小64KB"],datasets:[{label:"C++20 Coroutine - Clang 切换耗时",borderColor:"rgba(139, 0, 0, 1)",fill:!1,yAxisID:"y-axis-2",data:[5,6,9],type:"line"},{label:"C++20 Coroutine - MSVC 切换耗时",borderColor:"rgba(0, 0, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[10,14,28],type:"line"},{label:"librf(C++20 Coroutine) - Clang 切换耗时",borderColor:"rgba(0, 139, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[null,29,33],type:"line"},{label:"libcopp+动态栈池 切换耗时",borderColor:"rgba(184, 134, 11, 1)",fill:!1,yAxisID:"y-axis-2",data:[32,77,213],type:"line"},{label:"libcopp+libcotask+动态栈池 切换耗时",borderColor:"rgba(189, 183, 107, 1)",fill:!1,yAxisID:"y-axis-2",data:[49,134,371],type:"line"},{label:"libcopp future_t - GCC 切换耗时",borderColor:"rgba(139, 0, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[4,4,9],type:"line"},{label:"libcopp future_t(no trivial) - GCC 切换耗时",borderColor:"rgba(85, 107, 47, 1)",fill:!1,yAxisID:"y-axis-2",data:[4,4,6],type:"line"},{label:"libcopp task_t - GCC 切换耗时",borderColor:"rgba(255, 140, 0, 1)",fill:!1,yAxisID:"y-axis-2",data:[23,25,35],type:"line"},{label:"libcopp task_t(no trivial) - GCC 切换耗时",borderColor:"rgba(153, 50, 204, 1)",fill:!1,yAxisID:"y-axis-2",data:[41,41,50],type:"line"},{label:"libcopp future_t - Clang 切换耗时",borderColor:"rgba(233, 150, 122, 1)",fill:!1,yAxisID:"y-axis-2",data:[5,5,7],type:"line"},{label:"libcopp future_t(no trivial) - Clang 切换耗时",borderColor:"rgba(143, 188, 143, 1)",fill:!1,yAxisID:"y-axis-2",data:[7,7,8],type:"line"},{label:"libcopp task_t - Clang 切换耗时",borderColor:"rgba(255, 20, 147, 1)",fill:!1,yAxisID:"y-axis-2",data:[24,24,44],type:"line"},{label:"libcopp task_t(no trivial) - Clang 切换耗时",borderColor:"rgba(72, 61, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[53,53,70],type:"line"},{label:"C++20 Coroutine - GCC 创建耗时",backgroundColor:"rgba(128, 0, 0, 1)",yAxisID:"y-axis-1",data:[null,120,122]},{label:"C++20 Coroutine - Clang 创建耗时",backgroundColor:"rgba(255, 0, 0, 1)",yAxisID:"y-axis-1",data:[null,130,136]},{label:"C++20 Coroutine - MSVC 创建耗时",backgroundColor:"rgba(0, 0, 255, 1)",yAxisID:"y-axis-1",data:[null,407,369]},{label:"librf(C++20 Coroutine) - Clang 创建耗时",backgroundColor:"rgba(0, 255, 255, 1)",yAxisID:"y-axis-1",data:[null,252,281]},{label:"libcopp+动态栈池 创建耗时",backgroundColor:"rgba(218, 165, 32, 1)",yAxisID:"y-axis-1",data:[null,96,212]},{label:"libcopp+libcotask+动态栈池 创建耗时",backgroundColor:"rgba(240, 230, 140, 1)",yAxisID:"y-axis-1",data:[null,134,256]},{label:"libcopp future_t - GCC 创建耗时",backgroundColor:"rgba(255, 0, 255, 1)",yAxisID:"y-axis-1",data:[null,26,30]},{label:"libcopp future_t(no trivial) - GCC 创建耗时",backgroundColor:"rgba(128, 128, 0, 1)",yAxisID:"y-axis-1",data:[null,26,26]},{label:"libcopp task_t(no trivial) - GCC 创建耗时",backgroundColor:"rgba(255, 165, 0, 1)",yAxisID:"y-axis-1",data:[null,120,122]},{label:"libcopp task_t - GCC 创建耗时",backgroundColor:"rgba(218, 112, 214, 1)",yAxisID:"y-axis-1",data:[null,112,122]},{label:" libcopp future_t - Clang 创建耗时",backgroundColor:"rgba(250, 128, 114, 1)",yAxisID:"y-axis-1",data:[null,30,30]},{label:"libcopp future_t(no trivial) - Clang 创建耗时",backgroundColor:"rgba(46, 139, 87, 1)",yAxisID:"y-axis-1",data:[null,30,30]},{label:"libcopp task_t(no trivial) - Clang 创建耗时",backgroundColor:"rgba(106, 90, 205, 1)",yAxisID:"y-axis-1",data:[null,237,357]},{label:"libcopp task_t - Clang 创建耗时",backgroundColor:"rgba(112, 128, 144, 1)",yAxisID:"y-axis-1",data:[null,257,357]}]},options:{title:{display:!0,text:"切换/创建耗时（越小越好）"},scales:{yAxes:[{type:"linear",display:!0,scaleLabel:{display:!0,labelString:"切换耗时（单位：纳秒）"},position:"left",id:"y-axis-2",gridLines:{drawOnChartArea:!1},ticks:{callback:function(e){return e+" ns"}}},{type:"logarithmic",display:!0,scaleLabel:{display:!0,labelString:"创建耗时（单位：纳秒）"},ticks:{autoSkip:!0,callback:function(e,t,n){for(o in n){var o,s=n[o];if(s<e&&Math.floor(Math.log(e))==Math.floor(Math.log(s)))return null}return e+" ns"}},position:"right",id:"y-axis-1"}]}}})})</script><p>再来个直观点的带 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 版本的对比图，带上 <a href=https://github.com/jemalloc/jemalloc>jemalloc</a> 之后对clang编译的结果影响比较大:</p><canvas id=charjs-chart-1>Chart 1</canvas>
<script type=text/javascript>jQuery(function(){var e="charjs-chart-1";new Chart(document.getElementById(e),{type:"bar",data:{labels:["协程数:1,栈大小16KB","协程数:1000,栈大小2MB","协程数:30000,栈大小64KB"],datasets:[{label:"C++20 Coroutine - Clang 切换耗时",borderColor:"rgba(139, 0, 0, 1)",fill:!1,yAxisID:"y-axis-2",data:[5,6,9],type:"line"},{label:"C++20 Coroutine - MSVC 切换耗时",borderColor:"rgba(0, 0, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[10,14,28],type:"line"},{label:"librf(C++20 Coroutine) - Clang 切换耗时",borderColor:"rgba(0, 139, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[null,29,31],type:"line"},{label:"libcopp+动态栈池 切换耗时",borderColor:"rgba(184, 134, 11, 1)",fill:!1,yAxisID:"y-axis-2",data:[32,77,213],type:"line"},{label:"libcopp+libcotask+动态栈池 切换耗时",borderColor:"rgba(189, 183, 107, 1)",fill:!1,yAxisID:"y-axis-2",data:[49,134,371],type:"line"},{label:"libcopp future_t - GCC 切换耗时",borderColor:"rgba(139, 0, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[4,4,5],type:"line"},{label:"libcopp future_t(no trivial) - GCC 切换耗时",borderColor:"rgba(85, 107, 47, 1)",fill:!1,yAxisID:"y-axis-2",data:[4,4,5],type:"line"},{label:"libcopp task_t(no trivial) - GCC 切换耗时",borderColor:"rgba(255, 140, 0, 1)",fill:!1,yAxisID:"y-axis-2",data:[23,25,33],type:"line"},{label:"libcopp task_t - GCC 切换耗时",borderColor:"rgba(153, 50, 204, 1)",fill:!1,yAxisID:"y-axis-2",data:[32,32,38],type:"line"},{label:"libcopp future_t - Clang 切换耗时",borderColor:"rgba(233, 150, 122, 1)",fill:!1,yAxisID:"y-axis-2",data:[5,5,6],type:"line"},{label:"libcopp future_t(no trivial) - Clang 切换耗时",borderColor:"rgba(143, 188, 143, 1)",fill:!1,yAxisID:"y-axis-2",data:[7,7,8],type:"line"},{label:"libcopp task_t(no trivial) - Clang 切换耗时",borderColor:"rgba(255, 20, 147, 1)",fill:!1,yAxisID:"y-axis-2",data:[24,24,33],type:"line"},{label:"libcopp task_t - Clang 切换耗时",borderColor:"rgba(72, 61, 139, 1)",fill:!1,yAxisID:"y-axis-2",data:[44,45,61],type:"line"},{label:"C++20 Coroutine - GCC 创建耗时",backgroundColor:"rgba(128, 0, 0, 1)",yAxisID:"y-axis-1",data:[null,118,131]},{label:"C++20 Coroutine - Clang 创建耗时",backgroundColor:"rgba(255, 0, 0, 1)",yAxisID:"y-axis-1",data:[null,130,136]},{label:"C++20 Coroutine - MSVC 创建耗时",backgroundColor:"rgba(0, 0, 255, 1)",yAxisID:"y-axis-1",data:[null,407,369]},{label:"librf(C++20 Coroutine) - Clang 创建耗时",backgroundColor:"rgba(0, 255, 255, 1)",yAxisID:"y-axis-1",data:[null,245,229]},{label:"libcopp+动态栈池 创建耗时",backgroundColor:"rgba(218, 165, 32, 1)",yAxisID:"y-axis-1",data:[null,96,212]},{label:"libcopp+libcotask+动态栈池 创建耗时",backgroundColor:"rgba(240, 230, 140, 1)",yAxisID:"y-axis-1",data:[null,134,256]},{label:"libcopp future_t - GCC 创建耗时",backgroundColor:"rgba(255, 0, 255, 1)",yAxisID:"y-axis-1",data:[null,25,30]},{label:"libcopp future_t(no trivial) - GCC 创建耗时",backgroundColor:"rgba(128, 128, 0, 1)",yAxisID:"y-axis-1",data:[null,24,31]},{label:"libcopp task_t(no trivial) - GCC 创建耗时",backgroundColor:"rgba(255, 165, 0, 1)",yAxisID:"y-axis-1",data:[null,118,131]},{label:"libcopp task_t - GCC 创建耗时",backgroundColor:"rgba(218, 112, 214, 1)",yAxisID:"y-axis-1",data:[null,120,131]},{label:" libcopp future_t - Clang 创建耗时",backgroundColor:"rgba(250, 128, 114, 1)",yAxisID:"y-axis-1",data:[null,30,35]},{label:"libcopp future_t(no trivial) - Clang 创建耗时",backgroundColor:"rgba(46, 139, 87, 1)",yAxisID:"y-axis-1",data:[null,30,37]},{label:"libcopp task_t(no trivial) - Clang 创建耗时",backgroundColor:"rgba(106, 90, 205, 1)",yAxisID:"y-axis-1",data:[null,142,156]},{label:"libcopp task_t - Clang 创建耗时",backgroundColor:"rgba(112, 128, 144, 1)",yAxisID:"y-axis-1",data:[null,155,175]}]},options:{title:{display:!0,text:"切换/创建耗时（越小越好）"},scales:{yAxes:[{type:"linear",display:!0,scaleLabel:{display:!0,labelString:"切换耗时（单位：纳秒）"},position:"left",id:"y-axis-2",gridLines:{drawOnChartArea:!1},ticks:{callback:function(e){return e+" ns"}}},{type:"logarithmic",display:!0,scaleLabel:{display:!0,labelString:"创建耗时（单位：纳秒）"},ticks:{autoSkip:!0,callback:function(e,t,n){for(o in n){var o,s=n[o];if(s<e&&Math.floor(Math.log(e))==Math.floor(Math.log(s)))return null}return e+" ns"}},position:"right",id:"y-axis-1"}]}}})})</script><h3 id=原task对象的接入>原task对象的接入</h3><p>现在的实现中，<a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a>可以 <code>co_await</code> 原来老的 <code>cotask::task&lt;T></code> 。反过来有个想法是 <code>task_action::operator()</code> 返回 <code>copp::future::task_t</code> 的话就可实现反过来的 <code>co_await</code> 。但是要兼容以前的函数签名得模板写得比较调皮，而且也只能支持一层。暂时还没决定好要怎么写。现在支持的向前兼容的形式如下:</p><pre><code class=language-cpp>#include &lt;iostream&gt;

#include &lt;libcopp/future/std_coroutine_task.h&gt;
#include &lt;libcotask/task.h&gt;

#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) &amp;&amp; LIBCOPP_MACRO_ENABLE_STD_COROUTINE

typedef cotask::task&lt;&gt; my_task_t;

static copp::future::task_t&lt;int&gt; call_for_await_cotask(my_task_t::ptr_t t) {
    if (t) {
        co_return co_await t;
    }

    co_return 0;
}

static int cotask_action_callback(void *) {
    int ret = 234;
    void* ptr = nullptr;
    cotask::this_task::get_task()-&gt;yield(&amp;ptr);
    if (ptr != nullptr) {
        ret = *reinterpret_cast&lt;int*&gt;(ptr);
    }
    return ret;
}

int main() {
    my_task_t::ptr_t co_task = my_task_t::create(cotask_action_callback);

    auto t = call_for_await_cotask(co_task);
    co_task-&gt;start();

    int res = 345;
    co_task-&gt;resume(reinterpret_cast&lt;void*&gt;(&amp;res));

    if (nullptr != t.data()) {
        std::cout&lt;&lt; &quot;co_await a cotask::task and get result: &quot;&lt;&lt; *t.data()&lt;&lt; std::endl;
    }
    return 0;
}
</code></pre><h2 id=关于msvc的-stdexperimentalgenerator-和-cppcoro6-的-cppcorogenerator>关于MSVC的 <code>std::experimental::generator</code> 和 <a href=https://github.com/lewissbaker/cppcoro>cppcoro</a> 的 <code>cppcoro::generator</code></h2><p><a href=https://github.com/lewissbaker/cppcoro>cppcoro</a> 里有个 <code>cppcoro::generator</code> ， MSVC现在最新的版本里也有个 <code>std::experimental::generator</code> ，这两个东西的实现和功能基本上是一样的。但是这两个东东的设计功能和我们的 <code>libcopp::future::generator_t</code> 不同，前者主要是对协程外数据访问提供迭代器取协程内产生的数据，而后者是给协程内部提供数据产生器。</p><p>我个人地理解里，在我们特别是游戏服务器的使用场景，一般是有个大的任务，里面调用很多个不同的SDK或者模块。在这种场景中，能够使外部模块和外部系统的接入能够方便地接入到我们地协程中就更加地实用。</p><h2 id=gcc-1010-的坑>GCC 10.1.0 的坑</h2><h3 id=符号问题>符号问题</h3><p>我发现在 <strong>GCC 10.1.0</strong> 中，如果多个文件可能会引用到协程库的时候，链接时会报类似这样的错误</p><pre><code class=language-bash>C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: CMakeFiles/libcopp_unit_test.dir/objects.a(future_and_std_coroutine_test2.cpp.obj): in function `std::__n4861::__dummy_resume_destroy()':
C:/msys64/mingw64/include/c++/10.1.0/coroutine:222: multiple definition of `.weak._ZNSt7__n486122__dummy_resume_destroyEv._ZnwyPv'; CMakeFiles/libcopp_unit_test.dir/objects.a(future_and_std_coroutine_test.cpp.obj):C:/msys64/mingw64/include/c++/10.1.0/coroutine:222: first defined here
[100%] Built target libcopp_sample_readme_3
C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: CMakeFiles/libcopp_unit_test.dir/objects.a(future_and_std_coroutine_test2.cpp.obj):future_and_std_coroutine_test2.cpp:(.data+0x0): multiple definition of `.weak._ZNSt7__n486114__noop_coro_frE._ZnwyPv'; CMakeFiles/libcopp_unit_test.dir/objects.a(future_and_std_coroutine_test.cpp.obj):D:/workspace/github/libcopp/test/frame/test_manager.h:130: first defined here
</code></pre><p>看提示和出错的符号名感觉应该是引用到的相关头文件应该要生成弱符号，结果生成了强符号导致链接不过。这个问题仅在Windows上出现（我的测试环境是MSYS2带的MinGW64环境， GCC 10.1.0 ），Linux下正常。初步查了下Windows下输出的中间文件 <code>.obj</code> 中生成了代码（T）符号和弱（W）符号。而在Linux下只生成了弱（W）符号。看涉及的符号名感觉是GCC的BUG，猜测是GCC 10.1.0实现生成的符号可见性有点问题，我没有过多的深究。</p><h3 id=生命周期和析构>生命周期和析构</h3><p>本来受 <a href=https://github.com/lewissbaker/cppcoro>cppcoro</a> 的启发，想实现这样的使用接口。 <code>auto poll_data = co_await copp:future::make_generator&lt;T, TPD>(...);</code> 。然后 <code>poll_data</code> 指向 <code>copp:future::poll_t&lt;T></code> 来获取协程数据结果。 这里有两个临时对象，一个是 <code>generator_t</code> ， 另一个是 await <code>generator_t</code> 时产生的 <code>awaitable_t</code> 。 为了减少分配开销，我们的context和future对象都直接分配在 <code>generator_t</code> 里，然后 <code>generator_t</code> 禁止复制和禁止转移， 并且在 <code>awaitable_t</code> 的 <code>await_resume</code> 接口里通过右值构造临时对象转移数据。
这个流程在 MSVC 上是可行的，但是在GCC里 <code>awaitable_t</code> 挂起之前，临时的 <code>generator_t</code> 会被析构掉。这会导致context和future对象被释放。 所以为了性能考虑，最终还是只允许稍微繁琐一点的使用方式。</p><pre><code class=language-cpp>auto generator = copp:future::make_generator&lt;T, TPD&gt;(...);
auto future_data = co_await generator;
if (nullptr != future_data &amp;&amp; future_data-&gt;is_ready()) {
  // ...
}
</code></pre><p>同样，这个问题和导致的使用上的限制在 <code>copp:future::task_t</code> 上也一样。</p><h2 id=apple-clang-9-和-clang-6-开编译优化后访问协程栈变量崩溃问题>Apple clang 9 和 Clang 6 开编译优化后访问协程栈变量崩溃问题</h2><p>在CI跑单元测试的时候我发现有些环境里执行协程函数会直接崩溃掉。经测试只在 Clang 6 和 Apple Clang 9 上出现。原因是生成的协程栈局部变量访问的时候，Clang 6 和 Apple Clang 9（我只测试了x86_64）会使用 <code>movaps</code> 的SSE1指令来优化初始化内存数据（一次赋值16字节）。这个指令的目标是内存地址的话，是需要内存地址对齐到16的，但是在开启 <code>-O2</code> 的编译优化以后，可能会生成未对齐的目的地址。（ 指令参见: <a href=https://www.felixcloutier.com/x86/movaps>https://www.felixcloutier.com/x86/movaps</a> ）</p><p>比如对 <code>char buffer[256] = {0};</code> 这段代码，Clang 6生成的代码是:</p><pre><code class=language-assembly>movl    $336, %edi                  # imm = 0x150
callq   operator new(unsigned long) # 创建协程栈变量数据块
movq    %rax, %r12                  # 返回值 -&gt; %r12寄存器
# ...
xorps   %xmm0, %xmm0                # 初始化赋值
movaps  %xmm0, 280(%r12)            # %r12由new分配，由malloc保证总是对齐到16的。280 % 16 == 8，未对齐
movaps  %xmm0, 264(%r12)
movaps  %xmm0, 248(%r12)
movaps  %xmm0, 232(%r12)
# ...
</code></pre><p>而Clang 7生成的没问题的代码是:</p><pre><code class=language-assembly>movl    $344, %edi                  # imm = 0x158
callq   operator new(unsigned long) # 创建协程栈变量数据块
movq    %rax, %r12                  # 返回值 -&gt; %r12寄存器
# ...
xorps   %xmm0, %xmm0                # 初始化赋值
movaps  %xmm0, 288(%rax)            # %rax由new分配，由malloc保证总是对齐到16的。288 % 16 == 0，已对齐
movaps  %xmm0, 272(%rax)
movaps  %xmm0, 256(%rax)
movaps  %xmm0, 240(%rax)
# ...
</code></pre><p>完整的例子和对比可以参见这里: <a href=https://godbolt.org/z/QHREMu>https://godbolt.org/z/QHREMu</a></p><iframe src="https://godbolt.org/e?readOnly=true&amp;hideEditorToolbars=true#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tENwAcpLegAyeWpgByxgEaZiIAOwAGUgAdUBUJ1Wj1DEzNLAKC1OjsHZyM3Dx9FZUxVEIYCZmICMONTCzSVWNps3IJ4p1d3L18FHLyCiOLGyurE5PqASkVUA2JkDgByKQBme2RDLABqcXGddUbiTGYjBexxbwBBCamZzHnF9SMRPD9N7b3JSdppgzmFnQA3DKJiK93r/fvD450RkwRhIAE8vntvrcDo8js9MAAPPzuPBA%2BhsAD0aGIAzUDgh1xWBlUswA7sxCAB9BSoIGUtRAhTzTyyXazdmzewEWbsKgEemozAKBasnYc2aNdAgECI5HEQXo1jS7G4%2ByYSkIETodjPTazTXaHXjUXi8lUml0hlCiBc2YEHqzEA8zB8gWMiD20j6rXsCC0AysVh%2BAjEB3iFnhgAiP080eNP12RJJCgMCmR2mptPVVqZ4ZNHLN/It2cFwskADZZugRddxSm09ZM5bSxBC02S4ypJXKegHU70BAe2GI7HaxyXKh9LNmG3Vsx0KCIA7aKhEcNg8z8%2BL2ZLlbiAc95pJJCxA9PZ2sF06pJID4sqwA6Xn8nN3nQSghSmWGmts7fs1YCEGWhH2fN0hTvSNZm8X8xQ5KMEzg9kXlQPB0HPCki1TdMB13GUkRRNEciVFASFVBwNR9OFFj1BBl1XBF125PMx3/dAHwNbVqKghBYP/HdPz3AxmJo%2B8b1PVgMPNbDrGvY831mCAAFolPYsCczDUT3zw6xWD4%2BDR2%2BP9kNQ9CZ0wylVhTIEl1mFc10wDcWOM7c8LQYSFPEthJPMqkrOMDgj1vXV7zUl0X1LBSdJ/eMXPFdjOPYY4oP9QNg0%2BWKkOZaNvlHTLCRDYluRVYS1XpZgFAAa03ViP2IIrZj8HEjDwJR6VBZEarijlkE1YgACoP2YZBKspFwDCoKh3H0/8mtpVrsw6zAlyddoRrGiapuIP0AyDEMehYwysvFEq8WzCrquATB%2BUA4DKVQFw%2BHeWznOO/jbuIEDTrKnIqrzAgEFahDMv47LavFZhhNQTlaGCNhqRk7QXojbr/w%2BkCdII%2BUiLYaV6xwykHDeT4RzjLdtwQ1Hpyh2YqHseH8esZHydB9GPy/WVCK0Yi8cR9BCcwYnDrJ8GDJyyE3pMtDZgMWhEswfmHODEJmcpyXZhQ6X0cpTWB2HWQjtByGiFmUE8GUfmXjYAxlt63JBvndBQy69W6xydbxsm9xkundAnZm0HZjZzG5QVHmQEZjMiem0mA/FNX47y0Varmlq2oIJbBtThbYNq76KN%2ByqIGz9PM5hnonRL5b7H1tXgeT3Zjeh1A5WYD5ZjQSlfIIVsLOLcCy0rBF6KV5iUay4O%2BfbAe81mBEwfyo7rnz86qtp3vzSzGeKzJTD3Frly7eIWZPa28QAFZpEkc/ywvqCFnvlkYKT2q3P3EL3xvNxgHsO1oc77uN4oqCW/NqAOnczYWxPptaaIMeqoC7oWXehBYHkzfh5D%2BQVrCzFQFQDuZEzpyUkJg0%2B3tMHRTAYvcW1xbRnHsKrKEkwqBYDwZSSkyA/B%2BHYWRUqDhhQuXQSJHQh4bxsI4VwleCgiEKTEZw7hOJeEQXISA3SudbjWDwFQWqbZ%2B6vkLDHaQsxOAL3JlQDeBB965xcqSQGSVzHuA4lRI8t8d5gDAPo4gjjDSYAfOgOgy0egH3VoIzyx5mATg8ibfyQJpGYI8U%2BcKA9gEcxiizAse9PHywfNEgJAc64uTZjBKhIw%2BhKhGOfEYpBTAjG8JU1AIARjCJkHICUAwhhwluJwSpBAGm1MCaQSqZhvAPk4OMHw59xjjHPpIAAnJwW4MzyxCAadwSp1TamkHqSMSpUjfA9JqSU0gcBYAwCgKciASA0BGD8HgdgZAKAQCuTcu5KBhCiHLN4XwdNWAWOIFIiALhemVJcPTYgoIGldNIFcoiAB5WgrBwUHNIFgM4oh2BAuRXgVYmQ3hSKRYiDIwlRgbK5MoCFlTWB4BcMQXIoI9BYHJaQEMqJyV9BoPQJgbAOA8H4IIN5Yg5ByCEFSqRkA%2BgtzKHipSMLbxKQAOreVmPKxEIZmBKqoJIpSBAmRKUlA/CQzSZCSDVbqz8lKXAP3NQa2QMgdnpEyBoCA1gWimE4FYbQnRageDddEYIdAXWCF9WUT1SQ6huqUKULITR8j6EKIICN7wo0dDVF0MNiho0BvDdGkN3ROB9BpIMYYXBSkNIqVUjFWyETmHLEpcs3AO78tmOWB8wzvCKVwIQEgR5xhutmHoa5tyyGdIdE0m10hulAv6YM8%2BvgymrNIEYEA5ZOAjO4J4Tg1aeDrs3efctSKtk7JAHsydRzzmXNpM89w5BKBPMHR4aYIhgA%2BC%2Bbc35/zAVIpBbQWljLoXczhQijFKLH3oqRfgbFahcUYoJcgIlGLSVlMheamlYL6WjEhcyxdIwulsroIwU83LeACEkEIR9KBBUyGFS4UVS5NnKzoFKmVSqFVnmVQiVV6rNXaqVXq8YkZrVyGNTxs1VLLVUoE7akoibHXOtjREN11gc1pqDSETN/hAh%2BtoEp71UmHXlAzXJ11umygVDyNp%2BNBnwhGfaGZlNXri39ELdykt5S1kVoaVWmtdaG2PtmJ4FtLb234HbhMXt/bL3HwmJIEdFHx1MsnX0BAl46i0enbOlZbn90NMPceg5/SymSEqYu5dq7t3LrXRu5du71l1Oy/FvLp74DHMQCAXEfhhLXseReu9ggFadp0%2By/DXKuC8FJDSvwrLlmub3RsrZoWySEAQHPattb60PtEE2gLGz9l9L6Glqb87F3jHMA%2Bcw0zzCjLO5IC7x3qvue2YoI99W%2BmNdgEgNrHWHm3peSRvrHxBCDc5einlY3mATew4cspZaaubIaVFhbANltebW42/zraJ15cS8ljwqWQAzoO5l2bdXdnPZKS5wrC6QDHdO%2Bdy7tPbszdqw9nbZOBl45mad8sszuDljrT4cwng61TfGITpnGPdtTYpzDg9pP%2BnEyCBobgQA%3D%3D%3D" width=80% height=720px></iframe><h2 id=写在最后>写在最后</h2><p>至此 <a href=https://github.com/owent/libcopp/>libcopp</a> 对 <a href=https://en.cppreference.com/w/cpp/language/coroutines>C++20协程</a> 的接入就初步完成了。后面有空还可以加一些语法糖类的辅助工具，迭代器支持，manager接入之类的。这就后续有空再说了。欢迎有兴趣的童鞋们一起交流。</p></div><hr><footer class=article-footer><div class="article-panel-footer article-meta article-footer clearfix"><span class=article-meta-left><ol><li><a href=//owent.net/categories/article.html>Article</a></li><li><a href=//owent.net/categories/blablabla.html>Blablabla</a></li></ol></span><span class=article-meta-right><time datetime=2020-05-22T15:36:58.000+00:00 itemprop=datePublished>2020-05-22</time></span>
<span class=clearfix></span></div><div class=article-tags><ul class=article-tag-list><li class=article-tag-list-item><a href=//owent.net/tags/libcopp.html>libcopp</a></li><li class=article-tag-list-item><a href=//owent.net/tags/coroutine.html>coroutine</a></li><li class=article-tag-list-item><a href=//owent.net/tags/cxx.html>cxx</a></li><li class=article-tag-list-item><a href=//owent.net/tags/c++20.html>c++20</a></li><li class=article-tag-list-item><a href=//owent.net/tags/co_await.html>co_await</a></li><li class=article-tag-list-item><a href=//owent.net/tags/await.html>await</a></li><li class=article-tag-list-item><a href=//owent.net/tags/rust.html>rust</a></li><li class=article-tag-list-item><a href=//owent.net/tags/future.html>future</a></li><li class=article-tag-list-item><a href=//owent.net/tags/promise.html>promise</a></li><li class=article-tag-list-item><a href=//owent.net/tags/async.html>async</a></li></ul></div></footer></div><hr><nav id=article-nav><ul class=pagination><li class=page-item><a class=page-link id=article-nav-newer class=article-nav-link-wrap href=//owent.net/2020/2005.html>上一篇<strong>在游戏服务器中使用分布式事务</strong></a></li><li class=page-item><a class=page-link id=article-nav-older class=article-nav-link-wrap href=//owent.net/2020/2003.html>下一篇<strong>libatbus 的大幅优化</strong></a></li></ul></nav><hr><script src=https://utteranc.es/client.js repo=owent/blog-website issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></div></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>
2024
owent
</strong><strong id=footer-right class="float-right float-end"><a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=text/javascript src=//unpkg.com/@popperjs/core@latest/dist/umd/popper.min.js crossorigin=anonymous></script><script type=text/javascript src=//unpkg.com/bootstrap@latest/dist/js/bootstrap.min.js crossorigin=anonymous></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>jQuery(function(){jQuery("head").append('<link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css" />'),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const e={};for(const t of hljs.listLanguages())e[t.toLowerCase()]=!0;jQuery("pre>code").each(function(e,t){try{if(t.className.match(/\bnohighlight\b|\bmermaid\b/i))return;const e=t.className.match(/language-([^\s]+)/i);if(e&&e.length>=2&&hljs.getLanguage(e[1]))hljs.highlightElement(t);else{const e=jQuery(t),n=hljs.highlightAuto(e.text(),hljs.listLanguages());n&&n.value&&(e.html(n.value),e.addClass("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>jQuery(function(){jQuery("head").append('<link rel="stylesheet" href="//unpkg.com/katex@latest/dist/katex.min.css" />'),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
    import mermaid from "\/\/unpkg.com\/mermaid@latest\/dist\/mermaid.esm.min.mjs";
    const config = {
        theme: 'neutral',
        logLevel: 'fatal',
        securityLevel: 'loose', 
        startOnLoad: true,
        arrowMarkerAbsolute: false,
        

    };
    mermaid.initialize(config);
</script></div></body></html>