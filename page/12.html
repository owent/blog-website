<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><title>I'm OWenT|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/><link rel=alternate type=application/rss+xml href=//owent.net/index.xml title="I'm OWenT"><link rel=icon href=/favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script type=importmap>
{
  "imports": {
    "react": "//unpkg.com/react@latest",
    "react-bootstrap": "//unpkg.com/react-bootstrap@latest",
    "mermaid": "//unpkg.com/mermaid@latest/dist/mermaid.esm.min.mjs",
    "bootstrap": "//unpkg.com/bootstrap@latest/dist/js/bootstrap.esm.min.js",
    "@popperjs/core": "//unpkg.com/@popperjs/core@latest/dist/esm/popper.js"
  }
}
</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta content="codeva-4M5iohb9TW" name=baidu-site-verification></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=/archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=/about.html title=About>About</a></li><li class=nav-item><a id=nav-rss-link class=nav-link href=//owent.net/index.xml title=RSS订阅>RSS订阅</a></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=index-content><article class="article-panel archive-article archive-type-63"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/63.html target=_blank itemprop=url>POJ PKU 1990 MooFest 解题报告</a></h1></header><div class=article-summary><p>为什么我用线段数这么不灵活呢？</p><p>大概思路是线段数记录某牛之前的坐标小于这个牛的牛的坐标和和牛的个数</p><p>然后其他部分线性数组记录</p><p>OK，贴代码</p><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

#define MAXN 20005
class cow
{
public:
    int v;
    int pos;
    cow(){};
    ~cow(){};
};

bool cmp(cow a,cow b)
{
    return a.v &lt; b.v;
}
cow cw[MAXN];
long long belowXNT[MAXN];//树状数组，保存小于等于某坐标的牛的个数,计算时使用
long long belowXN[MAXN];//一般数组，保存小于等于某坐标和索引的牛的个数
long long velowXRT[MAXN];//树状数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和,计算时使用
long long velowXR[MAXN];//一般数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和
long long velowXRA[MAXN];//一般数组，保存小于等于某牛的坐标之和

int lowbit(int t)
{
    return t&amp;(t^(t-1));
}
void setVal(int pos, int num, long long treeG[], int maxn)
{
    while (pos &lt;= maxn)
    {
        treeG[pos] += num;
        pos += lowbit(pos);
    }
}
long long getSum(int pos, long long treeG[])
{
    long long sum = 0;
    while (pos &gt; 0)
    {
        sum += treeG[pos];
        pos -= lowbit(pos);
    }
    return sum;
}



int main()
{
    int i,n;
    long long output = 0;
    memset(belowXN, 0, sizeof(belowXN));
    memset(belowXNT, 0, sizeof(belowXN));
    memset(velowXR, 0, sizeof(velowXR));
    memset(velowXRA, 0, sizeof(velowXRA));
    memset(velowXRT, 0, sizeof(velowXRT));
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 0 ; i &lt; n ; i ++)
        scanf(&quot;%d %d&quot;, &amp;cw[i].v, &amp;cw[i].pos);

    sort(cw, cw + n, cmp);
    for(i = 0 ; i &lt; n ; i ++)
    {
        velowXRA[i] = velowXRA[i - 1] + cw[i].pos;
        setVal(cw[i].pos, 1, belowXNT, MAXN);
        setVal(cw[i].pos, cw[i].pos, velowXRT, MAXN);
        velowXR[i] = getSum(cw[i].pos, velowXRT);
        belowXN[i] = getSum(cw[i].pos, belowXNT);
    }

    for(i = 1 ; i &lt; n ; i ++)
        //output += cw[i].v * ((belowXN[i] - 1) * cw[i].pos - velowXR[i] + cw[i].pos + velowXRA[i] - velowXR[i] - (i - belowXN[i] + 1) * cw[i].pos);
        output += cw[i].v * ((belowXN[i] - i + belowXN[i] - 1 ) * cw[i].pos - 2 * velowXR[i] + velowXRA[i]);//这里是上面式子的简化版

    printf(&quot;%lld\n&quot;,output);
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/63.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-12-23T14:12:52.000+00:00 itemprop=datePublished>2009-12-23</time></div></div></article><article class="article-panel archive-article archive-type-64"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/64.html target=_blank itemprop=url>POJ PKU 2378 Tree Cutting 解题报告</a></h1></header><div class=article-summary><p>又来发解题报告了</p><p>这回是树状DP</p><pre><code class=language-cpp>/*
 * 树状DP
 * 首先把数据想象成树状的
 * 由于输入数据为树状，不需要构建树
 * 可令degree[i]为包括i且以i为根节点的所有子节点数量
 * dp[i]为删除i后的最大子节点数量或父亲节点数量 （这里我理解了很久）
 */
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt;chirld[10002];
int dp[10002] = {0}
    ,degree[10002] = {0}
    ,isJudged[10002] = {0};

int search(int pos,int &amp;n);
int main()
{
    int n,i,a,b;
    bool isnone = true;
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 1 ; i &lt; n ; i ++)
    {
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        chirld[a].push_back(b);
        chirld[b].push_back(a);
    }

    search(1 , n);

    for(i = 1 ; i &lt;= n ; i ++)
        if(dp[i] * 2 &lt;= n)
            printf(&quot;%d\n&quot;,i) , isnone = false;

    if(isnone)
        printf(&quot;NONE\n&quot;);
    return 0;
}

int search(int pos,int &amp;n)
{
    int i,j;
    degree[pos] = 1;
    isJudged[pos] = 1;
    dp[pos] = 0;

    for(i = 0 ; i &lt; chirld[pos].size() ; i ++)
    {
        if(!isJudged[chirld[pos].at(i)])//如果已经判断过就是父亲节点了
        {
            degree[pos] += search(chirld[pos].at(i) , n);
            if(dp[pos] &lt; degree[chirld[pos].at(i)])
                dp[pos] = degree[chirld[pos].at(i)];
        }
    }

    if(dp[pos] &lt; n - degree[pos])//判断父亲节点数量
        dp[pos] = n - degree[pos];
    return degree[pos];
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/64.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-12-23T14:09:13.000+00:00 itemprop=datePublished>2009-12-23</time></div></div></article><article class="article-panel archive-article archive-type-65"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/65.html target=_blank itemprop=url>POJ PKU 2528 Mayor's posters 解题报告</a></h1></header><div class=article-summary><p>题目链接: <a href="http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528">http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528</a></p><p>这题又是线段树+离散化</p><p>慢慢的对离散化有点感觉了,但是这题我还是错了3次</p><p>题目大意是一层一层地叠板子,问最后能看到几块</p><p>输入是板子的开始和结束位置</p></div><div class=article-more><a href=//owent.net/2009/65.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-18T17:49:55.000+00:00 itemprop=datePublished>2009-11-18</time></div></div></article><article class="article-panel archive-article archive-type-66"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/66.html target=_blank itemprop=url>我的ACM生涯</a></h1></header><div class=article-summary><p>在ACM的竞技场上走过了一年。这一年是充满艰难的一年，这一年是充满困惑的一年。这也是充满激情的一年。这之间有欢笑，有惊喜,也有黯然失色的悲伤.苦战一年，却没有拿到任何的成绩， regional的失败让我刻骨铭心也深深感受到了实力的差距。伤感之余也让我想起了我们ECUST的ACM之歌,我又看了一遍，每次看这篇文章都会有种说不出的感动与激情。让我有了继续走下去的力量。明年，再战ACM，等着我们，我们要成为明年名副其实的ACMer。</p></div><div class=article-more><a href=//owent.net/2009/66.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-17T17:57:31.000+00:00 itemprop=datePublished>2009-11-17</time></div></div></article><article class="article-panel archive-article archive-type-67"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/67.html target=_blank itemprop=url>POJ PKU 3277 City Horizon 解题报告</a></h1></header><div class=article-summary><p>题目链接:<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3277">http://acm.pku.edu.cn/JudgeOnline/problem?id=3277</a></p><p>线段树+离散化</p><p>ACM预选赛过去了,可是我们队什么都没拿到,这给我们的打击是相当大的,这也很大程度上体现了我们的不足</p><p>一直没能静下心,来,今天决定不能再这么悲伤下去,我要奋斗,继续学习,就从之前的断点线段树开始</p></div><div class=article-more><a href=//owent.net/2009/67.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-12T17:23:39.000+00:00 itemprop=datePublished>2009-11-12</time></div></div></article><article class="article-panel archive-article archive-type-69"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/69.html target=_blank itemprop=url>POJ PKU 2549 Sumsets 解题报告</a></h1></header><div class=article-summary><p><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2549">题目链接http://acm.pku.edu.cn/JudgeOnline/problem?id=2549</a></p><p>这道题伤了我很久脑筋</p><p>因为是a+b+c=d,数据量是1000,很自然地想到a+b=d-c</p><p>这样转化为n^2的算法.</p><p>但是我开始枚举d-c的集合二分查找a+b的几何不知道为什么WA掉了</p></div><div class=article-more><a href=//owent.net/2009/69.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-10-04T15:54:36.000+00:00 itemprop=datePublished>2009-10-04</time></div></div></article><article class="article-panel archive-article archive-type-74"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/74.html target=_blank itemprop=url>最长单调子序列 复杂度nlog(n)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//最长单调子序列 复杂度nlog(n)
//参数(原序列,序列长度,生成的序列),传入序列长度必须大于0
//返回值中lengthRecord中前k项表示长度为k的最小字序列
//LIScmp为关系函数,原函数表明lengthRecord为递增(不含等于)
typedef double LISTYPE;
#define LISMAXN 10000
int LIScmp(LISTYPE a,LISTYPE b)
{
    return a &lt; b;
}
long LISLength(LISTYPE list[],long n,LISTYPE lengthRecord[])
{
    long length = 1,lth;
    LISTYPE lR[LISMAXN];
    lR[0] = list[0];

    for(int i = 1 ; i &lt; n ; i ++)
    {
        //二分查找,复杂度 log(n)
        int b,e,m;
        b = 0;
        e = length - 1;
        while(b &lt;= e &amp;&amp; e &gt;= 0)
        {
            m = (b + e) / 2;
            if(LIScmp(lR[m],list[i]))
                b = m + 1;
            else
                e = m - 1;
        }
        lR[b] = list[i];
        if(b &gt;= length)
            length ++;
    }
    /*
    *计算序列部分
    *复杂度nlog(n)
    */
    lth = 1;
    for(int i = 1 ; i &lt; n ; i ++)
    {
        //二分查找,复杂度 log(n)
        int b,e,m;
        b = 0;
        e = lth - 1;
        while(b &lt;= e &amp;&amp; e &gt;= 0)
        {
            m = (b + e) / 2;
            if(LIScmp(lR[m],list[i]))
                b = m + 1;
            else
                e = m - 1;
        }
        lR[b] = list[i];
        if(b &gt;= lth)
            lth ++;
        if(lth == length)
        {
            for(b = 0 ; b &lt; length ; b ++)
                lengthRecord[b] = lR[b];
            break;
        }
    }
    //计算序列部分代码与之前的类似,可以直接Copy然后修改
    return length;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/74.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-16T04:44:59.000+00:00 itemprop=datePublished>2009-09-16</time></div></div></article><article class="article-panel archive-article archive-type-75"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/75.html target=_blank itemprop=url>Prime最小生成树(个人模板)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//Prime连通路模块
#define N 1000         //最大数据规模
#define MAXNUM 3000000   //最大路径长度
typedef double PrimeType;//路径类型

PrimeType PrimeRecord[N];
PrimeType dis[N][N];
int isLined[N] = {1,0};

PrimeType GetPrimeLength(const long n)
{
    PrimeType tmpLen = MAXNUM;
    long tmpPos = 0,left = n - 1;
    PrimeType sumLen = 0;

    for(long i = 1 ; i &lt; n ; i ++)
        PrimeRecord[i] = dis[0][i];
    while(left --)
    {
        tmpLen = MAXNUM;
        for(long i = 1 ; i &lt; n ; i ++)
            if(!isLined[i] &amp;&amp; PrimeRecord[i] &lt; tmpLen)
                tmpPos = i,tmpLen = PrimeRecord[i];

        sumLen += tmpLen;
        isLined[tmpPos] ++;
        for(long i = 1 ; i &lt; n ; i ++)
            if(dis[tmpPos][i] &lt; PrimeRecord[i])
                PrimeRecord[i] = dis[tmpPos][i];
    }

    return sumLen;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/75.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-15T16:43:29.000+00:00 itemprop=datePublished>2009-09-15</time></div></div></article><article class="article-panel archive-article archive-type-76"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/76.html target=_blank itemprop=url>矩阵相关 (增强中)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//MULDATATYPE为矩阵元素类型,MAXMAT为最大矩阵大小

typedef long MULDATATYPE;
#define MAXMAT 100
#define inf 1000000000

#define fabs(x) ((x)&gt;0?(x):-(x))
#define zero(x) (fabs(x)&lt;1e-10)

struct mat
{
    long n,m;
    MULDATATYPE data[MAXMAT][MAXMAT];
    void operator =(const mat&amp; a);
    mat operator +(const mat&amp; a);
    mat operator -(const mat&amp; a);
    //0-1邻接矩阵
    mat operator &amp;(const mat&amp; a);
    mat operator |(const mat&amp; a);
};

//c=a*b
//注意引用
int Mat_MulMode(mat&amp; c,const mat&amp; a,const mat&amp; b,MULDATATYPE mod)
{
    long i,j,k;
    if (a.m != b.n)
        return 0;
    c.n = a.n , c.m = b.m;
    for (i = 0 ; i &lt; c.n ; i ++)
        for (j = 0 ; j &lt; c.m ; j ++)
            for (c.data[i][j] = k = 0 ; k  &lt; a.m ; k ++)
                c.data[i][j] = (c.data[i][j] + a.data[i][k] * b.data[k][j]) % mod;
    return 1;
}
//c=a^b(其中必须满足b&gt;0)
int Mat_PowMode(mat&amp; c,mat a,long b,MULDATATYPE mod)
{
    c = a;
    b --;
    while(b)
    {
        mat tmp;
        if(b &amp; 1)
        {
            tmp = c;
            Mat_MulMode(c,tmp,a,mod);
        }
        tmp = a;
        Mat_MulMode(a,tmp,tmp,mod);
        b = b&gt;&gt;1;
    }
    return 1;
}
//c=a+b
int Mat_AddMode(mat&amp; c,const mat&amp; a,const mat&amp; b,MULDATATYPE mod)
{
    long i,j;
    if (a.n != b.n || a.m != b.m)
        return 0;
    c.n = a.n , c.m = b.m;
    for (i = 0 ; i &lt; c.n ; i ++)
        for (j = 0 ; j &lt; c.m ; j ++)
            c.data[i][j] = (a.data[i][j] + b.data[i][j]) % mod;
    return 1;
}
//c=a-b
int Mat_SubMode(mat&amp; c,const mat&amp; a,const mat&amp; b,MULDATATYPE mod)
{
    long i,j;
    if (a.n != b.n || a.m != b.m)
        return 0;
    c.n = a.n , c.m = b.m;
    for (i = 0 ; i &lt; c.n ; i ++)
        for (j = 0 ; j &lt; c.m ; j ++)
            c.data[i][j] = (a.data[i][j] - b.data[i][j]) % mod;
    return 1;
}


void mat::operator =(const mat&amp; a)
{
    n = a.n;
    m = a.m;
    for(int i = 0 ; i &lt; n ; i ++)
        for(int j = 0 ; j &lt; m ; j ++)
            data[i][j] = a.data[i][j];
}
mat mat::operator +(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] + a.data[i][j];
    return tmpMat;
}
mat mat::operator -(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] - a.data[i][j];
    return tmpMat;
}
mat mat::operator &amp;(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] &amp; a.data[i][j];
    return tmpMat;
}
mat mat::operator |(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] | a.data[i][j];
    return tmpMat;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/76.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-15T16:39:11.000+00:00 itemprop=datePublished>2009-09-15</time></div></div></article><article class="article-panel archive-article archive-type-77"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/77.html target=_blank itemprop=url>09年8月14日 ECUST ACM 练习赛总结</a></h1></header><div class=article-summary><p>今天在湖南的OJ上做题,发现不到两小时,他服务器就挂了,但是发现他和POJ上的一些题一样而且是连号的,就到POJ上继续了，我们队出了6题。</p><p>A题是<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3507">POJ的3507 Judging Olympia</a>这题是队友干掉的,我没看</p></div><div class=article-more><a href=//owent.net/2009/77.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-16T16:57:22.000+00:00 itemprop=datePublished>2009-08-16</time></div></div></article><article class="article-panel archive-article archive-type-78"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/78.html target=_blank itemprop=url>ECUST 09年 校赛个人赛第八场（最后一场）总结</a></h1></header><div class=article-summary><p>懒惰了，暂时休息一下</p><p>这次我只AC了一题（在结束的那一刻，另一题在题目来源地网站上AC了，我们的OJ上仍然WA，我们OJ的Special Judge真是—_—!）</p></div><div class=article-more><a href=//owent.net/2009/78.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:41:45.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-79"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/79.html target=_blank itemprop=url>ECUST 09年 校赛个人训练赛第五场总结</a></h1></header><div class=article-summary><h1 id=校赛个人训练赛第五场报告>校赛个人训练赛第五场报告</h1><p>今天战绩还行，AC了5题，今天总体没有太复杂的算法题，不过测试数据强度比之前有所增加
我的钱四题很早就过了，但是第五题很晚才出主要是代码写得太混乱，思路也错了两次
我过的题有五道，分别是ABCDG</p></div><div class=article-more><a href=//owent.net/2009/79.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:40:56.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-80"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/80.html target=_blank itemprop=url>点到直线距离 和 线段间最短距离 (OWenT 模板)</a></h1></header><div class=article-summary><p>点到直线距离</p><pre><code class=language-cpp>// (x0,y0)到(x1,y1)和(x2,y2)确定的直线的距离

double disBetweenPointAndLine(double x0,double y0,double x1,double y1,double x2,double y2)
{
    //化为ax+by+c=0的形式
    double a = y1-y2;
    double b = x2-x1;
    double c = x1*y2-x2*y1;
    double d = (a*x0+b*y0+c)/sqrt(a*a+b*b);
    /*
    如果是线段判断垂足

    double xp = (b*b*x0-a*b*y0-a*c)/(a*a+b*b);
    double yp = (-a*b*x0+a*a*y0-b*c)/(a*a+b*b);
    double xb = (x1&gt;x2)?x1:x2;
    double yb = (y1&gt;y2)?y1:y2;
    double xs = x1+x2-xb;
    double ys = y1+y2-yb;
    if(xp &gt; xb || xp &lt; xs || yp &gt; yb || yp &lt; ys)
    {
        d = sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
        if(d &gt; sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2)))
            d = sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2));
    }
    */
    return fabs(d);
}
</code></pre><p>线段间最短距离</p></div><div class=article-more><a href=//owent.net/2009/80.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:33:38.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-81"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/81.html target=_blank itemprop=url>连接最多点直线 (OWenT 个人模板)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//n每个用例的点个数
//MAXN为最大点个数
//PTYPE为坐标值类型
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;

#define MAXN 1005
#define EPS 1e-10
typedef double PTYPE;

struct point
{
    PTYPE x,y;
};
struct node
{
    PTYPE k;
};
int cmp(const void * a, const void * b)
{
    return((*(PTYPE*)a-*(PTYPE*)b&gt;0)?1:-1);
}
node numK[MAXN * MAXN / 2];
point pt[MAXN];
int main()
{

    int n , maxNum = 1 , tmpNum = 0;
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {
        for(int i = 0 ; i &lt; n ; i ++)
            scanf(&quot;%lf %lf&quot;,&amp;pt[i].x,&amp;pt[i].y);
        for(int i = 0 ; i &lt;  n ; i ++)
        {
            int pos = 0;
            for(int j = i + 1 ; j &lt; n ; j ++)
                if((pt[i].x - pt[j].x) &gt; EPS)
                    numK[pos ++].k = (pt[j].y - pt[i].y) / (pt[j].x - pt[i].x);
                else
                    numK[pos ++].k = 100000;

            qsort(numK,pos,sizeof(numK[0]),cmp);
            int tmpNum = 2;
            for(int j = 1 ; j &lt; pos ; j ++)
            {
                if(numK[j].k == numK[j - 1].k)
                    tmpNum ++;
                else
                {
                    if(tmpNum &gt; maxNum)
                        maxNum = tmpNum;
                    tmpNum = 2;
                }
            }
            if(tmpNum &gt; maxNum)
                maxNum = tmpNum;
        }


        printf(&quot;%d\n&quot;,maxNum);
        maxNum = 1;
    }
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/81.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:30:49.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-82"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/82.html target=_blank itemprop=url>09年8月9日 ECUST ACM 练习赛总结</a></h1></header><div class=article-summary><h2 id=problem-a><a href="http://acm.hdu.edu.cn/diy/contest_showproblem.php?pid=1001&amp;cid=3627&amp;hide=1&amp;problem=Problem%20%20A">Problem A</a></h2><p>我没看题,队友很快AC我就没花时间看</p><h2 id=problem-b><a href="http://acm.hdu.edu.cn/diy/contest_showproblem.php?pid=1002&amp;cid=3627&amp;hide=1&amp;problem=Problem%20%20B">Problem B</a></h2><p>DP题,但是我们确实都没想到方法,实在是我们的经验不足</p><p>B题补充:
B题的DP方法比较诡异(起码我理解了很久)
令fn[i][j]为有i个数j次交换位置的排列数量
很明显,当i+1时,如果把新增的数放在最后一位,那么交换次数不变(新增的数为i+1,最大).
如果把新增的数放在第1到i位之间的话有i种放法,
对于每一种fn[i][j]的排列中我们总能找到一种序列使得{(.)(.)(<em>)(.)(.)…(i+1)},["()表示一个元素"]
中(i+1)和(</em>)交换位置后前i个元素的排列和其相同
又因为(*)的位置可以有i种放法,以此我们发现,fn[i+1][j]=fn[i][j]+fn[i][j-1]×i
继续贴代码:</p></div><div class=article-more><a href=//owent.net/2009/82.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-10T16:14:16.000+00:00 itemprop=datePublished>2009-08-10</time></div></div></article><article class="article-panel archive-article archive-type-83"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/83.html target=_blank itemprop=url>牛顿迭代解方程 ax^3+bX^2+cx+d=0</a></h1></header><div class=article-summary><p>$$ ax^3+bX^2+cx+d=0 $$</p><p>根的关系:</p><p>$$ x1 + x2 + x3 = (-\frac{b}{a}) $$</p><p>$$ x1 \times x2 + x1 \times x3 + x2 \times x3 = \frac{c}{a} $$</p><p>$$ x1 \times x2 \times x3 = (-\frac{d}{a}) $$</p><p>牛顿迭代解方程(x0附近的根)</p><pre><code class=language-cpp>double Newton_Iterative(double a,double b,double c,double d,double x0)
{
    double f0,f0d,x;
    x = x0;
    do
    {
        x0 = x;
        f0 = ((a * x + b) * x + c) * x + d;
        f0d = ( 3 * a * x + 2 * b ) * x + c;
        x = x0 - f0 / f0d;
    }
    while(fabs(f0) &gt;= 1e-12);
    return x;
}
</code></pre><p>牛顿迭代法</p></div><div class=article-more><a href=//owent.net/2009/83.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-05T16:27:32.000+00:00 itemprop=datePublished>2009-08-05</time></div></div></article><article class="article-panel archive-article archive-type-84"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/84.html target=_blank itemprop=url>ECUST 09年 校赛个人赛第三场部分解题报告(A,D,F,I)</a></h1></header><div class=article-summary><p>校赛个人赛第三场部分解题报告（A,D,F,I）</p><p>这次我完成了四道题分别是A,D,F,I</p><p>一大半时间我都花在了A上，我犯了很究级的错误</p><p>首先是VC6.0的algorithm里没有min函数，而我用min做变量名导致CE4次，找了半天才找出来</p></div><div class=article-more><a href=//owent.net/2009/84.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-07-30T09:58:51.000+00:00 itemprop=datePublished>2009-07-30</time></div></div></article><article class="article-panel archive-article archive-type-85"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/85.html target=_blank itemprop=url>ECUST 09年 校赛个人赛第六，七场总结</a></h1></header><div class=article-summary><p>校赛个人赛第六，七场总结</p><p>这两场比赛体现了英文水平的重要性</p><p>第六场的题目超长，用词还诡异，话了很长时间才看懂</p><p>这两场题目都比较有难度，第六场我只出了2题</p><h2 id=a-grey-area>A Grey Area</h2><p>A题是很诡异的统计，是一道纯模拟就能过的题，其他的不多说了</p></div><div class=article-more><a href=//owent.net/2009/85.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-07-30T09:58:00.000+00:00 itemprop=datePublished>2009-07-30</time></div></div></article><article class="article-panel archive-article archive-type-87"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/87.html target=_blank itemprop=url>打造最快的Hash表(转) [以暴雪的游戏的Hash为例]</a></h1></header><div class=article-summary><p>先提一个简单的问题，如果有一个庞大的字符串数组，然后给你一个单独的字符串，让你从这个数组中查找是否有这个字符串并找到它，你会怎么做？</p><p>有一个方法最简单，老老实实从头查到尾，一个一个比较，直到找到为止，我想只要学过程序设计的人都能把这样一个程序作出来，但要是有程序员把这样的程序交给用户，我只能用无语来评价，或许它真的能工作，但…也只能如此了。</p></div><div class=article-more><a href=//owent.net/2009/87.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-07-22T12:41:44.000+00:00 itemprop=datePublished>2009-07-22</time></div></div></article><article class="article-panel archive-article archive-type-88"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/88.html target=_blank itemprop=url>POJ 2606 Rabbit hunt 2780 Linearity 1118 Lining Up 解题报告</a></h1></header><div class=article-summary><p>POJ打破传统,以前是做一题送一题,现在是做一题送两题,那么我们就不用客气了</p><p>言归正传 题号:<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2606">2606 Rabbit hunt</a> <a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2780">2780 Linearity</a> <a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1118">1118 Lining Up</a></p><p>大致题意是输入N个点.计算能穿过最多的点的直线,并输出最大点的个数</p></div><div class=article-more><a href=//owent.net/2009/88.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-07-20T14:50:15.000+00:00 itemprop=datePublished>2009-07-20</time></div></div></article></div><hr><nav id=page-nav><ul class=pagination><li class=page-item><a class=page-link href=/page/11.html>&#171;上一页</a></li><li class=page-item><a class=page-link href=/>1</a></li><li class=page-item><a class=page-link href=/page/2.html>2</a></li><li class=page-item><a class=page-link href=/page/3.html>3</a></li><li class=page-item><a class=page-link href=/page/4.html>4</a></li><li class=page-item><a class=page-link href=/page/5.html>5</a></li><li class=page-item><a class=page-link href=/page/6.html>6</a></li><li class=page-item><a class=page-link href=/page/7.html>7</a></li><li class=page-item><a class=page-link href=/page/8.html>8</a></li><li class=page-item><a class=page-link href=/page/9.html>9</a></li><li class=page-item><a class=page-link href=/page/10.html>10</a></li><li class=page-item><a class=page-link href=/page/11.html>11</a></li><li class='page-item disabled'><a class=page-link href=/page/12.html>12</a><span class=sr-only>(current)</span></li><li class=page-item><a class=page-link href=/page/13.html>13</a></li><li class=page-item><a class=page-link href=/page/13.html>下一页&#187;</a></li></ul></nav></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>2025&nbsp;OWenT
</strong><strong id=footer-right class="float-right float-end"><a href=https://beian.miit.gov.cn/ target=_blank>沪ICP备2022003252号</a>&nbsp;&nbsp;<a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=module>// import * as Popper from "@popperjs/core";// import * as bootstrap from "bootstrap";
// import React from "react";

        
</script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/katex@latest/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
import mermaid from "mermaid";
const config = {
    theme: 'neutral',
    logLevel: 'fatal',
    securityLevel: 'loose', 
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    

};
mermaid.initialize(config);
</script><script type=text/javascript>var _hmt=_hmt||[];(function(){var t,n,e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6a0daf8d58889f1cf55a353867bfdbb0",t=document.getElementsByTagName("script"),n=document.getElementsByTagName("script")[t.length-1],n.parentNode.appendChild(e)})()</script></div></body></html>