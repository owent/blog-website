<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><title>I'm OWenT|I'm OWenT</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/index.html><link rel=alternate type=application/rss+xml href=//owent.net/index.xml title="I'm OWenT"><link rel=icon href=/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script type=importmap>
{
  "imports": {
    "react": "https://cdn.jsdelivr.net/npm/react/&#43;esm",
    "react-bootstrap": "https://cdn.jsdelivr.net/npm/react-bootstrap/&#43;esm",
    "mermaid": "https://cdn.jsdelivr.net/npm/mermaid/&#43;esm",
    "bootstrap": "https://cdn.jsdelivr.net/npm/bootstrap/&#43;esm",
    "@popperjs/core": "https://cdn.jsdelivr.net/npm/popper.js/&#43;esm"
  }
}
</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta content="codeva-4M5iohb9TW" name=baidu-site-verification></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/index.html title=Home>Home</a></li><li class=nav-item><a class=nav-link href=/archives/index.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=/about/index.html title=About>About</a></li><li class=nav-item><a id=nav-rss-link class=nav-link href=//owent.net/index.xml title=RSS订阅>RSS订阅</a></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=index-content><article class="article-panel archive-article archive-type-1901"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2019/1901.html target=_blank itemprop=url>Rust玩具-企业微信机器人通用服务</a></h1></header><div class=article-summary><h2 id=新玩具-企业微信机器人>新玩具-企业微信机器人</h2><p>这个机器人其实蛮久前就做好了，现在才写了点分享出来。 最近企业微信不断地开放了机器人的接口，所以我想想拿来做一些开发工具集成也是挺不错的，顺便也是为了继续熟悉一下 <a href=https://rust-lang.org/>Rust</a> 的编程习惯。 那么这次就大量使用 <a href=https://crates.io/crates/futures>futures</a> 来实现这个机器人的接口服务，这也是即将到来的无栈协程语法糖 <a href=https://crates.io/crates/futures-await>await</a> 的基石。</p></div><div class=article-more><a href=//owent.net/2019/1901.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2019-01-03T17:08:50.000+00:00 itemprop=datePublished>2019-01-03</time></div></div></article><article class="article-panel archive-article archive-type-1812"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1812.html target=_blank itemprop=url>使用ELK辅助监控开发测试环境服务质量和问题定位</a></h1></header><div class=article-summary><h2 id=什么是elk>什么是ELK？</h2><p>ELK 是 <a href=https://www.elastic.co/cn/products/elasticsearch>elasticsearch</a> + <a href=https://www.elastic.co/cn/products/logstash>logstash</a> + <a href=https://www.elastic.co/cn/products/kibana>kibana</a>的缩写。这一套是现在比较流行的日志全文索引系统了。我之前的项目也有用它来做过日志分析，这次主要是拿来搭建开发测试环境的监控和分析系统，顺带记录一下部署脚本和流程。</p><p>其中 <a href=https://www.elastic.co/cn/products/elasticsearch>elasticsearch</a> 是日志索引系统，我按两个master，3个数据和处理节点来部署。 <a href=https://www.elastic.co/cn/products/logstash>logstash</a> 和 <a href=https://www.elastic.co/cn/products/kibana>kibana</a> 因为是开发测试环境使用，量级不大，所以只部署了一个节点。但是在使用过程中发现 <a href=https://www.elastic.co/cn/products/elasticsearch>elasticsearch</a> 在jre的GC的时候还是有较长时间的 <em><strong>Stop The World</strong></em> 的问题，而且这期间的数据会倍丢弃。所以为了缓解这个状况，又引入了 <a href=https://redis.io/>redis</a> 作为消息队列使用。然后使用两组pipeline，一个从 client -> <a href=https://www.elastic.co/cn/products/logstash>logstash</a> -> <a href=https://redis.io/>redis</a> ，另一个从 <a href=https://redis.io/>redis</a> -> <a href=https://www.elastic.co/cn/products/logstash>logstash</a> -> <a href=https://www.elastic.co/cn/products/elasticsearch>elasticsearch</a> 来传输。这样如果在 <a href=https://www.elastic.co/cn/products/elasticsearch>elasticsearch</a> GC的 <em><strong>Stop The World</strong></em> 结束的时候会把数据补回去。 外面更大型的部署也有用 <a href=https://kafka.apache.org/>kafka</a> 或者更进一步优化的 <a href=https://pulsar.apache.org/>pulsar</a>。不过我们目前的应用也不太需要 <a href=https://kafka.apache.org/>kafka</a> 和 <a href=https://pulsar.apache.org/>pulsar</a> 那种数据落地和强一致性，使用 <a href=https://redis.io/>redis</a> 也已经够了。</p></div><div class=article-more><a href=//owent.net/2018/1812.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-11-17T02:00:00.000+00:00 itemprop=datePublished>2018-11-17</time></div></div></article><article class="article-panel archive-article archive-type-1810"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1810.html target=_blank itemprop=url>2018年的新通用伪随机数算法(xoshiro / xoroshiro)的C++(head only)实现</a></h1></header><div class=article-summary><p>前段时间看到说<a href=https://github.com/lua/lua/blob/f59e6a93c0ad38a27a420e51abf8f13d962446b5/lmathlib.c#L571>Lua 5.4</a>用了一种新的通用随机数算法，替换掉本来内部使用的CRT的随机数引擎。我看了一下大致的实现，CPU和空间复杂度任然保持了一个较低的水平，并且循环节和说是随机性都还不错。我们游戏项目中原本对大量随机数场景的随机数算法使用的是基于线性同余的TAUS88，但是使用过程中发现这个算法分布上还是有一些不是很理想，所以就想把这个新的科研成果也用进我们项目中试试看效果。</p></div><div class=article-more><a href=//owent.net/2018/1810.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-10-18T13:43:31.000+00:00 itemprop=datePublished>2018-10-18</time></div></div></article><article class="article-panel archive-article archive-type-1811"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1811.html target=_blank itemprop=url>Webpack+vue+boostrap+ejs构建Web版GM工具</a></h1></header><div class=article-summary><h2 id=前言>前言</h2><p>Web前端的组件技术刷新真的是日新月异，前段时间看到很多童鞋分享了<a href=https://webpack.js.org/>webpack</a>的使用，刚好之前做我们游戏里Web版的GM工具的时候正在想怎么用简单的方式，做模块分离并且又不需要引入重量级的第三方库或组件，也不需要太繁琐的流程（毕竟只是个小工具）。</p><p>我们的Web版GM工具长差不多这个样子，全静态页面。</p><p><img src=1811-01.png alt=1811-01.png></p><p><img src=1811-02.png alt=1811-02.png></p><p>因为分成了好几个模块，然后由于用的是bootstrap的。上面的Tab和下面的内容还有处理逻辑的函数都分了三大块，在不同的位置。在内容持续增加以后，全都写在一个html里太不方便了，而如果走ajax加载，调试和本地编辑都挺麻烦。</p></div><div class=article-more><a href=//owent.net/2018/1811.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-10-16T17:10:50.000+00:00 itemprop=datePublished>2018-10-16</time></div></div></article><article class="article-panel archive-article archive-type-1809"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1809.html target=_blank itemprop=url>Rust的第二次接触-写个小服务器程序</a></h1></header><div class=article-summary><h2 id=just-practice>JUST PRACTICE</h2><p>蛮久前入门了一下 <a href=https://rust-lang.org/>Rust</a> 语言。它的设计模型非常地吸引C/C++的开发者。但是学习语言嘛还是要练习一下，之前也用它给我们项目写了个命令行小工具。这回拿来写个小型的服务器程序吧。</p></div><div class=article-more><a href=//owent.net/2018/1809.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-09-12T12:29:50.000+00:00 itemprop=datePublished>2018-09-12</time></div></div></article><article class="article-panel archive-article archive-type-1808"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1808.html target=_blank itemprop=url>理解和适配AEAD加密套件</a></h1></header><div class=article-summary><h2 id=什么是aead>什么是AEAD</h2><p>按照维基百科的说法。AEAD的全称是Authenticated encryption (AE) and authenticated encryption with associated data (AEAD, variant of AE)。也就是带附加数据的加密和验证算法。</p><p>我们很多涉及IO的系统收发数据的时候一般会加上一些校验码，以便检测IO错误。而对外的socket里，这个校验码还有一个功能是挡掉一些不正常的数据。如果这时候如果我们的数据需要带上加密的话，那就是AE了。然后AEAD就是在AE的基础上，增加一些自定义数据，用于防止猜解。</p></div><div class=article-more><a href=//owent.net/2018/1808.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-07-01T20:49:50.000+00:00 itemprop=datePublished>2018-07-01</time></div></div></article><article class="article-panel archive-article archive-type-1807"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1807.html target=_blank itemprop=url>atsf4g-co的进化：协程框架v2、对象路由系统和一些其他细节优化</a></h1></header><div class=article-summary><h1 id=前言>前言</h1><p>年前就计划把以前项目的一些理念和设计方案融合到sample里来。但是内容比较多，一直也没太多时间去完成它。所幸虽然断断续续但终归是完成了。并且在之前的一些实现上还做了一些细节的优化。内容比较多我感觉我自己写的也比较乱，仅当作一个参照和小计吧。</p></div><div class=article-more><a href=//owent.net/2018/1807.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-06-22T23:22:15.000+00:00 itemprop=datePublished>2018-06-22</time></div></div></article><article class="article-panel archive-article archive-type-1806"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1806.html target=_blank itemprop=url>协程框架(libcopp)v2优化、自适应栈池和同类库的Benchmark对比</a></h1></header><div class=article-summary><h1 id=协程系统优化>协程系统优化</h1><p><a href=https://github.com/owent/libcopp>libcopp</a>很早就实现完成了v2版本，现在迁移进<a href=https://github.com/atframework/atsf4g-co/tree/sample_solution>atsf4g-co/tree/sample_solution</a>以后也把v2分支正式并入了主干。原来的版本切出到v1分支并且停止维护了。</p><h2 id=libcopp-v2内存布局>libcopp v2内存布局</h2><p>开发<a href=https://github.com/owent/libcopp>libcopp</a> v2版本的最大目的是优化allocator的接口和内存碎片。</p><p>原来的allocator虽然是可定制的，但是是内置的。每次创建一个allocator对象，不同allocator之间共享数据只能通过全局数据或者TLS数据。现在则可以传入allocator了。这也是为后续的共享栈池做准备。</p></div><div class=article-more><a href=//owent.net/2018/1806.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-05-28T20:23:31.000+00:00 itemprop=datePublished>2018-05-28</time></div></div></article><article class="article-panel archive-article archive-type-1805"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1805.html target=_blank itemprop=url>可执行文件压缩</a></h1></header><div class=article-summary><h1 id=前言>前言</h1><p>最近看<a href=https://rust-lang.org/>Rust</a>相关东西的时候看到一篇关于压缩可执行文件的文章。压缩可执行文件对嵌入式开发特别有用，但是延伸一下用来减少我们游戏行业里预编译的工具二进制包大小和Android/iOS的库也是蛮有用的。</p><p>原文见这里： <a href=https://jamesmunns.com/blog/tinyrocket/>https://jamesmunns.com/blog/tinyrocket/</a></p><h1 id=基本流程>基本流程</h1><ol><li>Release编译，移除调试符号文件，开启最小化size优化(-Oz)</li><li>使用LLVM的全量LTO</li><li>使用xargo重新编译标准库(std)和核心库(core)（这个C/C++不容易模仿，而且编译选项十分难搞）</li><li>移除<a href=https://github.com/jemalloc/jemalloc>jemalloc</a>（服务器程序还是留着比较好，内置的malloc实现一般碎片比较厉害。虽然C/C++默认也不是<a href=https://github.com/jemalloc/jemalloc>jemalloc</a>，很多项目为了新能还是会用它）</li><li>移除panic的详情信息（这个仅适用于<a href=https://rust-lang.org/>Rust</a>）</li><li>strip（由GNU的<a href=https://www.gnu.org/software/binutils/>binutils</a>提供），参考命令: <code>strip [二进制]</code></li><li><a href=https://upx.github.io/>UPX</a>进一步压缩加壳</li></ol><h1 id=尝试改造优化>尝试改造优化</h1><p>然后尝试使用上面的流程改造我们的 <strong>gmtools-cli</strong> 。原先我是直接开LTO+Release编译的，编出的文件大小为4.4MB（4520728字节）。</p></div><div class=article-more><a href=//owent.net/2018/1805.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-04-24T10:58:05.000+00:00 itemprop=datePublished>2018-04-24</time></div></div></article><article class="article-panel archive-article archive-type-1804"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1804.html target=_blank itemprop=url>初识Rust</a></h1></header><div class=article-summary><h1 id=前言>前言</h1><p>虽然我主要使用C++，但是最近也想学点现代化的新语言。初步想的是从<a href=https://golang.org/>golang</a>和<a href=https://rust-lang.org/>Rust</a>里先选一个。</p><p>这两年<a href=https://golang.org/>golang</a>在国内很火，最大的特点莫过于语言层面提供了协程支持，能够极大地简化异步逻辑地理解。我之前也接触过一点，还写了个<a href=https://gist.github.com/owent/2286768f2586521600c9fd1700cbf845>goroutine压力测试</a>对比我的<a href=https://github.com/owent/libcopp>libcopp</a>的性能。但是<a href=https://golang.org/>golang</a>的语法我实在不喜欢，特别是那个不管啥类型声明都是反着来，感觉在复杂的类型下会非常反人类。而且听用过的人说<a href=https://golang.org/>golang</a>的GC还很不稳定。另外之前有新闻说<a href=https://golang.org/>golang</a>正在准备2.0，2.0版本即将加入泛型支持，然后导致很多语法不兼容和语法分析得重写。所以我还是懒得踩这个坑了，至少等2.0出来再说。</p><p><a href=https://rust-lang.org/>Rust</a>是Mozilla搞出来想拿来重写Firefox的。说实话Mozilla和Google还有点差距，导致<a href=https://rust-lang.org/>Rust</a>的发展还比较慢。对比起来就是感觉<a href=https://golang.org/>golang</a>很快就提供了一些快速可用的原型给大型项目使用，标准库也足够丰富。而<a href=https://rust-lang.org/>Rust</a>还纠结在底层、语言层面的优化和最求极致。很多组件都还不成熟，编程设计模型也还没完全统一。</p><p>但是接触了一点<a href=https://rust-lang.org/>Rust</a>以后，我发现<a href=https://rust-lang.org/>Rust</a>真的是挠到了C++程序员的痒点，语言层面解决了用C++得费很多脑力和用各种奇技淫巧实现并且还不能完全阻止被绕过的质量控制问题，而且保留了C++很多编译期推断得高级特性。并且和C++一样，提供给你能力，但不限定你方法提供 <strong>零成本抽象（zero-cost abstractions）</strong> 或者说叫 <strong>零开销（zero-overhead）</strong>。</p></div><div class=article-more><a href=//owent.net/2018/1804.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-04-23T21:54:50.000+00:00 itemprop=datePublished>2018-04-23</time></div></div></article><article class="article-panel archive-article archive-type-1803"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1803.html target=_blank itemprop=url>使用restructedtext编写xresloader文档</a></h1></header><div class=article-summary><p>离上一次写Blog过了好久啦。这次拖这么长时间主要是因为最近学习了一个新的文本标记语言 &ndash; <a href=https://en.wikipedia.org/wiki/ReStructuredText>ReStructuredText</a> 。并且重新整理了<a href=https://github.com/xresloader/>Excel导表工具-xresloader工具集</a>的文档，写文档真是好废好废时间啊。</p><p>好多项目用<a href=https://en.wikipedia.org/wiki/ReStructuredText>ReStructuredText</a>来写文档来着，比如<a href=https://cmake.org/>cmake</a>，再比如<a href=https://www.python.org/>python</a>。然后现在有比较容易上手的<a href=https://readthedocs.com/>readthedocs</a>来托管文档，和<a href=https://github.com/>github</a>的集成也还不错。所以我打算把一些项目的文档也迁移上去。毕竟 <strong>README.md</strong> 还是弱了些。</p><p>其实<a href=https://en.wikipedia.org/wiki/ReStructuredText>ReStructuredText</a>也支持 <strong>Markdown</strong> 。但是使用 <strong>Markdown</strong> 写文档还是略麻烦，特别是涉及跨文档引用和多行表格的时候，而且 <strong>Markdown</strong> 各个平台的组件和扩展还都不一样，没有统一标准。在这些方面<a href=https://en.wikipedia.org/wiki/ReStructuredText>ReStructuredText</a>就强大多了。不过这也是有代价的，那就是<a href=https://en.wikipedia.org/wiki/ReStructuredText>ReStructuredText</a>的语法规则比 <strong>Markdown</strong> 复杂得多。</p></div><div class=article-more><a href=//owent.net/2018/1803.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-04-03T17:22:42.000+00:00 itemprop=datePublished>2018-04-03</time></div></div></article><article class="article-panel archive-article archive-type-1802"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1802.html target=_blank itemprop=url>atframework的etcd模块化重构</a></h1></header><div class=article-summary><h2 id=前言>前言</h2><p>最近在抽时间整理之气的游戏服务器框架和解决方案里<a href=https://github.com/atframework/atsf4g-co>atsf4g-co</a>，现在的架构是使用<a href=https://coreos.com/etcd>etcd</a>的是<a href=https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atproxy>atproxy</a>。简单得说就是服务集群是分组的，每个分组有分组代理服务<a href=https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atproxy>atproxy</a>做组间通信。然后<a href=https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atproxy>atproxy</a>之间使用<a href=https://coreos.com/etcd>etcd</a>来做分组服务的服务发现和保活，并且以此来实现平行扩容。</p><p>之前做服务间通信组件<a href=https://github.com/atframework/libatbus>libatbus</a>的时候也提到了有一个暂时没实现的功能，就是全局路由表的自动通知。但是这个功能的实现主要也是用于后面不同种服务间感知到哪些节点是可用的，哪些是不可用的。而且我的简单实现必然是走心跳的模式，因为心跳的形式肯定不能把心跳设置得太短，同时也要考虑网络异常抖动和断线重连和丢包，所以肯定不是丢一个心跳包就认为丢失。所以故障或者扩缩容期间的感知时间就会比较长一些。另外就是因为可能有网络孤岛问题，所以可能短期内数据不一致（当然肯定会保证最终一致性）。</p><p>再加上由于<a href=https://github.com/atframework/libatbus>libatbus</a>是支持多级父子节点关系的，所以变化通知和同步包就要考虑自己与父节点、兄弟节点、自己与子节点的不同关系并作不同的同步流向，会比较复杂。比如：子节点下线，既要通知父节点，又要通知兄弟节点。那么这时候给兄弟节点通知就有两个通路，一个是经由父节点中转，另一种是直接发。当然这时候并不一定和兄弟节点有直接通路。所以可能兄弟节点会收到两次通知，一次来自兄弟节点，另一次来自公共父节点。然后又会有其他问题，就是万一又收到一条冲突的消息，来自父节点和来自兄弟节点的顺序是没有保证的，这里又得加入版本机制。总的来说，细节会比较复杂，具体在实现<a href=https://github.com/atframework/libatbus>libatbus</a>的这个功能的时候在谈吧。</p><p>上面说的<a href=https://github.com/atframework/libatbus>libatbus</a>的功能暂时没实现的最重要原因是<a href=https://coreos.com/etcd>etcd</a>可以比较完美的解决上面的延迟问题和不一致问题。缺点就是请求的消耗会高于使用<a href=https://github.com/atframework/libatbus>libatbus</a>的通信机制。不过这玩意本身不是高频操作，而且故障和容灾本身不是一个频发的事情所以关系不大。而之前<a href=https://coreos.com/etcd>etcd</a>的接入是直接写死在<a href=https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atproxy>atproxy</a>里的，那么这次重构的目的主要就是能够抽象出模块化的工具，以便后面不同的服务可以根据需要取用。</p><h2 id=统一管理驱动管理器和模块化>统一管理驱动管理器和模块化</h2><p>按现在的功能划分，<a href=https://coreos.com/etcd>etcd</a>的接入总共被分为3个模块，etcd_cluster、etcd_keepalive和etcd_watcher以及一个通用工具etcd_packer。etcd_packer用于对<a href=https://coreos.com/etcd>etcd</a>的一些通用的打解包操作。</p><p><img src=1802-01.png alt=模块关系图></p><h3 id=etcd_cluster>etcd_cluster</h3><p><a href=https://coreos.com/etcd>etcd</a> v3版本内部的通信已经使用了grpc。本来我是想等他的grpc接口进入官方文档并且提供出的grpc的proto再接入的，可是它一直没有整理出直接grpc的proto文件列表。另外我看了一下它的proto文件里用到了一些<a href=https://github.com/gogo/protobuf>gogoprotobuf</a>的扩展，其他语言不一定可以无缝接入。考虑到etcd使用了<a href=https://github.com/grpc-ecosystem/grpc-gateway>grpc-gateway</a>提供HTTP+JSON的网关层，所以我还是基于他的HTTP接入层来做。因为这里身频次不高，也没有那么在意性能。而且一组<a href=https://coreos.com/etcd>etcd</a>服务的QPS也就在十万的级别，只要管理好连接，不要老新建立和关闭连接，HTTP的性能还是够的。</p></div><div class=article-more><a href=//owent.net/2018/1802.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-02-20T22:43:00.000+00:00 itemprop=datePublished>2018-02-20</time></div></div></article><article class="article-panel archive-article archive-type-1801"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2018/1801.html target=_blank itemprop=url>C++的backtrace</a></h1></header><div class=article-summary><h1 id=开始之前>开始之前</h1><p>很多语言的log模块都有一个功能，就是在打log的时候能够追溯调用栈，有的时候对查bug能有点帮助。之前我也想过给我们的log模块加上C++的backtrace的功能，迟迟一直没有做主要是两个原因：一是C++的backtrace在各个平台和编译器上都不太一样，比较冗杂；二是C/C++在编译优化之后，调用行之类的信息和甚至一些函数可能就被优化没了。所以能提供的信息就相当有限。前两天刚好有朋友问有没有提供这个，所以就花了点时间整理了下适配方案。</p></div><div class=article-more><a href=//owent.net/2018/1801.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2018-01-08T17:55:00.000+00:00 itemprop=datePublished>2018-01-08</time></div></div></article><article class="article-panel archive-article archive-type-1472"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1472.html target=_blank itemprop=url>ECDH椭圆双曲线（比DH快10倍的密钥交换）算法简介和封装</a></h1></header><div class=article-summary><p>前面有几篇blog就提到我有计划支持使用ECDH密钥交换。近期也是抽空把以前的DH密钥交换跨平台适配从<a href=https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atgateway>atgateway</a>抽离出来，而后接入了<a href=https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman>ECDH</a>流程。</p><h2 id=背景>背景</h2><p>对<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>DH</a>和<a href=https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman>ECDH</a>算法的具体原理这里不做具体介绍了，可以点击链接看。<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>DH</a>和<a href=https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman>ECDH</a>的主要的作用就是在通信双方发送一些公有参数，保留私有参数，而后通过一系列计算双方都能够得到一个一致的结果。而这个运算的逆运算复杂度过高，在有限时间内不可解（至少量子计算机问世以前不可解），以保证密钥安全性。除了维基百科外，我还看到篇文章图画的很好看的：http://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/ 。而<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>DH</a>和<a href=https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman>ECDH</a>得区别简单来说就是，前者使用了一个大素数和两个随机数，而后者使用了<a href=https://en.wikipedia.org/wiki/Elliptic-curve_cryptography>ECC</a>算法和两个随机点。</p><p>实际应用中，有些加密算法的密钥碰撞计算难度反而比破解<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>DH</a>和<a href=https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman>ECDH</a>要容易（比如<a href=https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atgateway>atgateway</a>支持的<a href=https://en.wikipedia.org/wiki/XXTEA>XXTEA</a>算法，这个算法很简单所以也非常高效）。所以有些工程实践中会每隔一段时间再走一次密钥交换流程来更换密钥。</p></div><div class=article-more><a href=//owent.net/2017/1472.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-11-10T13:30:00.000+00:00 itemprop=datePublished>2017-11-10</time></div></div></article><article class="article-panel archive-article archive-type-1471"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1471.html target=_blank itemprop=url>protobuf-net的动态Message实现</a></h1></header><div class=article-summary><p>这本来是个早就可以写的分享。因为代码几周前就迁移并准备好了。而且这也是之前项目的工具，因为可以抽离出来通用化所以单独整理出来。</p><p>这个项目起源于我们之前哪个项目，客户端想要在Unity的C#里动态加载配置，而<a href=https://github.com/mgravell/protobuf-net>protobuf-net</a>一方面大量使用反射而性能不太行，另一方面使用的时候得生成C#代码才行。客户端原来的做法是把消息扁平化了，使用<a href=https://github.com/mgravell/protobuf-net>protobuf-net</a>得底层读写接口直接操作基本数据类型。这就失去了结构化带来的一系列好处。再加上后来我引入了跨平台导表工具，使用结构化得数据会非常方便，而手动把这个数据打散到客户端读取接口显然很浪费人力而且容易出错。所以我就干脆也使用<a href=https://github.com/mgravell/protobuf-net>protobuf-net</a>的底层读写接口做了现在的<a href=https://github.com/xresloader/DynamicMessage-net>DynamicMessage</a>的支持，API设计是结合<a href=https://github.com/cloudwu/pbc>pbc</a>和protobuf官方的API流程的。</p></div><div class=article-more><a href=//owent.net/2017/1471.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-10-31T17:57:00.000+00:00 itemprop=datePublished>2017-10-31</time></div></div></article><article class="article-panel archive-article archive-type-1470"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1470.html target=_blank itemprop=url>pbc的proto3接入</a></h1></header><div class=article-summary><p><a href=https://github.com/google/protobuf>Protobuf</a> 的 proto3发布也有挺长一段时间了。现在很多新项目慢慢转变用proto3来开发。这篇文章主要记录一下我在给<a href=https://github.com/cloudwu/pbc>pbc</a>写对proto3支持时的一些信息，也许对其他童鞋也有点助益。抛砖引玉一下。</p><h2 id=简介>简介</h2><p><a href=https://github.com/cloudwu/pbc>pbc</a>是<a href=https://github.com/cloudwu>云风</a>开发的一个纯C的读写<a href=https://github.com/google/protobuf>protobuf</a>的很小巧的库，配合上它提供的lua-5.1和lua-5.3的binding可以很容易地在lua里完成对pb文件的注册和打解包。应该很多人都知道这个组件。</p><p>但是后来<a href=https://github.com/cloudwu>云风</a>自己又发明了个<a href=https://github.com/cloudwu/sproto>sproto</a>，然后主推在他的<a href=https://github.com/cloudwu/skynet>skynet</a>框架中使用<a href=https://github.com/cloudwu/sproto>sproto</a>，于是<a href=https://github.com/cloudwu/pbc>pbc</a>就不再有功能维护了。</p><p>我们之前的也尝试直接使用了proto3，也是因为在迁移期，所以并没有使用全部的特性。但是仍然有一些向前不兼容的细节需要处理一下，所以有了这个改造</p></div><div class=article-more><a href=//owent.net/2017/1470.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-09-16T17:57:00.000+00:00 itemprop=datePublished>2017-09-16</time></div></div></article><article class="article-panel archive-article archive-type-1469"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1469.html target=_blank itemprop=url>atgateway内置协议流程优化-加密、算法协商和ECDH</a></h1></header><div class=article-summary><p>之前就有计划优化游戏服务器框架网关层的内部协议了，这次泰国旅游回来，新公司入职前，正海有空来做这件事。</p><h2 id=加密协商>加密协商</h2><p>以前提到过，最初决定重构这个流程是因为我觉得之前的方法，如果以后要扩展新的算法的话非常的麻烦。而后我看了一下shadowsocksr对多种加解密算法的实现方法，觉得还不错。就打算用类似的方法重写一下。当然也是因为写第一版的时候没考虑太多关于加解密方面的细节，还是优先实现出工程上可用的东西。这次就先稍微深入看了下像<a href=https://www.openssl.org/>openssl</a>和<a href=https://tls.mbed.org/>mbedtls</a>的一些实现，特别是下面会提到的cipher的实现。并以这个为基础来实现以后可能的增加加密算法的扩展。</p></div><div class=article-more><a href=//owent.net/2017/1469.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-09-08T18:37:00.000+00:00 itemprop=datePublished>2017-09-08</time></div></div></article><article class="article-panel archive-article archive-type-1468"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1468.html target=_blank itemprop=url>整理一波软件源镜像同步工具+DevOps工具</a></h1></header><div class=article-summary><p>上个月，同学的公司，格奕，突然间跪了。这个月基本属于休息+四处溜达。同时空闲的时候也想整理下之前做得一些之前的做得一些小工具们。在不泄密的情况下开源出来吧（其实也就是想找github存放一下而已，也没什么特别NB的东西）。</p></div><div class=article-more><a href=//owent.net/2017/1468.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-08-17T12:33:44.000+00:00 itemprop=datePublished>2017-08-17</time></div></div></article><article class="article-panel archive-article archive-type-1467"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1467.html target=_blank itemprop=url>Blog切换到Hugo</a></h1></header><div class=article-summary><p>其实很早就想把Blog迁移到静态化的博客系统了。不过一直没花时间来搞，当然主要原因还是懒。</p><p>这次下决心搞主要是因为，之前VPS迁移到Vultr，然后它的主机默认是没有交换区的。后来老是收到网站崩溃告警，每次去看都是MariaDB挂掉了，然后查了一下是内存不足。
然后，调整了几次参数，发现都不能解决问题。我这么个小站搞个高配机器显然是浪费。这种小网站都能耗尽1GB的内存我也是醉了。所以后来就干脆迁移到静态博客系统算了。</p></div><div class=article-more><a href=//owent.net/2017/1467.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-07-17T12:33:44.000+00:00 itemprop=datePublished>2017-07-17</time></div></div></article><article class="article-panel archive-article archive-type-1466"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2017/1466.html target=_blank itemprop=url>libcopp v2的第一波优化完成</a></h1></header><div class=article-summary><p>之前测出来<a href=https://github.com/owent/libcopp>libcopp</a>还有一些列优化点，但是要破坏之前的API，所以整理了一下优化的想法和方案。</p><h2 id=预留空间和合并分配>预留空间和合并分配</h2><p>之前有太多的堆内存分配了，导致很多碎片。那么第一个想法就是协程对象可以分配在栈上，runner也可以分配在栈上。然后还可以加一个自定义预留长度。每个对象对齐到sizeof(long)，总长度对齐到64 Bytes。</p></div><div class=article-more><a href=//owent.net/2017/1466.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2017-07-01T15:57:29.000+00:00 itemprop=datePublished>2017-07-01</time></div></div></article></div><hr><nav id=page-nav><ul class=pagination><li class=page-item><a class=page-link href=/page/3/index.html>&#171;上一页</a></li><li class=page-item><a class=page-link href=/index.html>1</a></li><li class=page-item><a class=page-link href=/page/2/index.html>2</a></li><li class=page-item><a class=page-link href=/page/3/index.html>3</a></li><li class='page-item disabled'><a class=page-link href=/page/4/index.html>4</a><span class=sr-only>(current)</span></li><li class=page-item><a class=page-link href=/page/5/index.html>5</a></li><li class=page-item><a class=page-link href=/page/6/index.html>6</a></li><li class=page-item><a class=page-link href=/page/7/index.html>7</a></li><li class=page-item><a class=page-link href=/page/8/index.html>8</a></li><li class=page-item><a class=page-link href=/page/9/index.html>9</a></li><li class=page-item><a class=page-link href=/page/10/index.html>10</a></li><li class=page-item><a class=page-link href=/page/11/index.html>11</a></li><li class=page-item><a class=page-link href=/page/12/index.html>12</a></li><li class=page-item><a class=page-link href=/page/13/index.html>13</a></li><li class=page-item><a class=page-link href=/page/5/index.html>下一页&#187;</a></li></ul></nav></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>2025&nbsp;OWenT
</strong><strong id=footer-right class="float-right float-end"><a href=https://beian.miit.gov.cn/ target=_blank>沪ICP备2022003252号</a>&nbsp;&nbsp;<a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=module>// import * as Popper from "@popperjs/core";// import * as bootstrap from "bootstrap";
// import React from "react";

        
</script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/accesslog.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/armasm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/awk.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/basic.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/bnf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/capnproto.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/cmake.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/d.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/dockerfile.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/dos.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/erlang.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/ebnf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/latex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/llvm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/lua.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/powershell.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/protobuf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/profile.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/vim.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/x86asm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/es/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex/+esm></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js></script><script type=module>
import mermaid from "mermaid";
const config = {
    theme: 'neutral',
    logLevel: 'fatal',
    securityLevel: 'loose', 
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    

};
mermaid.initialize(config);
</script><script type=text/javascript>var _hmt=_hmt||[];(function(){var t,n,e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6a0daf8d58889f1cf55a353867bfdbb0",t=document.getElementsByTagName("script"),n=document.getElementsByTagName("script")[t.length-1],n.parentNode.appendChild(e)})()</script></div></body></html>