<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.138.0"><meta charset=utf-8><title>I'm OWenT|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/><link rel=alternate type=application/rss+xml href=//owent.net/index.xml title="I'm OWenT"><link rel=icon href=../favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script type=importmap>
{
  "imports": {
    "react": "//unpkg.com/react@latest",
    "react-bootstrap": "//unpkg.com/react-bootstrap@latest",
    "mermaid": "//unpkg.com/mermaid@latest/dist/mermaid.esm.min.mjs",
    "bootstrap": "//unpkg.com/bootstrap@latest/dist/js/bootstrap.esm.min.js",
    "@popperjs/core": "//unpkg.com/@popperjs/core@latest/dist/esm/popper.js"
  }
}
</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta name=baidu-site-verification content="codeva-4M5iohb9TW"></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=../ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=../archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=../about.html title=About>About</a></li><li class=nav-item><a id=nav-rss-link class=nav-link href=//owent.net/index.xml title=RSS订阅>RSS订阅</a></li><li class="nav-item nav-ads ads-placeholder ads-container"><ins class="adsbygoogle ads_menu" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=4450372783 data-ad-format=auto data-full-width-responsive=true></ins><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{setTimeout(function(){try{(adsbygoogle=window.adsbygoogle||[]).push({})}catch(e){console.log("Load adsbygoogle failed"),console.error(e)}},256)})</script></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=index-content><article class="article-panel archive-article archive-type-8"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/8.html target=_blank itemprop=url>线段树相关问题 (引用 PKU POJ题目) 整理</a></h1></header><div class=article-summary><h2 id=1rangeminimummaximum-query问题计算单调区间内出现最多少的次数>1.RangeMinimum、Maximum Query问题（计算单调区间内出现最多（少）的次数）</h2><p>对元素的起点做离散化，再把离散化后的位置作为线段树的[l, r),记录次数为t.</p><p>对输入区间a, b:</p></div><div class=article-more><a href=//owent.net/2010/8.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-10-12T16:45:11.000+00:00 itemprop=datePublished>2010-10-12</time></div></div></article><article class="article-panel archive-article archive-type-10"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/10.html target=_blank itemprop=url>POJ PKU 1474 Video Surveillance 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://poj.org/problem?id=1474">http://poj.org/problem?id=1474</a></p><p>写这题的目的是看完了zzy的论文，写了半平面交，验证一下正确性，结果发现我写的问题还是很多的。</p><p>题目大意是问能不能放一个摄像机，使得摄像机能看到整个多边形内部。</p></div><div class=article-more><a href=//owent.net/2010/10.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-10-04T11:49:56.000+00:00 itemprop=datePublished>2010-10-04</time></div></div></article><article class="article-panel archive-article archive-type-11"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/11.html target=_blank itemprop=url>ACM 计算几何 个人模板</a></h1></header><div class=article-summary><pre><code class=language-cpp>/**
 * 二维ACM计算几何模板
 * 注意变量类型更改和EPS
 * #include &lt;cmath&gt;
 * #include &lt;cstdio&gt;
 * By OWenT
 */

const double eps = 1e-8;
const double pi = std::acos(-1.0);
//点
class point
{
public:
    double x, y;
    point(){};
    point(double x, double y):x(x),y(y){};

    static int xmult(const point &amp;ps, const point &amp;pe, const point &amp;po)
    {
        return (ps.x - po.x) * (pe.y - po.y) - (pe.x - po.x) * (ps.y - po.y);
    }

    //相对原点的差乘结果，参数：点[_Off]
    //即由原点和这两个点组成的平行四边形面积
    double operator *(const point &amp;_Off) const
    {
        return x * _Off.y - y * _Off.x;
    }
    //相对偏移
    point operator - (const point &amp;_Off) const
    {
        return point(x - _Off.x, y - _Off.y);
    }
    //点位置相同(double类型)
    bool operator == (const point &amp;_Off) const
    {
        return std::fabs(_Off.x - x) &lt; eps &amp;&amp; std::fabs(_Off.y - y) &lt; eps;
    }
    //点位置不同(double类型)
    bool operator != (const point &amp;_Off) const
    {
        return ((*this) == _Off) == false;
    }
    //两点间距离的平方
    double dis2(const point &amp;_Off) const
    {
        return (x - _Off.x) * (x - _Off.x) + (y - _Off.y) * (y - _Off.y);
    }
    //两点间距离
    double dis(const point &amp;_Off) const
    {
        return std::sqrt((x - _Off.x) * (x - _Off.x) + (y - _Off.y) * (y - _Off.y));
    }
};

//两点表示的向量
class pVector
{
public:
    point s, e;//两点表示，起点[s]，终点[e]
    double a, b, c;//一般式,ax+by+c=0

    pVector(){}
    pVector(const point &amp;s, const point &amp;e):s(s),e(e){}

    //向量与点的叉乘,参数：点[_Off]
    //[点相对向量位置判断]
    double operator *(const point &amp;_Off) const
    {
        return (_Off.y - s.y) * (e.x - s.x) - (_Off.x - s.x) * (e.y - s.y);
    }
    //向量与向量的叉乘,参数：向量[_Off]
    double operator *(const pVector &amp;_Off) const
    {
        return (e.x - s.x) * (_Off.e.y - _Off.s.y) - (e.y - s.y) * (_Off.e.x - _Off.s.x);
    }
    //从两点表示转换为一般表示
    bool pton()
    {
        a = s.y - e.y;
        b = e.x - s.x;
        c = s.x * e.y - s.y * e.x;
        return true;
    }

    //-----------点和直线（向量）-----------
    //点在向量左边（右边的小于号改成大于号即可,在对应直线上则加上=号）
    //参数：点[_Off],向量[_Ori]
    friend bool operator&lt;(const point &amp;_Off, const pVector &amp;_Ori)
    {
        return (_Ori.e.y - _Ori.s.y) * (_Off.x - _Ori.s.x)
            &lt; (_Off.y - _Ori.s.y) * (_Ori.e.x - _Ori.s.x);
    }

    //点在直线上,参数：点[_Off]
    bool lhas(const point &amp;_Off) const
    {
        return std::fabs((*this) * _Off) &lt; eps;
    }
    //点在线段上,参数：点[_Off]
    bool shas(const point &amp;_Off) const
    {
        return lhas(_Off)
            &amp;&amp; _Off.x - std::min(s.x, e.x) &gt; -eps &amp;&amp; _Off.x - std::max(s.x, e.x) &lt; eps
            &amp;&amp; _Off.y - std::min(s.y, e.y) &gt; -eps &amp;&amp; _Off.y - std::max(s.y, e.y) &lt; eps;
    }

    //点到直线/线段的距离
    //参数： 点[_Off], 是否是线段[isSegment](默认为直线)
    double dis(const point &amp;_Off, bool isSegment = false)
    {
        //化为一般式
        pton();

        //到直线垂足的距离
        double td = (a * _Off.x + b * _Off.y + c) / sqrt(a * a + b * b);

        //如果是线段判断垂足
        if(isSegment)
        {
            double xp = (b * b * _Off.x - a * b * _Off.y - a * c) / ( a * a + b * b);
            double yp = (-a * b * _Off.x + a * a * _Off.y - b * c) / (a * a + b * b);
            double xb = std::max(s.x, e.x);
            double yb = std::max(s.y, e.y);
            double xs = s.x + e.x - xb;
            double ys = s.y + e.y - yb;
            if(xp &gt; xb + eps || xp &lt; xs - eps || yp &gt; yb + eps || yp &lt; ys - eps)
                td = std::min(_Off.dis(s), _Off.dis(e));
        }

        return fabs(td);
    }

    //关于直线对称的点
    point mirror(const point &amp;_Off) const
    {
        //注意先转为一般式
        point ret;
        double d = a * a + b * b;
        ret.x = (b * b * _Off.x - a * a * _Off.x - 2 * a * b * _Off.y - 2 * a * c) / d;
        ret.y = (a * a * _Off.y - b * b * _Off.y - 2 * a * b * _Off.x - 2 * b * c) / d;
        return ret;
    }
    //计算两点的中垂线
    static pVector ppline(const point &amp;_a, const point &amp;_b)
    {
        pVector ret;
        ret.s.x = (_a.x + _b.x) / 2;
        ret.s.y = (_a.y + _b.y) / 2;
        //一般式
        ret.a = _b.x - _a.x;
        ret.b = _b.y - _a.y;
        ret.c = (_a.y - _b.y) * ret.s.y + (_a.x - _b.x) * ret.s.x;
        //两点式
        if(std::fabs(ret.a) &gt; eps)
        {
            ret.e.y = 0.0;
            ret.e.x = - ret.c / ret.a;
            if(ret.e == ret. s)
            {
                ret.e.y = 1e10;
                ret.e.x = - (ret.c - ret.b * ret.e.y) / ret.a;
            }
        }
        else
        {
            ret.e.x = 0.0;
            ret.e.y = - ret.c / ret.b;
            if(ret.e == ret. s)
            {
                ret.e.x = 1e10;
                ret.e.y = - (ret.c - ret.a * ret.e.x) / ret.b;
            }
        }
        return ret;
    }

    //------------直线和直线（向量）-------------
    //直线重合,参数：直线向量[_Off]
    bool equal(const pVector &amp;_Off) const
    {
        return lhas(_Off.e) &amp;&amp; lhas(_Off.s);
    }
    //直线平行，参数：直线向量[_Off]
    bool parallel(const pVector &amp;_Off) const
    {
        return std::fabs((*this) * _Off) &lt; eps;
    }
    //两直线交点，参数：目标直线[_Off]
    point crossLPt(pVector _Off)
    {
        //注意先判断平行和重合
        point ret = s;
        double t = ((s.x - _Off.s.x) * (_Off.s.y - _Off.e.y) - (s.y - _Off.s.y) * (_Off.s.x - _Off.e.x))
                / ((s.x - e.x) * (_Off.s.y - _Off.e.y) - (s.y - e.y) * (_Off.s.x - _Off.e.x));
        ret.x += (e.x - s.x) * t;
        ret.y += (e.y - s.y) * t;
        return ret;
    }

    //------------线段和直线（向量）----------
    //线段和直线交
    //参数：线段[_Off]
    bool crossSL(const pVector &amp;_Off) const
    {
        double rs = (*this) * _Off.s;
        double re = (*this) * _Off.e;
        return rs * re &lt; eps;
    }

    //------------线段和线段（向量）----------
    //判断线段是否相交(注意添加eps)，参数：线段[_Off]
    bool isCrossSS(const pVector &amp;_Off) const
    {
        //1.快速排斥试验判断以两条线段为对角线的两个矩形是否相交
        //2.跨立试验（等于0时端点重合）
        return (
            (std::max(s.x, e.x) &gt;= std::min(_Off.s.x, _Off.e.x)) &amp;&amp;
            (std::max(_Off.s.x, _Off.e.x) &gt;= std::min(s.x, e.x)) &amp;&amp;
            (std::max(s.y, e.y) &gt;= std::min(_Off.s.y, _Off.e.y)) &amp;&amp;
            (std::max(_Off.s.y, _Off.e.y) &gt;= std::min(s.y, e.y)) &amp;&amp;
            ((pVector(_Off.s, s) * _Off) * (_Off * pVector(_Off.s, e)) &gt;= 0.0) &amp;&amp;
            ((pVector(s, _Off.s) * (*this)) * ((*this) * pVector(s, _Off.e)) &gt;= 0.0)
            );
    }
};

class polygon
{
public:
    const static long maxpn = 100;
    point pt[maxpn];//点（顺时针或逆时针）
    long n;//点的个数

    point&amp; operator[](int _p)
    {
        return pt[_p];
    }

    //求多边形面积，多边形内点必须顺时针或逆时针
    double area() const
    {
        double ans = 0.0;
        int i;
        for(i = 0; i &lt; n; i ++)
        {
            int nt = (i + 1) % n;
            ans += pt[i].x * pt[nt].y - pt[nt].x * pt[i].y;
        }
        return std::fabs(ans / 2.0);
    }
    //求多边形重心，多边形内点必须顺时针或逆时针
    point gravity() const
    {
        point ans;
        ans.x = ans.y = 0.0;
        int i;
        double area = 0.0;
        for(i = 0; i &lt; n; i ++)
        {
            int nt = (i + 1) % n;
            double tp = pt[i].x * pt[nt].y - pt[nt].x * pt[i].y;
            area += tp;
            ans.x += tp * (pt[i].x + pt[nt].x);
            ans.y += tp * (pt[i].y + pt[nt].y);
        }
        ans.x /= 3 * area;
        ans.y /= 3 * area;
        return ans;
    }
    //判断点在凸多边形内，参数：点[_Off]
    bool chas(const point &amp;_Off) const
    {
        double tp = 0, np;
        int i;
        for(i = 0; i &lt; n; i ++)
        {
            np = pVector(pt[i], pt[(i + 1) % n]) * _Off;
            if(tp * np &lt; -eps)
                return false;
            tp = (std::fabs(np) &gt; eps)?np: tp;
        }
        return true;
    }
    //判断点是否在任意多边形内[射线法]，O(n)
    bool ahas(const point &amp;_Off) const
    {
        int ret = 0;
        double infv = 1e-10;//坐标系最大范围
        pVector l = pVector(_Off, point( -infv ,_Off.y));
        for(int i = 0; i &lt; n; i ++)
        {
            pVector ln = pVector(pt[i], pt[(i + 1) % n]);
            if(fabs(ln.s.y - ln.e.y) &gt; eps)
            {
                point tp = (ln.s.y &gt; ln.e.y)? ln.s: ln.e;
                if(fabs(tp.y - _Off.y) &lt; eps &amp;&amp; tp.x &lt; _Off.x + eps)
                    ret ++;
            }
            else if(ln.isCrossSS(l))
                ret ++;
        }
        return (ret % 2 == 1);
    }
    //凸多边形被直线分割,参数：直线[_Off]
    polygon split(pVector _Off)
    {
        //注意确保多边形能被分割
        polygon ret;
        point spt[2];
        double tp = 0.0, np;
        bool flag = true;
        int i, pn = 0, spn = 0;
        for(i = 0; i &lt; n; i ++)
        {
            if(flag)
                pt[pn ++] = pt[i];
            else
                ret.pt[ret.n ++] = pt[i];
            np = _Off * pt[(i + 1) % n];
            if(tp * np &lt; -eps)
            {
                flag = !flag;
                spt[spn ++] = _Off.crossLPt(pVector(pt[i], pt[(i + 1) % n]));
            }
            tp = (std::fabs(np) &gt; eps)?np: tp;
        }
        ret.pt[ret.n ++] = spt[0];
        ret.pt[ret.n ++] = spt[1];
        n = pn;
        return ret;
    }

    //-------------凸包-------------
    //Graham扫描法，复杂度O(nlg(n)),结果为逆时针
    //#include &lt;algorithm&gt;
    static bool graham_cmp(const point &amp;l, const point &amp;r)//凸包排序函数
    {
        return l.y &lt; r.y || (l.y == r.y &amp;&amp; l.x &lt; r.x);
    }
    polygon&amp; graham(point _p[], int _n)
    {
        int i, len;
        std::sort(_p, _p + _n, polygon::graham_cmp);
        n = 1;
        pt[0] = _p[0], pt[1] = _p[1];
        for(i = 2; i &lt; _n; i ++)
        {
            while(n &amp;&amp; point::xmult(_p[i], pt[n], pt[n - 1]) &gt;= 0)
                n --;
            pt[++ n] = _p[i];
        }
        len = n;
        pt[++ n] = _p[_n - 2];
        for(i = _n - 3; i &gt;= 0; i --)
        {
            while(n != len &amp;&amp; point::xmult(_p[i], pt[n], pt[n - 1]) &gt;= 0)
                n --;
            pt[++ n] = _p[i];
        }
        return (*this);
    }

    //凸包旋转卡壳(注意点必须顺时针或逆时针排列)
    //返回值凸包直径的平方（最远两点距离的平方）
    double rotating_calipers()
    {
        int i = 1;
        double ret = 0.0;
        pt[n] = pt[0];
        for(int j = 0; j &lt; n; j ++)
        {
            while(fabs(point::xmult(pt[j], pt[j + 1], pt[i + 1])) &gt; fabs(point::xmult(pt[j], pt[j + 1], pt[i])) + eps)
                i = (i + 1) % n;
            //pt[i]和pt[j],pt[i + 1]和pt[j + 1]可能是对踵点
            ret = std::max(ret, std::max(pt[i].dis(pt[j]), pt[i + 1].dis(pt[j + 1])));
        }
        return ret;
    }

    //凸包旋转卡壳(注意点必须逆时针排列)
    //返回值两凸包的最短距离
    double rotating_calipers(polygon &amp;_Off)
    {
        int i = 0;
        double ret = 1e10;//inf
        pt[n] = pt[0];
        _Off.pt[_Off.n] = _Off.pt[0];
        //注意凸包必须逆时针排列且pt[0]是左下角点的位置
        while(_Off.pt[i + 1].y &gt; _Off.pt[i].y)
            i = (i + 1) % _Off.n;
        for(int j = 0; j &lt; n; j ++)
        {
            double tp;
            //逆时针时为 &gt;,顺时针则相反
            while((tp = point::xmult(pt[j], pt[j + 1], _Off.pt[i + 1]) - point::xmult( pt[j], pt[j + 1], _Off.pt[i])) &gt; eps)
                i = (i + 1) % _Off.n;
            //(pt[i],pt[i+1])和(_Off.pt[j],_Off.pt[j + 1])可能是最近线段
            ret = std::min(ret, pVector(pt[j], pt[j + 1]).dis(_Off.pt[i], true));
            ret = std::min(ret, pVector(_Off.pt[i], _Off.pt[i + 1]).dis(pt[j + 1], true));
            if(tp &gt; -eps)//如果不考虑TLE问题最好不要加这个判断
            {
                ret = std::min(ret, pVector(pt[j], pt[j + 1]).dis(_Off.pt[i + 1], true));
                ret = std::min(ret, pVector(_Off.pt[i], _Off.pt[i + 1]).dis(pt[j], true));
            }
        }
        return ret;
    }

    //-----------半平面交-------------
    //复杂度:O(nlog2(n))
    //#include &lt;algorithm&gt;
    //半平面计算极角函数[如果考虑效率可以用成员变量记录]
    static double hpc_pa(const pVector &amp;_Off)
    {
        return atan2(_Off.e.y - _Off.s.y, _Off.e.x - _Off.s.x);
    }
    //半平面交排序函数[优先顺序: 1.极角 2.前面的直线在后面的左边]
    static bool hpc_cmp(const pVector &amp;l, const pVector &amp;r)
    {
        double lp = hpc_pa(l), rp = hpc_pa(r);
        if(fabs(lp - rp) &gt; eps)
            return lp &lt; rp;
        return point::xmult(l.s, r.e, r.s) &lt; 0.0;
    }
    //用于计算的双端队列
    pVector dequeue[maxpn];
    //获取半平面交的多边形（多边形的核）
    //参数：向量集合[l]，向量数量[ln];(半平面方向在向量左边）
    //函数运行后如果n[即返回多边形的点数量]为0则不存在半平面交的多边形（不存在区域或区域面积无穷大）
    polygon&amp; halfPanelCross(pVector _Off[], int ln)
    {
        int i, tn;
        n = 0;
        std::sort(_Off, _Off + ln, hpc_cmp);
        //平面在向量左边的筛选
        for(i = tn = 1; i &lt; ln; i ++)
            if(fabs(hpc_pa(_Off[i]) - hpc_pa(_Off[i - 1])) &gt; eps)
                _Off[tn ++] = _Off[i];
        ln = tn;
        int bot = 0, top = 1;
        dequeue[0] = _Off[0];
        dequeue[1] = _Off[1];
        for(i = 2; i &lt; ln; i ++)
        {
            if(dequeue[top].parallel(dequeue[top - 1]) ||
                dequeue[bot].parallel(dequeue[bot + 1]))
                return (*this);
            while(bot &lt; top &amp;&amp;
                point::xmult(dequeue[top].crossLPt(dequeue[top - 1]), _Off[i].e, _Off[i].s) &gt; eps)
                top --;
            while(bot &lt; top &amp;&amp;
                point::xmult(dequeue[bot].crossLPt(dequeue[bot + 1]), _Off[i].e, _Off[i].s) &gt; eps)
                bot ++;
            dequeue[++ top] = _Off[i];
        }

        while(bot &lt; top &amp;&amp;
            point::xmult(dequeue[top].crossLPt(dequeue[top - 1]), dequeue[bot].e, dequeue[bot].s) &gt; eps)
            top --;
        while(bot &lt; top &amp;&amp;
            point::xmult(dequeue[bot].crossLPt(dequeue[bot + 1]), dequeue[top].e, dequeue[top].s) &gt; eps)
            bot ++;
        //计算交点(注意不同直线形成的交点可能重合)
        if(top &lt;= bot + 1)
            return (*this);
        for(i = bot; i &lt; top; i ++)
            pt[n ++] = dequeue[i].crossLPt(dequeue[i + 1]);
        if(bot &lt; top + 1)
            pt[n ++] = dequeue[bot].crossLPt(dequeue[top]);
        return (*this);
    }
};
class circle
{
public:
    point c;//圆心
    double r;//半径
    double db, de;//圆弧度数起点， 圆弧度数终点(逆时针0-360)

    //-------圆---------

    //判断圆在多边形内
    bool inside(const polygon &amp;_Off) const
    {
        if(_Off.ahas(c) == false)
            return false;
        for(int i = 0; i &lt; _Off.n; i ++)
        {
            pVector l = pVector(_Off.pt[i], _Off.pt[(i + 1) % _Off.n]);
            if(l.dis(c, true) &lt; r - eps)
                return false;
        }
        return true;
    }

    //判断多边形在圆内（线段和折线类似）
    bool has(const polygon &amp;_Off) const
    {
        for(int i = 0; i &lt; _Off.n; i ++)
            if(_Off.pt[i].dis2(c) &gt; r * r - eps)
                return false;
        return true;
    }

    //-------圆弧-------
    //圆被其他圆截得的圆弧，参数：圆[_Off]
    circle operator-(circle &amp;_Off) const
    {
        //注意圆必须相交，圆心不能重合
        double d2 = c.dis2(_Off.c);
        double d = c.dis(_Off.c);
        double ans = std::acos((d2 + r * r - _Off.r * _Off.r) / (2 * d * r));
        point py = _Off.c - c;
        double oans = std::atan2(py.y, py.x);
        circle res;
        res.c = c;
        res.r = r;
        res.db = oans + ans;
        res.de = oans - ans + 2 * pi;
        return res;
    }
    //圆被其他圆截得的圆弧，参数：圆[_Off]
    circle operator+(circle &amp;_Off) const
    {
        //注意圆必须相交，圆心不能重合
        double d2 = c.dis2(_Off.c);
        double d = c.dis(_Off.c);
        double ans = std::acos((d2 + r * r - _Off.r * _Off.r) / (2 * d * r));
        point py = _Off.c - c;
        double oans = std::atan2(py.y, py.x);
        circle res;
        res.c = c;
        res.r = r;
        res.db = oans - ans;
        res.de = oans + ans;
        return res;
    }

    //过圆外一点的两条切线
    //参数：点[_Off](必须在圆外),返回：两条切线(切线的s点为_Off,e点为切点)
    std::pair&lt;pVector, pVector&gt;  tangent(const point &amp;_Off) const
    {
        double d = c.dis(_Off);
        //计算角度偏移的方式
        double angp = std::acos(r / d), ango = std::atan2(_Off.y - c.y, _Off.x - c.x);
        point pl = point(c.x + r * std::cos(ango + angp), c.y + r * std::sin(ango + angp)),
            pr = point(c.x + r * std::cos(ango - angp), c.y + r * std::sin(ango - angp));
        return std::make_pair(pVector(_Off, pl), pVector(_Off, pr));
    }

    //计算直线和圆的两个交点
    //参数：直线[_Off](两点式)，返回两个交点，注意直线必须和圆有两个交点
    std::pair&lt;point, point&gt; cross(pVector _Off) const
    {
        _Off.pton();
        //到直线垂足的距离
        double td = fabs(_Off.a * c.x + _Off.b * c.y + _Off.c) / sqrt(_Off.a * _Off.a + _Off.b * _Off.b);

        //计算垂足坐标
        double xp = (_Off.b * _Off.b * c.x - _Off.a * _Off.b * c.y - _Off.a * _Off.c) / ( _Off.a * _Off.a + _Off.b * _Off.b);
        double yp = (- _Off.a * _Off.b * c.x + _Off.a * _Off.a * c.y - _Off.b * _Off.c) / (_Off.a * _Off.a + _Off.b * _Off.b);

        double ango = std::atan2(yp - c.y, xp - c.x);
        double angp = std::acos(td / r);

        return std::make_pair(point(c.x + r * std::cos(ango + angp), c.y + r * std::sin(ango + angp)),
            point(c.x + r * std::cos(ango - angp), c.y + r * std::sin(ango - angp)));
    }
};

class triangle
{
public:
    point a, b, c;//顶点
    triangle(){}
    triangle(point a, point b, point c): a(a), b(b), c(c){}

    //计算三角形面积
    double area()
    {
        return fabs(point::xmult(a, b, c)) / 2.0;
    }

    //计算三角形外心
    //返回：外接圆圆心
    point circumcenter()
    {
        pVector u,v;
        u.s.x = (a.x + b.x) / 2;
        u.s.y = (a.y + b.y) / 2;
        u.e.x = u.s.x - a.y + b.y;
        u.e.y = u.s.y + a.x - b.x;
        v.s.x = (a.x + c.x) / 2;
        v.s.y = (a.y + c.y) / 2;
        v.e.x = v.s.x - a.y + c.y;
        v.e.y = v.s.y + a.x - c.x;
        return u.crossLPt(v);
    }

    //计算三角形内心
    //返回：内接圆圆心
    point incenter()
    {
        pVector u, v;
        double m, n;
        u.s = a;
        m = atan2(b.y - a.y, b.x - a.x);
        n = atan2(c.y - a.y, c.x - a.x);
        u.e.x = u.s.x + cos((m + n) / 2);
        u.e.y = u.s.y + sin((m + n) / 2);
        v.s = b;
        m = atan2(a.y - b.y, a.x - b.x);
        n = atan2(c.y - b.y, c.x - b.x);
        v.e.x = v.s.x + cos((m + n) / 2);
        v.e.y = v.s.y + sin((m + n) / 2);
        return u.crossLPt(v);
    }

    //计算三角形垂心
    //返回：高的交点
    point perpencenter()
    {
        pVector u,v;
        u.s = c;
        u.e.x = u.s.x - a.y + b.y;
        u.e.y = u.s.y + a.x - b.x;
        v.s = b;
        v.e.x = v.s.x - a.y + c.y;
        v.e.y = v.s.y + a.x - c.x;
        return u.crossLPt(v);
    }

    //计算三角形重心
    //返回：重心
    //到三角形三顶点距离的平方和最小的点
    //三角形内到三边距离之积最大的点
    point barycenter()
    {
        pVector u,v;
        u.s.x = (a.x + b.x) / 2;
        u.s.y = (a.y + b.y) / 2;
        u.e = c;
        v.s.x = (a.x + c.x) / 2;
        v.s.y = (a.y + c.y) / 2;
        v.e = b;
        return u.crossLPt(v);
    }

    //计算三角形费马点
    //返回：到三角形三顶点距离之和最小的点
    point fermentpoint()
    {
        point u, v;
        double step = fabs(a.x) + fabs(a.y) + fabs(b.x) + fabs(b.y) + fabs(c.x) + fabs(c.y);
        int i, j, k;
        u.x = (a.x + b.x + c.x) / 3;
        u.y = (a.y + b.y + c.y) / 3;
        while (step &gt; eps)
        {
            for (k = 0; k &lt; 10; step /= 2, k ++)
            {
                for (i = -1; i &lt;= 1; i ++)
                {
                    for (j =- 1; j &lt;= 1; j ++)
                    {
                        v.x = u.x + step * i;
                        v.y = u.y + step * j;
                        if (u.dis(a) + u.dis(b) + u.dis(c) &gt; v.dis(a) + v.dis(b) + v.dis(c))
                            u = v;
                    }
                }
            }
        }
        return u;
    }
};
</code></pre></div><div class=article-more><a href=//owent.net/2010/11.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-10-04T11:19:02.000+00:00 itemprop=datePublished>2010-10-04</time></div></div></article><article class="article-panel archive-article archive-type-13"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/13.html target=_blank itemprop=url>The 35th ACM/ICPC Asia Regional Tianjin Site —— Online Contest 1009 Convex 解题报告</a></h1></header><div class=article-summary><p>The 35th ACM/ICPC Asia Regional Tianjin Site —— Online Contest</p><p>2010年天津赛 网络赛 I题 Convex</p><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3629">http://acm.hdu.edu.cn/showproblem.php?pid=3629</a></p><p>题目大意是给你700个点，问从中选4个点组成凸四边形的方法数</p><p>比赛的时候其实最终得到了正确的方法，结果因为写搓了导致TLE，HDU的64位整形必须用I64d，导致WA</p></div><div class=article-more><a href=//owent.net/2010/13.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-09-14T08:12:26.000+00:00 itemprop=datePublished>2010-09-14</time></div></div></article><article class="article-panel archive-article archive-type-15"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/15.html target=_blank itemprop=url>Catalan 数</a></h1></header><div class=article-summary><p>Catalan数:</p><p>$$ h(1)=1,h(0)=1 $$</p><p>$$ h(n)=\begin{cases} \sum_{i=0}^{n-1} h(i) \times h(n-i-1) & \text{if }(n>=2) \\ \frac{C(2n,n)}{n+1} & \text{if }(n=1,2,3,\mathellipsis) \end{cases} $$</p><p>相关结论：
n边形能分解成三角形的分法数为 h(n – 2)
n个节点能组成的二叉树个数为 h(n)
一个栈(无穷大)的进栈序列为1，2，3，…，n，出栈序列种数为 h(n)</p></div><div class=article-more><a href=//owent.net/2010/15.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-09-08T16:47:57.000+00:00 itemprop=datePublished>2010-09-08</time></div></div></article><article class="article-panel archive-article archive-type-17"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/17.html target=_blank itemprop=url>简易四则运算(ACM个人模板)</a></h1></header><div class=article-summary><pre><code class=language-cpp>/**
 * 简易四则运算（栈实现）
 * #include &lt;stack&gt;
 * #include &lt;cstring&gt;
 */
std::stack&lt;char&gt; opr;
std::stack&lt;double&gt; num;
char oprPRI[256];
//初始化调用
void initCalc()
{
    //优先级设置
    char oprMap[7][2] = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'^', 3}, {'(', 100}, {')', 0} };
    for(int i = 0; i &lt; 7; i ++)
        oprPRI[oprMap[i][0]] = oprMap[i][1];
}
bool checkNum(char c)
{
    return c == '.' || (c &gt;= '0' &amp;&amp; c &lt;= '9');
}
double calcOpr(double l, double r, char opr)
{
    switch(opr)
    {
        case '+': return l + r;
        case '-': return l - r;
        case '*': return l * r;
        case '/': return l / r;
        case '^': return ::pow(l, r);
    }
    return 0.0;
}
void calcStack()
{
    double cl, cr;
    cr = num.top();
    num.pop();
    cl = num.top();
    num.pop();
    num.push(::calcOpr(cl, cr, opr.top()));
    opr.pop();
}
double calc(const char str[])
{
    while(!opr.empty())
        opr.pop();
    while(!num.empty())
        num.pop();
    int i = 0, len = strlen(str);
    num.push(0.0);
    opr.push('(');
    while(i &lt; len)
    {
        if(::checkNum(str[i]))
        {
            double l;
            ::sscanf(str + i, &quot;%lf&quot;, &amp;l);
            while(::checkNum(str[i]))
            i ++;
            num.push(l);
        }
        else
        {
            char c = str[i ++];
            if(c == ')')
            {
                while(opr.top() != '(')
                    calcStack();
                opr.pop();
            }
            else if(oprPRI[c] &gt; oprPRI[opr.top()])
                opr.push(c);
            else
            {
                while(opr.top() != '(' &amp;&amp; oprPRI[c] &lt;= oprPRI[opr.top()])
                    calcStack();
                opr.push(c);
            }
        }
    }
    while(opr.size() &gt; 1)
        calcStack();
    return num.top();
}
</code></pre></div><div class=article-more><a href=//owent.net/2010/17.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-08-10T18:40:31.000+00:00 itemprop=datePublished>2010-08-10</time></div></div></article><article class="article-panel archive-article archive-type-18"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/18.html target=_blank itemprop=url>数论模板（个人模板）</a></h1></header><div class=article-summary><h2 id=基础函数>基础函数:</h2><pre><code class=language-cpp>// 最大公约数,欧几里得定理
int gcd(int a, int b)
{
    return b?gcd(b, a % b): a;
}
// 拓展欧几里得定理
// 求解ax + by = gcd(a,b)
int ext_gcd(int a, int b, int &amp;x, int &amp;y)
{
    int tmp, ret;
    if(!b)
    {
        x = 1;
        y = 0;
        return a;
    }
    ret = ext_gcd(b, a % b, x, y);
    tmp = x;
    x = y;
    y = tmp - (a / b) * y;
    return ret;
}
//交换数值
void swap(int &amp;a, int &amp;b)
{
    a ^= b ^= a ^= b;
}

/**
 * a的b次方Mod c
 * 参数为整数
 * 使用时注意修改类型
 */
int PowerMod(int a, int b, int c)
{
    int tp = 1;
    while (b)
    {
        if (b &amp; 1)
            tp = (tp * a) % c;
        a = (a * a) % c;
        b &gt;&gt;= 1;
    }
    return tp;
}
</code></pre><h2 id=1欧拉函数>1.欧拉函数</h2><p>Ψ（n） = 小于n且与n互质的数的个数</p></div><div class=article-more><a href=//owent.net/2010/18.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-08-09T15:54:02.000+00:00 itemprop=datePublished>2010-08-09</time></div></div></article><article class="article-panel archive-article archive-type-19"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/19.html target=_blank itemprop=url>POJ PKU 2826 An Easy Problem?! 解题报告</a></h1></header><div class=article-summary><p>题目链接：
<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2826">http://acm.pku.edu.cn/JudgeOnline/problem?id=2826</a></p><p>大致意思是给你两条线段，问组成的开口向上的V形区域能盛多少雨水。雨水是垂直落下的。</p><p>显然线段不相交，或者平行，重合，或者有一条斜率为0时结果为0.00</p></div><div class=article-more><a href=//owent.net/2010/19.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-08-07T08:54:04.000+00:00 itemprop=datePublished>2010-08-07</time></div></div></article><article class="article-panel archive-article archive-type-20"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/20.html target=_blank itemprop=url>关于差分约束（转载）</a></h1></header><div class=article-summary><p>关于差分约束（转载）</p><p>（本文假设读者已经有以下知识：最短路径的基本性质、Bellman-Ford算法。）
比如有这样一组不等式：</p><p>$$ \begin{cases} X1 - X2 &lt;= 0 \\ X1 - X5 &lt;= (-1) \\ X2 - X5 &lt;= 1 \\ X3 - X1 &lt;= 5 \\ X4 - X1 &lt;= 4 \\ X4 - X3 &lt;= (-1) \\ X5 - X3 &lt;= (-3) \\ X5 - X4 &lt;= (-3) \end{cases} $$(1)</p></div><div class=article-more><a href=//owent.net/2010/20.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-08-02T06:49:13.000+00:00 itemprop=datePublished>2010-08-02</time></div></div></article><article class="article-panel archive-article archive-type-21"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/21.html target=_blank itemprop=url>计算几何算法概览[转载]</a></h1></header><div class=article-summary><p>一、引言</p><p>　　计算机的出现使得很多原本十分繁琐的工作得以大幅度简化，但是也有一些在人们直观看来很容易的问题却需要拿出一套并不简单的通用解决方案，比如几何问题。作为计算机科学的一个分支，计算几何主要研究解决几何问题的算法。在现代工程和数学领域，计算几何在图形学、机器人技术、超大规模集成电路设计和统计等诸多领域有着十分重要的应用。在本文中，我们将对计算几何常用的基本算法做一个全面的介绍，希望对您了解并应用计算几何的知识解决问题起到帮助。</p></div><div class=article-more><a href=//owent.net/2010/21.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-07-24T16:40:14.000+00:00 itemprop=datePublished>2010-07-24</time></div></div></article><article class="article-panel archive-article archive-type-22"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/22.html target=_blank itemprop=url>POJ PKU 1986 Distance Queries 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1986">http://acm.pku.edu.cn/JudgeOnline/problem?id=1986</a></p><p>这是一道并查集+树的题，采用Tarjan离线算法</p><p>首先BS一下出题的人，也太懒了吧，还要我们看1984题才知道输入</p><p>题目的意思是告诉一个节点数为40000的树，问我们两个节点间的距离。实际上就是找出公共父节点，Tarjan算法写挫了很容易TLE，我开始用Vector就写搓了，结果TLE，后来重写，自己写邻接表然后AC了。</p></div><div class=article-more><a href=//owent.net/2010/22.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-07-16T04:57:10.000+00:00 itemprop=datePublished>2010-07-16</time></div></div></article><article class="article-panel archive-article archive-type-23"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/23.html target=_blank itemprop=url>POJ PKU 2446 Chessboard 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2446">http://acm.pku.edu.cn/JudgeOnline/problem?id=2446</a></p><p>这是一道匹配题，把行数（r）和列数（c）按（r+c）%2分成两组，然后连边，做一次二分图匹配，可以直接用匈牙利算法</p><p>匹配数等于两组的元素个数则为YES，否则NO</p></div><div class=article-more><a href=//owent.net/2010/23.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-07-16T04:51:23.000+00:00 itemprop=datePublished>2010-07-16</time></div></div></article><article class="article-panel archive-article archive-type-25"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/25.html target=_blank itemprop=url>参加有道难题笔记</a></h1></header><div class=article-summary><p>好久不写代码，省赛之后一直在赶作业和复习。对自己还真没什么信心</p><p>话说回来试了一下联系赛</p><p>三道水题，虽然钱两题很快，但是竟然多敲了几个没用的字符导致WA掉了，会范这种错误表示最近状态不宜写算法题啊</p></div><div class=article-more><a href=//owent.net/2010/25.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-06-24T06:59:25.000+00:00 itemprop=datePublished>2010-06-24</time></div></div></article><article class="article-panel archive-article archive-type-26"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/26.html target=_blank itemprop=url>C#格式化输出(记录)</a></h1></header><div class=article-summary><pre><code class=language-cs>int a = 12345678;
//格式为sring输出
Label1.Text = string.Format(&quot;asdfadsf{0}adsfasdf&quot;,a);
Label2.Text = &quot;asdfadsf&quot;+a.ToString()+&quot;adsfasdf&quot;;
Label1.Text = string.Format(&quot;asdfadsf{0:C}adsfasdf&quot;,a);//asdfadsf￥1,234.00adsfasdf
Label2.Text = &quot;asdfadsf&quot;+a.ToString(&quot;C&quot;)+&quot;adsfasdf&quot;;//asdfadsf￥1,234.00adsfasdf
double b = 1234.12543;
int a = 12345678;
//格式为特殊的string样式输出
Label1.Text = string.Format(&quot;asdfadsf{0:C}adsfasdf&quot;,b);//asdfadsf￥1,234.13adsfasdf
Label2.Text = &quot;asdfadsf&quot;+b.ToString(&quot;C&quot;)+&quot;adsfasdf&quot;;//asdfadsf￥1,234.13adsfasdf
Label1.Text = string.Format(&quot;{0:C3}&quot;,b);//￥1,234.125
Label2.Text = b.ToString(&quot;C3&quot;);//￥1,234.125
Label1.Text = string.Format(&quot;{0:d}&quot;,a);//十进制--12345678
Label2.Text = b.ToString(&quot;d&quot;);//十进制--相同的类型，转换报错
Label1.Text = string.Format(&quot;{0:e}&quot;,a);//指数--1.234568e+007
Label2.Text = b.ToString(&quot;e&quot;);//指数--1.234125e+003
Label1.Text = string.Format(&quot;{0:f}&quot;,a);//定点数--12345678.00
Label2.Text = b.ToString(&quot;f&quot;);//定点数--1234.13
Label1.Text = string.Format(&quot;{0:n}&quot;,a);//数值--12,345,678.00
Label2.Text = b.ToString(&quot;n&quot;);//数值--1,234.13
Label1.Text = string.Format(&quot;{0:x}&quot;,a);//十六进制--bc614e
Label2.Text = b.ToString(&quot;x&quot;);//16--带有小数不能转换，出错
Label1.Text = string.Format(&quot;{0:g}&quot;,a);//通用为最紧凑--12345678
Label2.Text = b.ToString(&quot;g&quot;);//通用为最紧凑--1234.12543
Label1.Text = string.Format(&quot;{0:r}&quot;,a);//转来转去不损失精度--整数不允许用，报错
Label2.Text = b.ToString(&quot;r&quot;);//转来转去不损失精度--1234.12543
double b = 4321.12543;
int a = 1234;
自定义模式输出：
//&quot;0&quot;描述：占位符，如果可能，填充位
Label1.Text = string.Format(&quot;{0:000000}&quot;,a);// 001234
Label2.Text = string.Format(&quot;{0:000000}&quot;,b);// 004321
//&quot;#&quot;描述：占位符，如果可能，填充位
Label1.Text = string.Format(&quot;{0:####### }&quot;,a);// 1234
Label2.Text = string.Format(&quot;{0:####### }&quot;,b);// 4321
Label1.Text = string.Format(&quot;{0:#0#### }&quot;,a);// 01234
Label2.Text = string.Format(&quot;{0:0#0000}&quot;,b);// 004321
//&quot;.&quot;描述：小数点
Label1.Text = string.Format(&quot;{0:000.000}&quot;,a);//1234.000
Label2.Text = string.Format(&quot;{0:000.000}&quot;,b);//4321.125
double b = 87654321.12543;
int a = 12345678;
//&quot;,&quot;描述：数字分组，也用于增倍器
Label1.Text = string.Format(&quot;{0:0,00}&quot;,a);// 12,345,678
Label2.Text = string.Format(&quot;{0:0,00}&quot;,b);// 87,654,32
Label1.Text = string.Format(&quot;{0:0,}&quot;,a);// 12346
Label2.Text = string.Format(&quot;{0:0,}&quot;,b);// 87654
Label1.Text = string.Format(&quot;{0:0,,}&quot;,a);// 12
Label2.Text = string.Format(&quot;{0:0,,}&quot;,b);// 88
Label1.Text = string.Format(&quot;{0:0,,,}&quot;,a);// 0
Label2.Text = string.Format(&quot;{0:0,,,}&quot;,b);// 0
//&quot;%&quot;描述：格式为百分数
Label1.Text = string.Format(&quot;{ 0:0% }&quot;,a);// 1234567800%
Label2.Text = string.Format(&quot;{ 0:#% }&quot;,b);// 8765432113%
Label1.Text = string.Format(&quot;{ 0:0.00% }&quot;,a);// 1234567800.00%
Label2.Text = string.Format(&quot;{ 0:#.00% }&quot;,b);// 8765432112.54%
//&quot;abc&quot;描述：显示单引号内的文本
Label1.Text = string.Format(&quot;{0:'文本'0}&quot;,a);// 文本12345678
Label2.Text = string.Format(&quot;{0:文本0}&quot;,b);// 文本87654321
//&quot;\&quot;描述：后跟1要打印字的字符，也用于转移符\n等
Label1.Text = string.Format(&quot;\&quot;你好！\&quot;&quot;);// &quot;你好！&quot;
Label2.Text = string.Format(&quot;[url=file://\\c\\books\\new\\we.asp]\\c\\books\\new\\we.asp&quot;);//\c\books\new\we.asp
//&quot;@&quot;描述：后跟要打印字的字符,
Label1.Text = string.Format(@&quot;&quot;&quot;你好！&quot;&quot;&quot;); // &quot;你好！&quot;要打印&quot;则需要输入两对才可以
Label2.Text = string.Format(@&quot;\c\books\new\we.asp&quot;);//\c\books\new\we.asp 
</code></pre></div><div class=article-more><a href=//owent.net/2010/26.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-06-08T05:39:06.000+00:00 itemprop=datePublished>2010-06-08</time></div></div></article><article class="article-panel archive-article archive-type-27"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/27.html target=_blank itemprop=url>USACO 2008 March Gold Cow Jogging 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://202.120.106.94/onlinejudge/problemshow.php?pro_id=143">http://202.120.106.94/onlinejudge/problemshow.php?pro_id=143</a></p><p>这道题嘛，怎么说呢，好吧中等题</p><p>要求算出下山的前k短路的路长度</p><p>由于一定是下山所以可以用邻接表记录路径，然后用一个优先队列记录已有的到n的路长度</p></div><div class=article-more><a href=//owent.net/2010/27.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-06-02T17:31:57.000+00:00 itemprop=datePublished>2010-06-02</time></div></div></article><article class="article-panel archive-article archive-type-28"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/28.html target=_blank itemprop=url>POJ PKU 3659 Cell Phone Network 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3659">http://acm.pku.edu.cn/JudgeOnline/problem?id=3659</a></p><p>这题不算难题了，基本算是中等题</p><p>题目大意是给出一颗树，在一些点建一个信号塔，信号塔覆盖范围是其所在点和邻近点，问最少几个信号塔可以覆盖全区域</p></div><div class=article-more><a href=//owent.net/2010/28.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-06-01T15:51:00.000+00:00 itemprop=datePublished>2010-06-01</time></div></div></article><article class="article-panel archive-article archive-type-29"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/29.html target=_blank itemprop=url>浙江理工 省赛总结 team62 By OWenT of Coeus</a></h1></header><div class=article-summary><p>这次比赛成绩比预期差</p><p>开始Ultramanhu调整IDE</p><p>Q Boy从头开始看题</p><p>我的任务是倒数看题，最后看的题目是J，I，H，G</p><p>我看完J觉得J可做（哈密顿回路），但是需要很长时间。就首先放着继续看题</p></div><div class=article-more><a href=//owent.net/2010/29.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-05-10T16:45:14.000+00:00 itemprop=datePublished>2010-05-10</time></div></div></article><article class="article-panel archive-article archive-type-30"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/30.html target=_blank itemprop=url>树状数组模块(个人模板)</a></h1></header><div class=article-summary><p>树状数组模块</p><p>ACM个人模板</p><p>POJ 2155 题目测试通过</p><pre><code class=language-cpp>/**
 * 树状数组模块
 * 下标从0开始
 */
typedef long DG_Ran;
typedef long DG_Num;
const DG_Num DG_MAXN = 1005;

//2^n
DG_Num LowBit(DG_Num n)
{
    return n &amp; (-n);
}
//获取父节点索引
DG_Num DGFather(DG_Num n)
{
    return n + LowBit(n + 1);
}
//获取小的兄弟节点索引
DG_Num DGBrother(DG_Num n)
{
    return n - LowBit(n + 1);
}
//查找增加树状数组前pos项和
//参数(树状数组[in],索引[in],初始赋0即查找前n项和[out])
//复杂度:log(n)
void DGFind(DG_Ran *g,DG_Num pos,DG_Ran &amp;sum)
{
    sum += *(g + pos);
    if(pos &gt;= LowBit(pos + 1))
        DGFind(g, pos - LowBit(pos + 1), sum);
}
//查找对应线性数组元素
//参数(树状数组[in],索引[in]).
//返回值:对应线性数组元素log(n)
//复杂度:log(n)
DG_Ran DGFindEle(DG_Ran *g,DG_Num pos)
{
    DG_Ran a = 0 , b = 0;
    DGFind(g, pos, a);
    if(pos)
    {
        DGFind(g,pos - 1,b);
        return a - b;
    }
    else
        return a;
}
//树状数组,增加节点
//参数:树状数组[out],原数组大小[in],新增线性数组值[in]
//复杂度:log(n)
DG_Ran DGAdd(DG_Ran *g,DG_Num n,DG_Ran val)
{
    *(g + n) = val;
    DG_Num a = n;
    DG_Num b = 1;
    while((a &amp; (~b)) != a)
    {
        *(g + n) += *(g + a - 1);
        a &amp;= (~b);
        b &lt;&lt;= 1;
    }
    return n + 1;
}
//构建树状数组
//参数:线性数组[in],数组大小[in],树状数组[out]
//复杂度:nlog(n)
DG_Ran DGCreate(DG_Ran *g,DG_Num n,DG_Ran *tg)
{
    DG_Num i;
    *tg = *g;
    for(i = 1 ; i &lt; n ; i ++)
        DGAdd(tg,i,*(g + i));
    return n;
}
//修改指定位置值
//参数:线性数组[in],数组位置[in],数组大小[in],新值[in]
//复杂度:log(n)
DG_Ran DGEdit(DG_Ran *g,DG_Num pos,DG_Num n,DG_Ran val)
{
    DG_Num f = DGFather(pos);
    DG_Ran o = *( g + pos );
    *( g + pos ) = val;
    if(f &lt; n)
    {
        DG_Ran fv = val - o + *( g + f );
        DGEdit(g, f, n, fv);
    }
    return n;
}

//树状数组的翻转(树状数组的应用)
//一维  复杂度log(n)
//小于等于指定位置的元素的翻转&lt;=pos
void DGDown1(DG_Ran g[],DG_Num pos,DG_Ran av)
{
    while(pos &gt;= 0)
        g[pos] += av , pos = DGBrother(pos);
}
//获取位置pos的元素翻转次数
DG_Ran DGCUp1(DG_Ran g[],DG_Num pos , DG_Num n)
{
    DG_Ran t = 0;
    while(pos &lt; n)
        t += g[pos] , pos = DGFather(pos);
    return t;
}
//二维  复杂度(log(n))^2
//小于等于指定位置的元素的翻转(0,0)-&gt;(x,y)
void DGDown2(DG_Ran g[][DG_MAXN],DG_Num x ,DG_Num y,DG_Ran av)
{
    while(x &gt;= 0)
    {
        DG_Num tmp = y;
        while (tmp &gt;= 0)
        {
            g[x][tmp] += av;
            tmp = DGBrother(tmp);
        }
        x = DGBrother(x);
    }
}
//获取位置(x,y)的元素翻转次数
DG_Ran DGCUp2(DG_Ran g[][DG_MAXN],DG_Num x ,DG_Num y , DG_Num n)
{
    DG_Ran t = 0;
    while(x &lt; n)
    {
        DG_Num tmp = y;
        while (tmp &lt; n)
        {
            t += g[x][tmp];
            tmp = DGFather(tmp);
        }
        x = DGFather(x);
    }
    return t;
}
</code></pre></div><div class=article-more><a href=//owent.net/2010/30.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-05-06T13:51:29.000+00:00 itemprop=datePublished>2010-05-06</time></div></div></article><article class="article-panel archive-article archive-type-31"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/31.html target=_blank itemprop=url>HDU HDOJ 3398 String 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3398">http://acm.hdu.edu.cn/showproblem.php?pid=3398</a></p><p>题目要我们计算1，0的排列方式总数，并且对任意长的字符串，1的数量大于等于0的数量</p><p>我们可以把题目转化为从（0，0）点到（m，n）点的方法总数，且路径不经过y=x-1这条直线</p></div><div class=article-more><a href=//owent.net/2010/31.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-05-05T16:51:22.000+00:00 itemprop=datePublished>2010-05-05</time></div></div></article><article class="article-panel archive-article archive-type-32"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/32.html target=_blank itemprop=url>线性筛法求质数(素数)表 及其原理</a></h1></header><div class=article-summary><pre><code class=language-cpp>/**
 * 线性筛法求素数表
 * 复杂度: O(n)
 */
const long MAXP = 1000000;
long prime[MAXP] = {0},num_prime = 0;
int isNotPrime[MAXP] = {1, 1};
void GetPrime_Init()//初始化调用
{
    for(long i = 2 ; i &lt;  MAXP ; i ++)
    {
        if(! isNotPrime[i])
            prime[num_prime ++]=i;
        for(long j = 0 ; j &lt; num_prime &amp;&amp; i * prime[j] &lt;  MAXP ; j ++)
        {
            isNotPrime[i * prime[j]] = 1;
            if( !(i % prime[j]))
                break;
        }
    }
}
</code></pre><p>线性筛法,即是筛选掉所有合数,留下质数</p></div><div class=article-more><a href=//owent.net/2010/32.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-05-03T11:20:33.000+00:00 itemprop=datePublished>2010-05-03</time></div></div></article></div><hr><nav id=page-nav><ul class=pagination><li class=page-item><a class=page-link href=../page/9.html>&#171;上一页</a></li><li class=page-item><a class=page-link href=../>1</a></li><li class=page-item><a class=page-link href=../page/2.html>2</a></li><li class=page-item><a class=page-link href=../page/3.html>3</a></li><li class=page-item><a class=page-link href=../page/4.html>4</a></li><li class=page-item><a class=page-link href=../page/5.html>5</a></li><li class=page-item><a class=page-link href=../page/6.html>6</a></li><li class=page-item><a class=page-link href=../page/7.html>7</a></li><li class=page-item><a class=page-link href=../page/8.html>8</a></li><li class=page-item><a class=page-link href=../page/9.html>9</a></li><li class='page-item disabled'><a class=page-link href=../page/10.html>10</a><span class=sr-only>(current)</span></li><li class=page-item><a class=page-link href=../page/11.html>11</a></li><li class=page-item><a class=page-link href=../page/12.html>12</a></li><li class=page-item><a class=page-link href=../page/13.html>13</a></li><li class=page-item><a class=page-link href=../page/11.html>下一页&#187;</a></li></ul></nav></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>
2024
OWenT
</strong><strong id=footer-right class="float-right float-end"><a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=module>
import * as Popper from "@popperjs/core";
import * as bootstrap from 'bootstrap';
// import React from "react";

</script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/katex@latest/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
import mermaid from "mermaid";
const config = {
    theme: 'neutral',
    logLevel: 'fatal',
    securityLevel: 'loose', 
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    

};
mermaid.initialize(config);
</script></div></body></html>