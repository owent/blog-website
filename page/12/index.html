<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.154.0"><meta charset=utf-8><title>I'm OWenT|I'm OWenT</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/index.html><link rel=alternate type=application/rss+xml href=//owent.net/index.xml title="I'm OWenT"><link rel=icon href=/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta content="codeva-4M5iohb9TW" name=baidu-site-verification></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/index.html title=Home>Home</a></li><li class=nav-item><a class=nav-link href=/archives/index.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=/about/index.html title=About>About</a></li><li class=nav-item><a id=nav-rss-link class=nav-link href=//owent.net/index.xml title=RSS订阅>RSS订阅</a></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=index-content><article class="article-panel archive-article archive-type-53"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/53.html target=_blank itemprop=url>ZOJ 3309 Search New Posts 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3309">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3309</a></p><p>一道典型的Hash题</p><p>题目很好理解。这里不复述</p><p>由于输入语句最大数量200000，不用Hash铁定TLE。然后数据量不超过10000，所以必然有很多search和reply的操作。</p></div><div class=article-more><a href=//owent.net/2010/53.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-15T14:49:52.000+00:00 itemprop=datePublished>2010-03-15</time></div></div></article><article class="article-panel archive-article archive-type-54"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/54.html target=_blank itemprop=url>Hash模板 个人模板</a></h1></header><div class=article-summary><pre><code class=language-cpp>/**
 * Hash模板
 * Based: 0
 * template&lt;unsigned long _SZ,class _T, unsigned long *pFun(_T _Off)&gt;
 * class _My_Hash_ToInt
 * 传入数据大小_SZ,传入类型_T,Hash函数
 * 传入类型_T必须重载 = 和 == 符号
 * 收录了ELFHash函数
 * 主要是为了判重的简化些的模板
 * Hash算法性能比较见 http://www.cnblogs.com/lonelycatcher/archive/2011/08/23/2150587.html
 */

const long hashsize = 51071; //Hash表大小(注意修改)
// 各种Hash算法
unsigned int SDBMHash(char *str)
{
    unsigned int hash = hashsize;

    while (*str)
    {
        // equivalent to: hash = 65599*hash + (*str++);
        hash = (*str++) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;
    }

    return (hash &amp; 0x7FFFFFFF);
}

// RS Hash Function
unsigned int RSHash(char *str)
{
    unsigned int b = 378551;
    unsigned int a = 63689;
    unsigned int hash = hashsize;

    while (*str)
    {
        hash = hash * a + (*str++);
        a *= b;
    }

    return (hash &amp; 0x7FFFFFFF);
}

// JS Hash Function
unsigned int JSHash(char *str)
{
    unsigned int hash = 1315423911;

    while (*str)
    {
        hash ^= ((hash &lt;&lt; 5) + (*str++) + (hash &gt;&gt; 2));
    }

    return (hash &amp; 0x7FFFFFFF);
}

// P. J. Weinberger Hash Function
unsigned int PJWHash(char *str)
{
    unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8);
    unsigned int ThreeQuarters    = (unsigned int)((BitsInUnignedInt  * 3) / 4);
    unsigned int OneEighth        = (unsigned int)(BitsInUnignedInt / 8);
    unsigned int HighBits         = (unsigned int)(0xFFFFFFFF) &lt;&lt; (BitsInUnignedInt - OneEighth);
    unsigned int hash             = hashsize;
    unsigned int test             = 0;

    while (*str)
    {
        hash = (hash &lt;&lt; OneEighth) + (*str++);
        if ((test = hash &amp; HighBits) != 0)
        {
            hash = ((hash ^ (test &gt;&gt; ThreeQuarters)) &amp; (~HighBits));
        }
    }

    return (hash &amp; 0x7FFFFFFF);
}

// ELF Hash Function
unsigned int ELFHash(char *str)
{
    unsigned int hash = hashsize;
    unsigned int x    = 0;

    while (*str)
    {
        hash = (hash &lt;&lt; 4) + (*str++);
        if ((x = hash &amp; 0xF0000000L) != 0)
        {
            hash ^= (x &gt;&gt; 24);
            hash &amp;= ~x;
        }
    }

    return (hash &amp; 0x7FFFFFFF);
}

// BKDR Hash Function
unsigned int BKDRHash(char *str)
{
    unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
    unsigned int hash = hashsize;

    while (*str)
    {
        hash = hash * seed + (*str++);
    }

    return (hash &amp; 0x7FFFFFFF);
}

// DJB Hash Function
unsigned int DJBHash(char *str)
{
    unsigned int hash = 5381;

    while (*str)
    {
        hash += (hash &lt;&lt; 5) + (*str++);
    }

    return (hash &amp; 0x7FFFFFFF);
}

// AP Hash Function
unsigned int APHash(char *str)
{
    unsigned int hash = hashsize;
    int i;

    for (i=0; *str; i++)
    {
        if ((i &amp; 1) == 0)
        {
            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));
        }
        else
        {
            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));
        }
    }

    return (hash &amp; 0x7FFFFFFF);
}

// 程序模板
template&lt;typename _T&gt;
class _My_Hash_ToInt_Data
{
public:
    _My_Hash_ToInt_Data()
    {
        times = 0;
        next = -1;
    }
    _T data;
    long times;
    long next;
};
template&lt;long _SZ,class _T, unsigned long pFun(_T&amp; _Off)&gt;
class _My_Hash_ToInt
{
public:
    _My_Hash_ToInt()
    {
        memset(hash, -1, sizeof(hash));
        length = 0;
    };
    ~_My_Hash_ToInt(){};
    long find(_T _Off)
    {
        long pos = hash[pFun(_Off)];
        while(pos &gt;= 0)
        {
            if(data[pos].data == _Off)
                return pos;
            else
                pos = data[pos].next;
        }
        return -1;
    }
    long insert(_T _Off)
    {
        long oldPos = pFun(_Off);
        long pos = hash[oldPos];
        while(pos &gt;= 0)
        {
            if(data[pos].data == _Off)
            {
                data[pos].times ++;
                return pos;
            }
            else
                pos = data[pos].next;
        }
        data[length].data = _Off;
        data[length].times = 1;
        data[length].next = hash[oldPos];
        hash[oldPos] = length ;
        return length ++;
    }
    void clear()
    {
        length = 0;
        memset(hash, -1, sizeof(hash));
        memset(data, -1, sizeof(data));
    }
    //Member
    long length;
    _My_Hash_ToInt_Data&lt;_T&gt; data[_SZ];
    long hash[hashsize];
};

//节点类（注意修改）
class node
{
public:
    char str[60];
    bool operator == (node &amp;strin)
    {
        return !strcmp(str, strin.str);
    }
    node&amp; operator = (node &amp;strin)
    {
        strcpy(str, strin.str);
        return (*this);
    }
};
//扩展Hash函数（注意修改）
unsigned long ELFHashEx(node &amp;strIn)
{
    return ELFHash(strIn.str);
}
_My_Hash_ToInt&lt;10005, node, ELFHashEx&gt;hash;//Hash类例子
</code></pre></div><div class=article-more><a href=//owent.net/2010/54.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-15T12:58:47.000+00:00 itemprop=datePublished>2010-03-15</time></div></div></article><article class="article-panel archive-article archive-type-55"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/55.html target=_blank itemprop=url>HDU 3336 Count the string 解题报告</a></h1></header><div class=article-summary><p>题目：
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3336">http://acm.hdu.edu.cn/showproblem.php?pid=3336</a></p><p>水题一道，主要是测试数据很水</p><p>不解释，贴代码：</p><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
using namespace std;

char str[200005];
vector&lt;long&gt;glo_Pos;
int main()
{
    int t;
    long output,i,n,j;
    scanf(&quot;%d&quot;,&amp;t);
    while(t --)
    {
        output = 0;
        glo_Pos.clear();
        scanf(&quot;%ld %s&quot;, &amp;n, str);

        for(i = 0; i &lt; n; i ++)
        {
            if(str[i] == str[0])
            {
                glo_Pos.push_back(i);
                output ++;
            }
        }
        output = output % 10007;
        for(i = 1; i &lt; n; i ++)
        {
            for(j = 0; j &lt; glo_Pos.size();j ++)
            {
                if(str[i] == str[glo_Pos[j] + i])
                    output = (output + 1) % 10007;
                else
                {
                    glo_Pos.erase(glo_Pos.begin() + j);
                    j --;
                }
            }
        }

        printf(&quot;%ld\n&quot;, output);
    }
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2010/55.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-03-15T11:12:56.000+00:00 itemprop=datePublished>2010-03-15</time></div></div></article><article class="article-panel archive-article archive-type-57"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/57.html target=_blank itemprop=url>POJ PKU 1065 Wooden Sticks 3636 Nested Dolls 解题报告</a></h1></header><div class=article-summary><p>3636 Nested Dolls</p><p>题目链接：[http://acm.pku.edu.cn/JudgeOnline/problem?id=3636</p><p>](<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3636">http://acm.pku.edu.cn/JudgeOnline/problem?id=3636</a>)好吧，这题我看了解题报告。而且解题报告有错误的。只考虑w递增，没考虑w值相等的情况。</p><p>我自己这里加进去了判断。主要是看解题报告后才知道数据这么弱，就按他的写了</p></div><div class=article-more><a href=//owent.net/2010/57.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-02-24T15:43:54.000+00:00 itemprop=datePublished>2010-02-24</time></div></div></article><article class="article-panel archive-article archive-type-58"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/58.html target=_blank itemprop=url>POJ PKU 3631 Cuckoo Hashing 解题报告</a></h1></header><div class=article-summary><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3631">http://acm.pku.edu.cn/JudgeOnline/problem?id=3631</a></p><p>我讨厌这么长的题目</p><p>这题是模拟那个Hash算法，有点像我之前转载的那篇文章里提到的Hash</p><p><a href=https://www.owent.net/2009/87.html>打造最快的Hash表(转) [以暴雪的游戏的Hash为例]</a> 这里是用两个Hash函数算出两个Hash值h1和h2，如果h1位置已经被占用就检查h2位置，如果都被占用就把原来的替换掉再给原来的字符串重新计算映射。这样下去可能出现死循环。会出现死循环就输出</p></div><div class=article-more><a href=//owent.net/2010/58.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-02-24T10:14:57.000+00:00 itemprop=datePublished>2010-02-24</time></div></div></article><article class="article-panel archive-article archive-type-59"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2010/59.html target=_blank itemprop=url>POJ PKU 2596 Dice Stacking 解题报告</a></h1></header><div class=article-summary><p>状态压缩+DP</p><p>1972的增强版</p><p>题目链接：<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2596">http://acm.pku.edu.cn/JudgeOnline/problem?id=2596</a></p><p>题意是给出小于10个的骰子，要求竖着叠成一条，而且每两个相接的骰子相接的面的数字相同</p><p>求侧面数字的最大和。如果叠不出来输出0</p></div><div class=article-more><a href=//owent.net/2010/59.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2010-02-19T12:31:50.000+00:00 itemprop=datePublished>2010-02-19</time></div></div></article><article class="article-panel archive-article archive-type-63"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/63.html target=_blank itemprop=url>POJ PKU 1990 MooFest 解题报告</a></h1></header><div class=article-summary><p>为什么我用线段数这么不灵活呢？</p><p>大概思路是线段数记录某牛之前的坐标小于这个牛的牛的坐标和和牛的个数</p><p>然后其他部分线性数组记录</p><p>OK，贴代码</p><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

#define MAXN 20005
class cow
{
public:
    int v;
    int pos;
    cow(){};
    ~cow(){};
};

bool cmp(cow a,cow b)
{
    return a.v &lt; b.v;
}
cow cw[MAXN];
long long belowXNT[MAXN];//树状数组，保存小于等于某坐标的牛的个数,计算时使用
long long belowXN[MAXN];//一般数组，保存小于等于某坐标和索引的牛的个数
long long velowXRT[MAXN];//树状数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和,计算时使用
long long velowXR[MAXN];//一般数组，保存索引小于等于某的牛且坐标也小于它的牛的坐标之和
long long velowXRA[MAXN];//一般数组，保存小于等于某牛的坐标之和

int lowbit(int t)
{
    return t&amp;(t^(t-1));
}
void setVal(int pos, int num, long long treeG[], int maxn)
{
    while (pos &lt;= maxn)
    {
        treeG[pos] += num;
        pos += lowbit(pos);
    }
}
long long getSum(int pos, long long treeG[])
{
    long long sum = 0;
    while (pos &gt; 0)
    {
        sum += treeG[pos];
        pos -= lowbit(pos);
    }
    return sum;
}



int main()
{
    int i,n;
    long long output = 0;
    memset(belowXN, 0, sizeof(belowXN));
    memset(belowXNT, 0, sizeof(belowXN));
    memset(velowXR, 0, sizeof(velowXR));
    memset(velowXRA, 0, sizeof(velowXRA));
    memset(velowXRT, 0, sizeof(velowXRT));
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 0 ; i &lt; n ; i ++)
        scanf(&quot;%d %d&quot;, &amp;cw[i].v, &amp;cw[i].pos);

    sort(cw, cw + n, cmp);
    for(i = 0 ; i &lt; n ; i ++)
    {
        velowXRA[i] = velowXRA[i - 1] + cw[i].pos;
        setVal(cw[i].pos, 1, belowXNT, MAXN);
        setVal(cw[i].pos, cw[i].pos, velowXRT, MAXN);
        velowXR[i] = getSum(cw[i].pos, velowXRT);
        belowXN[i] = getSum(cw[i].pos, belowXNT);
    }

    for(i = 1 ; i &lt; n ; i ++)
        //output += cw[i].v * ((belowXN[i] - 1) * cw[i].pos - velowXR[i] + cw[i].pos + velowXRA[i] - velowXR[i] - (i - belowXN[i] + 1) * cw[i].pos);
        output += cw[i].v * ((belowXN[i] - i + belowXN[i] - 1 ) * cw[i].pos - 2 * velowXR[i] + velowXRA[i]);//这里是上面式子的简化版

    printf(&quot;%lld\n&quot;,output);
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/63.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-12-23T14:12:52.000+00:00 itemprop=datePublished>2009-12-23</time></div></div></article><article class="article-panel archive-article archive-type-64"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/64.html target=_blank itemprop=url>POJ PKU 2378 Tree Cutting 解题报告</a></h1></header><div class=article-summary><p>又来发解题报告了</p><p>这回是树状DP</p><pre><code class=language-cpp>/*
 * 树状DP
 * 首先把数据想象成树状的
 * 由于输入数据为树状，不需要构建树
 * 可令degree[i]为包括i且以i为根节点的所有子节点数量
 * dp[i]为删除i后的最大子节点数量或父亲节点数量 （这里我理解了很久）
 */
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt;chirld[10002];
int dp[10002] = {0}
    ,degree[10002] = {0}
    ,isJudged[10002] = {0};

int search(int pos,int &amp;n);
int main()
{
    int n,i,a,b;
    bool isnone = true;
    scanf(&quot;%d&quot;,&amp;n);
    for(i = 1 ; i &lt; n ; i ++)
    {
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        chirld[a].push_back(b);
        chirld[b].push_back(a);
    }

    search(1 , n);

    for(i = 1 ; i &lt;= n ; i ++)
        if(dp[i] * 2 &lt;= n)
            printf(&quot;%d\n&quot;,i) , isnone = false;

    if(isnone)
        printf(&quot;NONE\n&quot;);
    return 0;
}

int search(int pos,int &amp;n)
{
    int i,j;
    degree[pos] = 1;
    isJudged[pos] = 1;
    dp[pos] = 0;

    for(i = 0 ; i &lt; chirld[pos].size() ; i ++)
    {
        if(!isJudged[chirld[pos].at(i)])//如果已经判断过就是父亲节点了
        {
            degree[pos] += search(chirld[pos].at(i) , n);
            if(dp[pos] &lt; degree[chirld[pos].at(i)])
                dp[pos] = degree[chirld[pos].at(i)];
        }
    }

    if(dp[pos] &lt; n - degree[pos])//判断父亲节点数量
        dp[pos] = n - degree[pos];
    return degree[pos];
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/64.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-12-23T14:09:13.000+00:00 itemprop=datePublished>2009-12-23</time></div></div></article><article class="article-panel archive-article archive-type-65"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/65.html target=_blank itemprop=url>POJ PKU 2528 Mayor's posters 解题报告</a></h1></header><div class=article-summary><p>题目链接: <a href="http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528">http://acm.pku.edu.cn/JudgeOnline/bbs?problem_id=2528</a></p><p>这题又是线段树+离散化</p><p>慢慢的对离散化有点感觉了,但是这题我还是错了3次</p><p>题目大意是一层一层地叠板子,问最后能看到几块</p><p>输入是板子的开始和结束位置</p></div><div class=article-more><a href=//owent.net/2009/65.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-18T17:49:55.000+00:00 itemprop=datePublished>2009-11-18</time></div></div></article><article class="article-panel archive-article archive-type-66"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/66.html target=_blank itemprop=url>我的ACM生涯</a></h1></header><div class=article-summary><p>在ACM的竞技场上走过了一年。这一年是充满艰难的一年，这一年是充满困惑的一年。这也是充满激情的一年。这之间有欢笑，有惊喜,也有黯然失色的悲伤.苦战一年，却没有拿到任何的成绩， regional的失败让我刻骨铭心也深深感受到了实力的差距。伤感之余也让我想起了我们ECUST的ACM之歌,我又看了一遍，每次看这篇文章都会有种说不出的感动与激情。让我有了继续走下去的力量。明年，再战ACM，等着我们，我们要成为明年名副其实的ACMer。</p></div><div class=article-more><a href=//owent.net/2009/66.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-17T17:57:31.000+00:00 itemprop=datePublished>2009-11-17</time></div></div></article><article class="article-panel archive-article archive-type-67"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/67.html target=_blank itemprop=url>POJ PKU 3277 City Horizon 解题报告</a></h1></header><div class=article-summary><p>题目链接:<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3277">http://acm.pku.edu.cn/JudgeOnline/problem?id=3277</a></p><p>线段树+离散化</p><p>ACM预选赛过去了,可是我们队什么都没拿到,这给我们的打击是相当大的,这也很大程度上体现了我们的不足</p><p>一直没能静下心,来,今天决定不能再这么悲伤下去,我要奋斗,继续学习,就从之前的断点线段树开始</p></div><div class=article-more><a href=//owent.net/2009/67.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-11-12T17:23:39.000+00:00 itemprop=datePublished>2009-11-12</time></div></div></article><article class="article-panel archive-article archive-type-69"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/69.html target=_blank itemprop=url>POJ PKU 2549 Sumsets 解题报告</a></h1></header><div class=article-summary><p><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2549">题目链接http://acm.pku.edu.cn/JudgeOnline/problem?id=2549</a></p><p>这道题伤了我很久脑筋</p><p>因为是a+b+c=d,数据量是1000,很自然地想到a+b=d-c</p><p>这样转化为n^2的算法.</p><p>但是我开始枚举d-c的集合二分查找a+b的几何不知道为什么WA掉了</p></div><div class=article-more><a href=//owent.net/2009/69.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-10-04T15:54:36.000+00:00 itemprop=datePublished>2009-10-04</time></div></div></article><article class="article-panel archive-article archive-type-74"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/74.html target=_blank itemprop=url>最长单调子序列 复杂度nlog(n)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//最长单调子序列 复杂度nlog(n)
//参数(原序列,序列长度,生成的序列),传入序列长度必须大于0
//返回值中lengthRecord中前k项表示长度为k的最小字序列
//LIScmp为关系函数,原函数表明lengthRecord为递增(不含等于)
typedef double LISTYPE;
#define LISMAXN 10000
int LIScmp(LISTYPE a,LISTYPE b)
{
    return a &lt; b;
}
long LISLength(LISTYPE list[],long n,LISTYPE lengthRecord[])
{
    long length = 1,lth;
    LISTYPE lR[LISMAXN];
    lR[0] = list[0];

    for(int i = 1 ; i &lt; n ; i ++)
    {
        //二分查找,复杂度 log(n)
        int b,e,m;
        b = 0;
        e = length - 1;
        while(b &lt;= e &amp;&amp; e &gt;= 0)
        {
            m = (b + e) / 2;
            if(LIScmp(lR[m],list[i]))
                b = m + 1;
            else
                e = m - 1;
        }
        lR[b] = list[i];
        if(b &gt;= length)
            length ++;
    }
    /*
    *计算序列部分
    *复杂度nlog(n)
    */
    lth = 1;
    for(int i = 1 ; i &lt; n ; i ++)
    {
        //二分查找,复杂度 log(n)
        int b,e,m;
        b = 0;
        e = lth - 1;
        while(b &lt;= e &amp;&amp; e &gt;= 0)
        {
            m = (b + e) / 2;
            if(LIScmp(lR[m],list[i]))
                b = m + 1;
            else
                e = m - 1;
        }
        lR[b] = list[i];
        if(b &gt;= lth)
            lth ++;
        if(lth == length)
        {
            for(b = 0 ; b &lt; length ; b ++)
                lengthRecord[b] = lR[b];
            break;
        }
    }
    //计算序列部分代码与之前的类似,可以直接Copy然后修改
    return length;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/74.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-16T04:44:59.000+00:00 itemprop=datePublished>2009-09-16</time></div></div></article><article class="article-panel archive-article archive-type-75"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/75.html target=_blank itemprop=url>Prime最小生成树(个人模板)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//Prime连通路模块
#define N 1000         //最大数据规模
#define MAXNUM 3000000   //最大路径长度
typedef double PrimeType;//路径类型

PrimeType PrimeRecord[N];
PrimeType dis[N][N];
int isLined[N] = {1,0};

PrimeType GetPrimeLength(const long n)
{
    PrimeType tmpLen = MAXNUM;
    long tmpPos = 0,left = n - 1;
    PrimeType sumLen = 0;

    for(long i = 1 ; i &lt; n ; i ++)
        PrimeRecord[i] = dis[0][i];
    while(left --)
    {
        tmpLen = MAXNUM;
        for(long i = 1 ; i &lt; n ; i ++)
            if(!isLined[i] &amp;&amp; PrimeRecord[i] &lt; tmpLen)
                tmpPos = i,tmpLen = PrimeRecord[i];

        sumLen += tmpLen;
        isLined[tmpPos] ++;
        for(long i = 1 ; i &lt; n ; i ++)
            if(dis[tmpPos][i] &lt; PrimeRecord[i])
                PrimeRecord[i] = dis[tmpPos][i];
    }

    return sumLen;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/75.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-15T16:43:29.000+00:00 itemprop=datePublished>2009-09-15</time></div></div></article><article class="article-panel archive-article archive-type-76"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/76.html target=_blank itemprop=url>矩阵相关 (增强中)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//MULDATATYPE为矩阵元素类型,MAXMAT为最大矩阵大小

typedef long MULDATATYPE;
#define MAXMAT 100
#define inf 1000000000

#define fabs(x) ((x)&gt;0?(x):-(x))
#define zero(x) (fabs(x)&lt;1e-10)

struct mat
{
    long n,m;
    MULDATATYPE data[MAXMAT][MAXMAT];
    void operator =(const mat&amp; a);
    mat operator +(const mat&amp; a);
    mat operator -(const mat&amp; a);
    //0-1邻接矩阵
    mat operator &amp;(const mat&amp; a);
    mat operator |(const mat&amp; a);
};

//c=a*b
//注意引用
int Mat_MulMode(mat&amp; c,const mat&amp; a,const mat&amp; b,MULDATATYPE mod)
{
    long i,j,k;
    if (a.m != b.n)
        return 0;
    c.n = a.n , c.m = b.m;
    for (i = 0 ; i &lt; c.n ; i ++)
        for (j = 0 ; j &lt; c.m ; j ++)
            for (c.data[i][j] = k = 0 ; k  &lt; a.m ; k ++)
                c.data[i][j] = (c.data[i][j] + a.data[i][k] * b.data[k][j]) % mod;
    return 1;
}
//c=a^b(其中必须满足b&gt;0)
int Mat_PowMode(mat&amp; c,mat a,long b,MULDATATYPE mod)
{
    c = a;
    b --;
    while(b)
    {
        mat tmp;
        if(b &amp; 1)
        {
            tmp = c;
            Mat_MulMode(c,tmp,a,mod);
        }
        tmp = a;
        Mat_MulMode(a,tmp,tmp,mod);
        b = b&gt;&gt;1;
    }
    return 1;
}
//c=a+b
int Mat_AddMode(mat&amp; c,const mat&amp; a,const mat&amp; b,MULDATATYPE mod)
{
    long i,j;
    if (a.n != b.n || a.m != b.m)
        return 0;
    c.n = a.n , c.m = b.m;
    for (i = 0 ; i &lt; c.n ; i ++)
        for (j = 0 ; j &lt; c.m ; j ++)
            c.data[i][j] = (a.data[i][j] + b.data[i][j]) % mod;
    return 1;
}
//c=a-b
int Mat_SubMode(mat&amp; c,const mat&amp; a,const mat&amp; b,MULDATATYPE mod)
{
    long i,j;
    if (a.n != b.n || a.m != b.m)
        return 0;
    c.n = a.n , c.m = b.m;
    for (i = 0 ; i &lt; c.n ; i ++)
        for (j = 0 ; j &lt; c.m ; j ++)
            c.data[i][j] = (a.data[i][j] - b.data[i][j]) % mod;
    return 1;
}


void mat::operator =(const mat&amp; a)
{
    n = a.n;
    m = a.m;
    for(int i = 0 ; i &lt; n ; i ++)
        for(int j = 0 ; j &lt; m ; j ++)
            data[i][j] = a.data[i][j];
}
mat mat::operator +(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] + a.data[i][j];
    return tmpMat;
}
mat mat::operator -(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] - a.data[i][j];
    return tmpMat;
}
mat mat::operator &amp;(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] &amp; a.data[i][j];
    return tmpMat;
}
mat mat::operator |(const mat &amp;a)
{
    long i,j;
    mat tmpMat;
    tmpMat.m = m;
    tmpMat.n = n;
    for(i = 0 ; i &lt; n ; i ++)
        for(j = 0 ; j &lt; m ; j ++)
            tmpMat.data[i][j] = data[i][j] | a.data[i][j];
    return tmpMat;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/76.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-09-15T16:39:11.000+00:00 itemprop=datePublished>2009-09-15</time></div></div></article><article class="article-panel archive-article archive-type-77"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/77.html target=_blank itemprop=url>09年8月14日 ECUST ACM 练习赛总结</a></h1></header><div class=article-summary><p>今天在湖南的OJ上做题,发现不到两小时,他服务器就挂了,但是发现他和POJ上的一些题一样而且是连号的,就到POJ上继续了，我们队出了6题。</p><p>A题是<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3507">POJ的3507 Judging Olympia</a>这题是队友干掉的,我没看</p></div><div class=article-more><a href=//owent.net/2009/77.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-16T16:57:22.000+00:00 itemprop=datePublished>2009-08-16</time></div></div></article><article class="article-panel archive-article archive-type-78"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/78.html target=_blank itemprop=url>ECUST 09年 校赛个人赛第八场（最后一场）总结</a></h1></header><div class=article-summary><p>懒惰了，暂时休息一下</p><p>这次我只AC了一题（在结束的那一刻，另一题在题目来源地网站上AC了，我们的OJ上仍然WA，我们OJ的Special Judge真是—_—!）</p></div><div class=article-more><a href=//owent.net/2009/78.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:41:45.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-79"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/79.html target=_blank itemprop=url>ECUST 09年 校赛个人训练赛第五场总结</a></h1></header><div class=article-summary><h1 id=校赛个人训练赛第五场报告>校赛个人训练赛第五场报告</h1><p>今天战绩还行，AC了5题，今天总体没有太复杂的算法题，不过测试数据强度比之前有所增加
我的钱四题很早就过了，但是第五题很晚才出主要是代码写得太混乱，思路也错了两次
我过的题有五道，分别是ABCDG</p></div><div class=article-more><a href=//owent.net/2009/79.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:40:56.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-80"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/80.html target=_blank itemprop=url>点到直线距离 和 线段间最短距离 (OWenT 模板)</a></h1></header><div class=article-summary><p>点到直线距离</p><pre><code class=language-cpp>// (x0,y0)到(x1,y1)和(x2,y2)确定的直线的距离

double disBetweenPointAndLine(double x0,double y0,double x1,double y1,double x2,double y2)
{
    //化为ax+by+c=0的形式
    double a = y1-y2;
    double b = x2-x1;
    double c = x1*y2-x2*y1;
    double d = (a*x0+b*y0+c)/sqrt(a*a+b*b);
    /*
    如果是线段判断垂足

    double xp = (b*b*x0-a*b*y0-a*c)/(a*a+b*b);
    double yp = (-a*b*x0+a*a*y0-b*c)/(a*a+b*b);
    double xb = (x1&gt;x2)?x1:x2;
    double yb = (y1&gt;y2)?y1:y2;
    double xs = x1+x2-xb;
    double ys = y1+y2-yb;
    if(xp &gt; xb || xp &lt; xs || yp &gt; yb || yp &lt; ys)
    {
        d = sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
        if(d &gt; sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2)))
            d = sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2));
    }
    */
    return fabs(d);
}
</code></pre><p>线段间最短距离</p></div><div class=article-more><a href=//owent.net/2009/80.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:33:38.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article><article class="article-panel archive-article archive-type-81"><div class="article-panel-inner archive-article-inner"><header class="article-header archive-article-title"><h1 itemprop=name><a class=article-title href=//owent.net/2009/81.html target=_blank itemprop=url>连接最多点直线 (OWenT 个人模板)</a></h1></header><div class=article-summary><pre><code class=language-cpp>//n每个用例的点个数
//MAXN为最大点个数
//PTYPE为坐标值类型
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;

#define MAXN 1005
#define EPS 1e-10
typedef double PTYPE;

struct point
{
    PTYPE x,y;
};
struct node
{
    PTYPE k;
};
int cmp(const void * a, const void * b)
{
    return((*(PTYPE*)a-*(PTYPE*)b&gt;0)?1:-1);
}
node numK[MAXN * MAXN / 2];
point pt[MAXN];
int main()
{

    int n , maxNum = 1 , tmpNum = 0;
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {
        for(int i = 0 ; i &lt; n ; i ++)
            scanf(&quot;%lf %lf&quot;,&amp;pt[i].x,&amp;pt[i].y);
        for(int i = 0 ; i &lt;  n ; i ++)
        {
            int pos = 0;
            for(int j = i + 1 ; j &lt; n ; j ++)
                if((pt[i].x - pt[j].x) &gt; EPS)
                    numK[pos ++].k = (pt[j].y - pt[i].y) / (pt[j].x - pt[i].x);
                else
                    numK[pos ++].k = 100000;

            qsort(numK,pos,sizeof(numK[0]),cmp);
            int tmpNum = 2;
            for(int j = 1 ; j &lt; pos ; j ++)
            {
                if(numK[j].k == numK[j - 1].k)
                    tmpNum ++;
                else
                {
                    if(tmpNum &gt; maxNum)
                        maxNum = tmpNum;
                    tmpNum = 2;
                }
            }
            if(tmpNum &gt; maxNum)
                maxNum = tmpNum;
        }


        printf(&quot;%d\n&quot;,maxNum);
        maxNum = 1;
    }
    return 0;
}
</code></pre></div><div class=article-more><a href=//owent.net/2009/81.html target=_blank itemprop=url>更多</a></div><div class="article-panel-footer archive-article-footer"><time datetime=2009-08-14T11:30:49.000+00:00 itemprop=datePublished>2009-08-14</time></div></div></article></div><hr><nav id=page-nav><ul class=pagination><li class=page-item><a class=page-link href=/page/11/index.html>&#171;上一页</a></li><li class=page-item><a class=page-link href=/index.html>1</a></li><li class=page-item><a class=page-link href=/page/2/index.html>2</a></li><li class=page-item><a class=page-link href=/page/3/index.html>3</a></li><li class=page-item><a class=page-link href=/page/4/index.html>4</a></li><li class=page-item><a class=page-link href=/page/5/index.html>5</a></li><li class=page-item><a class=page-link href=/page/6/index.html>6</a></li><li class=page-item><a class=page-link href=/page/7/index.html>7</a></li><li class=page-item><a class=page-link href=/page/8/index.html>8</a></li><li class=page-item><a class=page-link href=/page/9/index.html>9</a></li><li class=page-item><a class=page-link href=/page/10/index.html>10</a></li><li class=page-item><a class=page-link href=/page/11/index.html>11</a></li><li class='page-item disabled'><a class=page-link href=/page/12/index.html>12</a><span class=sr-only>(current)</span></li><li class=page-item><a class=page-link href=/page/13/index.html>13</a></li><li class=page-item><a class=page-link href=/page/13/index.html>下一页&#187;</a></li></ul></nav></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>2026&nbsp;OWenT
</strong><strong id=footer-right class="float-right float-end"><a href=https://beian.miit.gov.cn/ target=_blank>沪ICP备2022003252号</a>&nbsp;&nbsp;<a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=importmap>
{"imports":{"@popperjs/core":"https://esm.run/popper.js","bootstrap":"https://esm.run/bootstrap","react":"https://esm.run/react","react-bootstrap":"https://esm.run/react-bootstrap"}}
</script><script type=module>// import * as Popper from "@popperjs/core";// import * as bootstrap from "bootstrap";
// import React from "react";

        
</script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/accesslog.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/armasm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/awk.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/basic.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/bnf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/capnproto.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/cmake.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/d.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/dockerfile.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/dos.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/erlang.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ebnf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/latex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/llvm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/lua.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/powershell.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/protobuf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/profile.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/vim.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/x86asm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bexcalidraw\b/i)){e.classList.add("excalidraw-root");continue}if(e.className.match(/\bdrawio\b/i)){e.classList.add("drawio-root"),e.classList.add("mxgraph");continue}if(e.className.match(/\bchart(js)?\b/i)){e.classList.add("chartjs-container");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript>var _hmt=_hmt||[];(function(){var t,n,e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6a0daf8d58889f1cf55a353867bfdbb0",t=document.getElementsByTagName("script"),n=document.getElementsByTagName("script")[t.length-1],n.parentNode.appendChild(e)})()</script></div></body></html>