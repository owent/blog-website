<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进程间通信 on I'm OWenT</title><link>//owent.net/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html</link><description>Recent content in 进程间通信 on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md"&gt;&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /&gt;&lt;/a&gt;</copyright><lastBuildDate>Sun, 23 Apr 2017 23:48:54 +0000</lastBuildDate><atom:link href="//owent.net/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>libatbus的几个藏得很深的bug</title><link>//owent.net/2017/1411.html</link><pubDate>Sun, 23 Apr 2017 23:48:54 +0000</pubDate><guid>//owent.net/2017/1411.html</guid><description>&lt;p&gt;在写这篇文章前，我突然想到以前流行了一段时间的服务器面试题：当一个BUG只有几百万分之一的概率会出现，怎么办？这个问题在这个BUG里只是毛毛雨而已，因为这次的BUG的&lt;strong&gt;出现概率是夸张的三亿分之一&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>atapp的c binding和c#适配</title><link>//owent.net/2017/1367.html</link><pubDate>Wed, 15 Feb 2017 23:27:51 +0000</pubDate><guid>//owent.net/2017/1367.html</guid><description>&lt;p&gt;这两天在做服务器框架的C的接口导出和C#的接入。之所以要做这么个东西是因为之前的服务器框架（&lt;a href="https://github.com/atframework/atsf4g-co"&gt;atsf4g-co&lt;/a&gt;）已经完成了通信层面和基本设计模式的细节部分，而且基本算是最大化性能了吧。但是现在的项目的战斗引擎是从以前Unity游戏上抽象而来的，全部由C#编写。再加上最近再考虑接入实时战斗，这样就不能像之前一样用一个简单的通信方式了，必须使用一个高效并且实时性更高通信机制。需要能够处理好比较高的集中式的组播和容灾的通信方式。于是就有了把之前的C++的框架抽离出API来驱动逻辑的想法。这样也比较容易地兼顾开发成本和性能之间地权衡。&lt;/p&gt;
&lt;h2 id="c-binding"&gt;C Binding&lt;/h2&gt;
&lt;p&gt;那么抽离出框架地目的是抽象出应用底层，这个刚好是&lt;a href="https://github.com/atframework/libatapp"&gt;atapp&lt;/a&gt;做的事，而且&lt;a href="https://github.com/atframework/libatapp"&gt;atapp&lt;/a&gt;的层面对外暴露的接口数量也比较少，使用比较简单，所以索性就直接对它下手了。&lt;/p&gt;</description></item><item><title>对象路由系统设计</title><link>//owent.net/2017/1342.html</link><pubDate>Sat, 04 Feb 2017 19:01:45 +0000</pubDate><guid>//owent.net/2017/1342.html</guid><description>&lt;h2 id="起源"&gt;起源&lt;/h2&gt;
&lt;p&gt;现在的手游也开始越来越复杂，以前少量交互线上保存的服务器架构越来越不能满足现在越来越偏向PC端MMORPG的需求。比如现在手游也引入了地图服务、公会服务等等。特别是地图服务需要能够动态切换服务节点、并且由于广播量巨大，导致我们得用更多级的缓存和更复杂的负载均衡。这些缓存和负载均衡都会涉及缓存失效、同步、更新、发现延迟等问题，所以越来越需要一个路由系统来解决这些问题。&lt;/p&gt;</description></item><item><title>近期的一个协程流程BUG</title><link>//owent.net/2017/1313.html</link><pubDate>Mon, 02 Jan 2017 23:13:25 +0000</pubDate><guid>//owent.net/2017/1313.html</guid><description>&lt;p&gt;最近一直没什么时间整理近期碰到的问题，今天思考了一下之前碰到的一个临时处理的BUG，顺便写点东西清理一下思路。&lt;/p&gt;
&lt;p&gt;其实严格来说这个BUG更应该是一个流程试用问题，不过这个问题应该是需要能在协程库里检测并抛出错误来。&lt;/p&gt;</description></item><item><title>atsf4g完整游戏工程示例</title><link>//owent.net/2016/1306.html</link><pubDate>Sun, 23 Oct 2016 12:31:14 +0000</pubDate><guid>//owent.net/2016/1306.html</guid><description>&lt;p&gt;近期仍然在搭建完整的游戏服务器架构。基于&lt;a href="https://github.com/atframework/atsf4g-co/"&gt;atsf4g（asynchronously-tree server framework fo game）&lt;/a&gt;的完整解决方案终于接近完成。基本框架之前其实已经做完了，但是之前解决的只是基本的框架层代码，不包含任何特定的交互模型、协议模型、配置服务等等。这回就整理了一个只包含登入登出逻辑的完整工程，另外优化了一些小细节和周边工具的支持。&lt;/p&gt;</description></item><item><title>atframework基本框架已经完成</title><link>//owent.net/2016/1301.html</link><pubDate>Thu, 22 Sep 2016 17:10:11 +0000</pubDate><guid>//owent.net/2016/1301.html</guid><description>&lt;p&gt;好久没写blog了。最近空闲时间都在加紧完成&lt;a href="https://atframe.work"&gt;atframework&lt;/a&gt;框架。总算是搞完了，并且搭建了一个静态介绍页。以后有空慢慢加文档进去。&lt;/p&gt;
&lt;p&gt;主页: &lt;a href="https://atframe.work/"&gt;https://atframe.work/&lt;/a&gt;
Github: &lt;a href="https://github.com/atframework/"&gt;https://github.com/atframework/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前这个项目已经是一个小型游戏服务器的完整框架，包括服务器间实例的管理、客户端和服务器的内部协议和通信机制。并且实现了纯C的port。
然后&lt;a href="https://github.com/atframework/atsf4g-co/tree/master/sample/atgw_cli_inner_hello"&gt;https://github.com/atframework/atsf4g-co/tree/master/sample/atgw_cli_inner_hello&lt;/a&gt;里提供了c++的客户度端的代码示例，&lt;a href="https://github.com/atframework/AtgwInnerCli-CSharp"&gt;https://github.com/atframework/AtgwInnerCli-CSharp&lt;/a&gt;里提供了C#的客户端代码示例。
使用的都是同一个纯C的协议porting。这样无论cocos还是unity框架接入都不困难了。其他的框架也可以直接用这个纯C的porting来接入。&lt;/p&gt;</description></item><item><title>游戏服务器的不停服更新</title><link>//owent.net/2016/1294.html</link><pubDate>Sun, 31 Jul 2016 17:23:34 +0000</pubDate><guid>//owent.net/2016/1294.html</guid><description>&lt;p&gt;我们目前的游戏第一次测试的时候笔记送匆忙，导致上线之后频繁更新。
比如BOSS战由于大区的人数和预期不一样导致的难度调整，或者是任务链或者数值调整，再加上一些BUG。&lt;/p&gt;</description></item><item><title>对atbus的小数据包的优化</title><link>//owent.net/2016/1286.html</link><pubDate>Sat, 09 Jul 2016 14:16:41 +0000</pubDate><guid>//owent.net/2016/1286.html</guid><description>&lt;p&gt;atbus是我按之前的思路写得服务器消息通信中间件，目标是简化服务器通信的流程，能够自动选择最优路线，自动的断线重连和通信通道维护。能够&lt;strong&gt;跨平台&lt;/strong&gt;并且&lt;strong&gt;高效&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>pbc的一个陈年老BUG</title><link>//owent.net/2016/1273.html</link><pubDate>Mon, 04 Jul 2016 13:01:42 +0000</pubDate><guid>//owent.net/2016/1273.html</guid><description>&lt;p&gt;近期跟了一下pbc的lua-binding的一个老BUG，起源是我们客户端报了一个奇怪的问题，我们游戏里的某些功能的optional字段，服务器并没有下发数据，但是客户端竟然能读到。&lt;/p&gt;</description></item><item><title>libatbus基本功能及单元测试终于写完啦</title><link>//owent.net/2016/1214.html</link><pubDate>Fri, 19 Feb 2016 12:44:53 +0000</pubDate><guid>//owent.net/2016/1214.html</guid><description>&lt;h2 id="libatbus"&gt;&lt;a href="https://github.com/atframework/libatbus"&gt;libatbus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;经过茫茫长时间的编写+过年在家无聊补充和修正单元测试，再加上这两天的整理，终于把以前的这个关于服务器通信中间件的基本功能和相应的单元测试完成啦。还是可以热烈庆祝一下的。&lt;/p&gt;</description></item><item><title>关于BUS通信系统的一些思考（三）</title><link>//owent.net/2015/1201.html</link><pubDate>Sun, 08 Nov 2015 17:17:05 +0000</pubDate><guid>//owent.net/2015/1201.html</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href="//www.owent.net/2014/1099.html"&gt;接上文关于bus通信系统的一些思考（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前的文章内容应该要有修订，但是并没有更新到blog里，而是直接写在了&lt;a href="https://github.com/atframework/libatbus"&gt;libatbus&lt;/a&gt;的文档里&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="目录"&gt;目录&lt;/h2&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;好久没写总结啦，最近一段时间比较忙，抽出的空闲时间都在不断完善之前提到的一个进程间通信lib的想法和实现（&lt;a href="https://github.com/atframework/libatbus"&gt;libatbus&lt;/a&gt;）。&lt;/p&gt;</description></item><item><title>关于BUS通信系统的一些思考（二）</title><link>//owent.net/2014/1099.html</link><pubDate>Tue, 05 Aug 2014 14:08:20 +0000</pubDate><guid>//owent.net/2014/1099.html</guid><description>&lt;blockquote&gt;
&lt;p&gt;接上文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="目录"&gt;目录&lt;/h2&gt;
&lt;h2 id="bus系统的设计思路"&gt;BUS系统的设计思路&lt;/h2&gt;
&lt;p&gt;虽然我很不愿意再设计一套BUS系统，但是现有的一些确实都没有特别符合我的口味的。所以还是尝试设计一个出来。&lt;/p&gt;
&lt;h3 id="结构设计"&gt;结构设计&lt;/h3&gt;
&lt;p&gt;简单来说，我希望BUS系统可以简单、高效、稳定。&lt;/p&gt;</description></item><item><title>关于BUS通信系统的一些思考（一）</title><link>//owent.net/2014/1090.html</link><pubDate>Fri, 01 Aug 2014 14:21:53 +0000</pubDate><guid>//owent.net/2014/1090.html</guid><description>&lt;h2 id="目录"&gt;目录&lt;/h2&gt;
&lt;h2 id="概述"&gt;概述&lt;/h2&gt;
&lt;p&gt;如何保证一个进程或线程能安全稳定地把一段消息发送到另一个进程和线程，甚至是另一台机器的进程或线程，再或是要通过代理转发到另一个进程或线程，一直是一个比较麻烦的问题。&lt;/p&gt;</description></item></channel></rss>