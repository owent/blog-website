<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gcc on I'm OWenT</title><link>//owent.net/tags/gcc.html</link><description>Recent content in gcc on I'm OWenT</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>admin@owent.net (OWenT)</managingEditor><webMaster>admin@owent.net (OWenT)</webMaster><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Sun, 17 Apr 2022 23:43:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/gcc/index.xml" rel="self" type="application/rss+xml"/><item><title>再度优化GCC、LLVM、Clang、libc++、libc++abi等套件的构建脚本</title><link>//owent.net/2022/2205.html</link><pubDate>Sun, 17 Apr 2022 23:43:45 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2022/2205.html</guid><description>前言 一直以来，我都维护了完整的 GCC 工具链构建工具 和 LLVM,Clang,libc++,libc++abi工具链构建工具 。 一方面是为了测试和体验</description></item><item><title>记录一些bazel适配用编译选项</title><link>//owent.net/2022/2202.html</link><pubDate>Mon, 14 Feb 2022 20:36:45 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2022/2202.html</guid><description>之前搞 opentelemetry-cpp 的时候接触了下 bazel 构建系统。这玩意儿用起来有一点坑，特别是使用自定义编译环境的时候。 在使用我自己编译的很新版本的 GCC 和 clang+libc++ 的时候，涉及对l</description></item><item><title>新版GCC和LLVM+Clang终于Release啦</title><link>//owent.net/2021/2105.html</link><pubDate>Sun, 16 May 2021 14:34:34 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2021/2105.html</guid><description>可能是疫情的原因，GCC好久没发布啦。最近总于又Release了，还是大版本。并且三大编译器对C++20的支持也都七七八八了。所以特意立贴庆</description></item><item><title>C++的backtrace</title><link>//owent.net/2018/1801.html</link><pubDate>Mon, 08 Jan 2018 17:55:00 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2018/1801.html</guid><description>开始之前 很多语言的log模块都有一个功能，就是在打log的时候能够追溯调用栈，有的时候对查bug能有点帮助。之前我也想过给我们的log模块加</description></item><item><title>libcopp v2的第一波优化完成</title><link>//owent.net/2017/1466.html</link><pubDate>Sat, 01 Jul 2017 15:57:29 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2017/1466.html</guid><description>之前测出来libcopp还有一些列优化点，但是要破坏之前的API，所以整理了一下优化的想法和方案。 预留空间和合并分配 之前有太多的堆内存分配了</description></item><item><title>libcopp(v2) vs goroutine性能测试</title><link>//owent.net/2017/1465.html</link><pubDate>Sat, 10 Jun 2017 15:57:29 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2017/1465.html</guid><description>本来是没想写这个对比。无奈之前和call_in_stack的作者聊了一阵，发现了一些libcopp的改进空间。然后顺便看了新的boost.c</description></item><item><title>libcopp的线程安全、栈池和merge boost.context 1.64.0</title><link>//owent.net/2017/1446.html</link><pubDate>Fri, 12 May 2017 19:45:17 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2017/1446.html</guid><description>线程安全 前段时间看到了一个完成读比较高的协程库-libgo，里面提供了线程安全的协程实现，并且也是使用锁。本来我并没有给libcopp里的功</description></item><item><title>GCC 7和LLVM+Clang+libc++abi 4.0的构建脚本</title><link>//owent.net/2017/1431.html</link><pubDate>Tue, 09 May 2017 11:17:55 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2017/1431.html</guid><description>之前的版本发完，有空来更新一下之前的gcc和llvm+clang工具链的编译脚本了。其实GCC 7是才release没多久但是llvm 4.0发</description></item><item><title>libatbus的几个藏得很深的bug</title><link>//owent.net/2017/1411.html</link><pubDate>Sun, 23 Apr 2017 23:48:54 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2017/1411.html</guid><description>在写这篇文章前，我突然想到以前流行了一段时间的服务器面试题：当一个BUG只有几百万分之一的概率会出现，怎么办？这个问题在这个BUG里只是毛毛</description></item><item><title>atsf4g完整游戏工程示例</title><link>//owent.net/2016/1306.html</link><pubDate>Sun, 23 Oct 2016 12:31:14 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1306.html</guid><description>近期仍然在搭建完整的游戏服务器架构。基于atsf4g（asynchronously-tree server framework fo game）的完整解决方案终于接近完成。基本</description></item><item><title>atframework基本框架已经完成</title><link>//owent.net/2016/1301.html</link><pubDate>Thu, 22 Sep 2016 17:10:11 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1301.html</guid><description>好久没写blog了。最近空闲时间都在加紧完成atframework框架。总算是搞完了，并且搭建了一个静态介绍页。以后有空慢慢加文档进去。 主页</description></item><item><title>游戏服务器的不停服更新</title><link>//owent.net/2016/1294.html</link><pubDate>Sun, 31 Jul 2016 17:23:34 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1294.html</guid><description>我们目前的游戏第一次测试的时候笔记送匆忙，导致上线之后频繁更新。 比如BOSS战由于大区的人数和预期不一样导致的难度调整，或者是任务链或者数值</description></item><item><title>Android和IOS的TLS问题</title><link>//owent.net/2016/1285.html</link><pubDate>Sat, 09 Jul 2016 14:15:14 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1285.html</guid><description>这个问题起源于以前给客户端写的一个log模块，然后里面为了线程安全且多线程下不互相写乱，并且因为这些系统基本都用比较高版本的编译器，都支持C</description></item><item><title>boost.context-1.61版本的设计模型变化</title><link>//owent.net/2016/1270.html</link><pubDate>Tue, 14 Jun 2016 17:40:29 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1270.html</guid><description>前言 之前写了个C++的协程框架libcopp，底层使用的是boost.context实现，然后剥离了对boost的依赖。然而这样意味着我必须</description></item><item><title>libatbus基本功能及单元测试终于写完啦</title><link>//owent.net/2016/1214.html</link><pubDate>Fri, 19 Feb 2016 12:44:53 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1214.html</guid><description>libatbus 经过茫茫长时间的编写+过年在家无聊补充和修正单元测试，再加上这两天的整理，终于把以前的这个关于服务器通信中间件的基本功能和相应的单元测试完</description></item><item><title>小记最近踩得两个C++坑</title><link>//owent.net/2015/1189.html</link><pubDate>Sat, 25 Jul 2015 14:53:44 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2015/1189.html</guid><description>小记最近踩得两个C++坑 记一下最近踩得两个C++独有的暗坑，其中一个和ABI相关。第二个坑其实之前研究过，但是没有实例，这次算是碰到了个典型</description></item><item><title>Android NDK undefined reference to ___tls_get_addr 错误</title><link>//owent.net/2015/1140.html</link><pubDate>Fri, 06 Feb 2015 20:27:16 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2015/1140.html</guid><description>本来看到Android的ndk都开始用gcc4.8和gcc4.9了，而且gcc4.8.1开始支持全部的c++11的特性，我就很happy地用</description></item><item><title>LLVM + Clang + Libcxx + Libcxxabi 工具链编译</title><link>//owent.net/2014/1101.html</link><pubDate>Fri, 12 Sep 2014 19:07:03 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1101.html</guid><description>LLVM和Clang工具链的生成配置文件写得比较搓，所以略微麻烦，另外这个脚本没有经过多环境测试，不保证在其他Linux发行版里正常使用。 如</description></item><item><title>[libiniloader] Project</title><link>//owent.net/2014/1081.html</link><pubDate>Mon, 14 Jul 2014 19:28:49 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1081.html</guid><description>INI 配置读取库发布 Github地址: https://github.com/owent/libiniloader OSChina镜像: http://git.oschina.net/owent/libiniloader 项目中经常会碰到需要读取配置的情况，而用ini配置最大的优势就是简单易懂。 但是现在</description></item><item><title>再议 C++ 11 Lambda表达式</title><link>//owent.net/2014/1060.html</link><pubDate>Tue, 03 Jun 2014 20:55:44 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1060.html</guid><description>目录 C++ 的Lambda表达式 C++ 11 标准发布，各大编译器都开始支持里面的各种新特性，其中一项比较有意思的就是lambda表达式。 语法规则 C++ 11 Lam</description></item><item><title>Linux 编译安装 GCC 4.9</title><link>//owent.net/2014/1038.html</link><pubDate>Wed, 23 Apr 2014 14:37:46 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1038.html</guid><description>详情及变更请参照: Linux 编译安装 GCC 4.9 GCC4.9发布啦，本脚本在之前4.8的基础上做了稍许改进，更新 PS：4.9.0 开始支持C++1y特性 GCC 4.9 的</description></item><item><title>捣鼓一个协程库</title><link>//owent.net/2014/1000.html</link><pubDate>Wed, 05 Mar 2014 21:52:49 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1000.html</guid><description>今年准备安安心心写一个协程库。一方面是觉得协程挺有意思，另一方面也是因为C/C++在这方面没有一个非常权威的解决方案。 按照我自己风格还是喜欢</description></item><item><title>C++11动态模板参数和type_traits</title><link>//owent.net/2014/971.html</link><pubDate>Mon, 27 Jan 2014 16:27:46 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/971.html</guid><description>C++11标准里有动态模板参数已经是众所周知的事儿了。但是当时还有个主流编译器还不支持。 但是现在，主要的编译器。VC(Windows),GC</description></item><item><title>std和boost的function与bind实现剖析</title><link>//owent.net/2013/938.html</link><pubDate>Thu, 28 Nov 2013 22:01:30 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/938.html</guid><description>用过std和boost的function对象和bind函数的童鞋们都知道这玩意用起来腰不酸了，腿不疼了，心情也舒畅了。先上一个简单得示例： std::string</description></item><item><title>VC和GCC成员函数指针实现的研究(三)</title><link>//owent.net/2013/902.html</link><pubDate>Wed, 11 Sep 2013 14:57:15 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/902.html</guid><description>接上一篇 VC和GCC内成员函数指针实现的研究(二) 虚继承 终于到最后的虚继承了。 测试代码如下: #include &amp;lt;ctime&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;cstddef&amp;gt; #include &amp;lt;string&amp;gt; class foo_a { public: virtual ~foo_a(){} virtual void info() {</description></item><item><title>VC和GCC成员函数指针实现的研究(二)</title><link>//owent.net/2013/896.html</link><pubDate>Wed, 11 Sep 2013 14:44:06 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/896.html</guid><description>接上一篇 VC和GCC内成员函数指针实现的研究(一) 接下来是多重继承，用到的测试代码如下所示: #include &amp;lt;ctime&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;cstddef&amp;gt; #include &amp;lt;string&amp;gt; class foo_a { public: virtual ~foo_a(){} virtual void info() {</description></item><item><title>VC和GCC内成员函数指针实现的研究(一)</title><link>//owent.net/2013/890.html</link><pubDate>Fri, 06 Sep 2013 12:55:58 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/890.html</guid><description>最近在《C++对象模型》一书里说到的virtual的成员函数指针，低于128的被cfront编译器认为是虚表偏移量（支持子类对父类函数的覆盖</description></item><item><title>ARM 交叉编译环境搭建</title><link>//owent.net/2013/738.html</link><pubDate>Thu, 11 Apr 2013 17:55:04 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/738.html</guid><description>最近研究了一下ARM的交叉编译环境搭建，太麻烦了必须作一下记录啊。 前两个方法比较简单一点，关键是淫家Google帮你弄好了大部分功能 方案一：</description></item><item><title>Linux 编译安装 GCC 4.8</title><link>//owent.net/2013/730.html</link><pubDate>Tue, 26 Mar 2013 10:01:33 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/730.html</guid><description>Linux 编译安装 GCC 4.8 详见: Linux 编译安装 GCC 4.8 GCC4.8发布啦，这个脚本在之前4.7的基础上做了点改进，移除一些过时的组件,增加了检测不到时自动下载源</description></item><item><title>Linux编译安装GCC 4.7</title><link>//owent.net/2012/584.html</link><pubDate>Sat, 07 Apr 2012 10:25:18 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2012/584.html</guid><description>Linux编译安装GCC 4.7 详见: Linux编译安装GCC 4.7 准备环境及依赖项 支持 ISO C90 的编译器 用于创建Ada编译器的GNAT 支持POSIX的sh</description></item><item><title>Linux 和 Windows PowerShell 常用工具/命令 记录</title><link>//owent.net/2011/482.html</link><pubDate>Fri, 19 Aug 2011 11:16:55 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2011/482.html</guid><description>Linux 常用工具 enca: http://dl.cihar.com/enca/ 文件名编码转换 iconv: 文件编码转换 convmv: 文件名编码转换 ldd: 查看可执行文件或动态链接库的依赖库 getconf: 查看配置信息（如getconf LONG_BI</description></item></channel></rss>