<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>协程 on I'm OWenT</title><link>//owent.net/tags/%E5%8D%8F%E7%A8%8B.html</link><description>Recent content in 协程 on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Wed, 12 Mar 2025 20:58:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/%E5%8D%8F%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>协程(libcopp)的Channel功能和CPU命中率优化</title><link>//owent.net/2025/2502.html</link><pubDate>Wed, 12 Mar 2025 20:58:45 +0000</pubDate><guid>//owent.net/2025/2502.html</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>设计 &lt;a href="https://owent.net/2022/2206.html">《libcopp对C++20协程的接入和接口设计》&lt;/a> 的时候，由于C++20协程的promise和awaitable是链式关联的。所以当时设计promise和awaitable之间通过一个共享的context来通信交互。当时第一版实现直接使用了 &lt;code>std::shared_ptr&lt;/code> 来管理共享引用，也预留了个规划是未来可以改成非线程安全的引用来减少不必要的Cache Miss开销。&lt;/p></description></item><item><title>libcopp对C++20协程的接入和接口设计</title><link>//owent.net/2022/2206.html</link><pubDate>Sat, 23 Jul 2022 20:50:45 +0000</pubDate><guid>//owent.net/2022/2206.html</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近开的坑有点多。有点忙不过来了所以好久没写Blog了。这个C++20的协程接入一直在改造计划中，但是一直没抽出时间来正式实施。
在之前，我写过一个初版的C++20协程接入 &lt;a href="https://owent.net/2020/2004.html">《libcopp接入C++20 Coroutine和一些过渡期的设计》&lt;/a> 。当时主要是考虑到 Rust也有和C++类似的历史包袱问题，所以参考了一些Rust协程改造过程中的设计。
但是后来尝试在项目中使用的时候发现还是有一些问题。首先C++20的协程并不是零开销抽象，所以强行用Rust的模式反而带来了一定开销和理解上的难度。其次原先的设计中 generator 是按类型去实现外部接入的。但是实际接入SDK的过程中我们有相当一部分类型相同但是接入流程不同的情况，再加上现在各大编译器也都已经让C++20协程的特性脱离 experimental 阶段了，有一些细节有所变化。所以干脆根据我们实际的使用场景，重新设计了下组织结构。&lt;/p></description></item><item><title>跨平台协程库 - libcopp 简介</title><link>//owent.net/2019/1912.html</link><pubDate>Tue, 22 Oct 2019 21:53:00 +0000</pubDate><guid>//owent.net/2019/1912.html</guid><description>&lt;p>前段时间有同事联系我想看看可能推广我之前写的协程库 &lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>，虽然 &lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a> 已经用到过好几个项目上，这几年也断断续续地写了一些实现细节的文章，但是也但确实需要系统、概览性地介绍下 &lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a> ，所以就有了这篇文章。&lt;/p></description></item><item><title>C++20 Coroutine 性能测试 (附带和libcopp/libco/libgo/goroutine/linux ucontext对比)</title><link>//owent.net/2019/1911.html</link><pubDate>Sat, 05 Oct 2019 14:52:00 +0000</pubDate><guid>//owent.net/2019/1911.html</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>之前写了 &lt;a href="https://owent.net/2018/1806.html">《协程框架(libcopp)v2优化、自适应栈池和同类库的Benchmark对比》&lt;/a> 和 &lt;a href="https://owent.net/2019/1904.html">《C++20 Coroutine》&lt;/a> ，但是一直没写 &lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20 Coroutine&lt;/a> 的测试报告。&lt;/p>
&lt;p>现在的草案版本比我当时写 &lt;a href="https://owent.net/2019/1904.html">《C++20 Coroutine》&lt;/a> 的时候有了一点点更新，&lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">cppreference&lt;/a> 上有文档了(&lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">https://en.cppreference.com/w/cpp/language/coroutines&lt;/a>) 。里面列举的标准文档是&lt;a href="https://owent.net/2019/1904.html">P0912R5&lt;/a>，这个文档目前还没完工，详情可以看他的来源&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">N4775&lt;/a>。不过内容上暂时还没有太大的变化，今天我就照着之前的方式来benchmark一波 &lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20 Coroutine&lt;/a> 吧。&lt;/p></description></item><item><title>协程框架(libcopp) 小幅优化</title><link>//owent.net/2019/1907.html</link><pubDate>Sat, 22 Jun 2019 12:26:58 +0000</pubDate><guid>//owent.net/2019/1907.html</guid><description>&lt;p>最近抽空继续对 &lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a> 进行了更新和小幅优化。 首先的Merge了 &lt;a href="https://www.boost.org/libs/context/">boost.context&lt;/a> 1.70.0 。这次&lt;a href="https://www.boost.org/libs/context/">boost.context&lt;/a>的更新似乎和它写进 &lt;a href="https://www.boost.org/users/history/version_1_70_0.html">CHANGELOG&lt;/a> 里的并不完全一致，匹配的只看到 macho 架构的脏数据操作。 不过另外它增加了新的平台支持 mips64，我目前还是简单导入了，但是平台检测工具还没有写，如果要使用是可以通过编译参数切过去的，不过我感觉没人会这么用吧？我自己用都得看一下之前怎么写的。&lt;/p></description></item><item><title>C++20 Coroutine</title><link>//owent.net/2019/1904.html</link><pubDate>Mon, 04 Mar 2019 20:38:00 +0000</pubDate><guid>//owent.net/2019/1904.html</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>最近的新闻里 C++20 已经确认的内容里已经有了协程组件，之前都是粗略看过这个协程草案。最近抽时间更加系统性的看了下接入和实现细节。&lt;/p>
&lt;p>我的测试代码都是在MSVC下开启 &lt;code>/await&lt;/code> 选项后测试的，在我本地的Linux clang环境中，可以通过 &lt;code>$LLVM_CLANG_PREFIX/bin/clang++ -std=c++2a -O0 -g -ggdb -stdlib=libc++ -fcoroutines-ts -lc++ -lc++abi -Wl,-rpath=$LLVM_CLANG_PREFIX/lib/ test.cpp&lt;/code> 编译和运行。&lt;/p></description></item><item><title>libcopp merge boost.context 1.69.0</title><link>//owent.net/2019/1903.html</link><pubDate>Mon, 11 Feb 2019 10:35:32 +0000</pubDate><guid>//owent.net/2019/1903.html</guid><description>&lt;p>过年啦，最近在看一些非技术性的东西，&lt;a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna&lt;/a> 的Paper也还没看完。随手优化了下Blog的主题，修复和优化了一些小问题。然后来Merge了一下 &lt;a href="https://www.boost.org/libs/context/">boost.context&lt;/a> 最新 1.69.0 版本的asm部分到 &lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>。&lt;/p></description></item><item><title>libcopp v2的第一波优化完成</title><link>//owent.net/2017/1466.html</link><pubDate>Sat, 01 Jul 2017 15:57:29 +0000</pubDate><guid>//owent.net/2017/1466.html</guid><description>&lt;p>之前测出来&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>还有一些列优化点，但是要破坏之前的API，所以整理了一下优化的想法和方案。&lt;/p>
&lt;h2 id="预留空间和合并分配">预留空间和合并分配&lt;/h2>
&lt;p>之前有太多的堆内存分配了，导致很多碎片。那么第一个想法就是协程对象可以分配在栈上，runner也可以分配在栈上。然后还可以加一个自定义预留长度。每个对象对齐到sizeof(long)，总长度对齐到64 Bytes。&lt;/p></description></item><item><title>libcopp(v2) vs goroutine性能测试</title><link>//owent.net/2017/1465.html</link><pubDate>Sat, 10 Jun 2017 15:57:29 +0000</pubDate><guid>//owent.net/2017/1465.html</guid><description>&lt;p>本来是没想写这个对比。无奈之前和&lt;a href="https://github.com/yuanzhubi/call_in_stack">call_in_stack&lt;/a>的作者聊了一阵，发现了一些&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>的改进空间。然后顺便看了新的boost.context的cc部分的代码，有所启发。想给&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>做一些优化，主要集中在减少分配次数从而减少内存碎片；在支持的编译器里有些地方用右值引用来减少不必要的拷贝；减少原子操作和减少L1cache miss几个方面。&lt;/p>
&lt;p>之后改造了茫茫多流程和接口后出了v2版本，虽然没完全优化完，但是组织结构已经定型了，可以用来做压力测试。为了以后方便顺便还把cppcheck和clang-analyzer的静态分析工具写进了dev脚本。然后万万没想到的是，在大量协程的情况下，benchmark的结果性能居然比原来还下降了大约1/3。&lt;/p></description></item><item><title>libcopp的线程安全、栈池和merge boost.context 1.64.0</title><link>//owent.net/2017/1446.html</link><pubDate>Fri, 12 May 2017 19:45:17 +0000</pubDate><guid>//owent.net/2017/1446.html</guid><description>&lt;h2 id="线程安全">线程安全&lt;/h2>
&lt;p>前段时间看到了一个完成读比较高的协程库-&lt;a href="https://github.com/yyzybb537/libgo">libgo&lt;/a>，里面提供了线程安全的协程实现，并且也是使用锁。本来我并没有给&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>里的功能加锁的打算，因为上层dispatcher还是比较容易做到安全分发的，所以原来并不保证线程安全。而且线程安全这种问题单元测试比较难写，可能还得碰点运气。但是思来想去，还是为线程安全做点什么吧。反正也不是很复杂。&lt;/p>
&lt;p>由于我并没有给utils加互斥锁的跨平台适配，所以先就直接用了自旋锁，来锁住需要考虑线程安全的地方。其实需要加锁的地方并不多，无非是管理器的增删查和task的next函数需要加锁。这些逻辑都很短，功能也很简单，并不会占用太多时间，所以自旋锁的问题也不大。而且以后真发现有问题，换掉也不是什么难事儿。&lt;/p></description></item><item><title>近期的一个协程流程BUG</title><link>//owent.net/2017/1313.html</link><pubDate>Mon, 02 Jan 2017 23:13:25 +0000</pubDate><guid>//owent.net/2017/1313.html</guid><description>&lt;p>最近一直没什么时间整理近期碰到的问题，今天思考了一下之前碰到的一个临时处理的BUG，顺便写点东西清理一下思路。&lt;/p>
&lt;p>其实严格来说这个BUG更应该是一个流程试用问题，不过这个问题应该是需要能在协程库里检测并抛出错误来。&lt;/p></description></item><item><title>boost.context-1.61版本的设计模型变化</title><link>//owent.net/2016/1270.html</link><pubDate>Tue, 14 Jun 2016 17:40:29 +0000</pubDate><guid>//owent.net/2016/1270.html</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>之前写了个C++的协程框架&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>，底层使用的是boost.context实现，然后剥离了对boost的依赖。然而这样意味着我必须时常跟进&lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context&lt;/a>的更新。&lt;/p>
&lt;p>顺带提一下这个协程库已经在我们线上服务器版本中使用了。&lt;/p>
&lt;p>从最初的boost版本（我忘了从哪个版本开始了）一直到1.60版本，&lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context&lt;/a>的变化都不大，都只是补全一些新的架构和体系结构，还有就是修复一些小细节的BUG，再就是增加了对valgrind的支持（之前写过一个&lt;a href="//owent.net/2015/1194.html">Merge记录&lt;/a>提到过）。新增的功能也只有&lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html">execution_context&lt;/a>(现在叫execution_context_v1)，这个东西我的&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>里其实包含了这个功能，并且本身做得比它要功能丰富，所以没有接入的必要。另外在1.60版本的时候尝试使用Windows里的fiber（当然默认是关闭的），在1.61版本里被移除了。这些细节都不是特别重要，主要还是1.61版本的变化。&lt;/p></description></item></channel></rss>