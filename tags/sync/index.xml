<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sync on I'm OWenT</title><link>//owent.net/tags/sync.html</link><description>Recent content in Sync on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Wed, 12 Mar 2025 20:58:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/sync/index.xml" rel="self" type="application/rss+xml"/><item><title>协程(libcopp)的Channel功能和CPU命中率优化</title><link>//owent.net/2025/2502.html</link><pubDate>Wed, 12 Mar 2025 20:58:45 +0000</pubDate><guid>//owent.net/2025/2502.html</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>设计 &lt;a href="https://owent.net/2022/2206.html">《libcopp对C++20协程的接入和接口设计》&lt;/a> 的时候，由于C++20协程的promise和awaitable是链式关联的。所以当时设计promise和awaitable之间通过一个共享的context来通信交互。当时第一版实现直接使用了 &lt;code>std::shared_ptr&lt;/code> 来管理共享引用，也预留了个规划是未来可以改成非线程安全的引用来减少不必要的Cache Miss开销。&lt;/p></description></item></channel></rss>