<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cache on I'm OWenT</title><link>//owent.net/tags/cache.html</link><description>Recent content in Cache on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md"&gt;&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /&gt;&lt;/a&gt;</copyright><lastBuildDate>Wed, 12 Mar 2025 20:58:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/cache/index.xml" rel="self" type="application/rss+xml"/><item><title>协程(libcopp)的Channel功能和CPU命中率优化</title><link>//owent.net/2025/2502.html</link><pubDate>Wed, 12 Mar 2025 20:58:45 +0000</pubDate><guid>//owent.net/2025/2502.html</guid><description>&lt;h2 id="背景"&gt;背景&lt;/h2&gt;
&lt;p&gt;设计 &lt;a href="https://owent.net/2022/2206.html"&gt;《libcopp对C++20协程的接入和接口设计》&lt;/a&gt; 的时候，由于C++20协程的promise和awaitable是链式关联的。所以当时设计promise和awaitable之间通过一个共享的context来通信交互。当时第一版实现直接使用了 &lt;code&gt;std::shared_ptr&lt;/code&gt; 来管理共享引用，也预留了个规划是未来可以改成非线程安全的引用来减少不必要的Cache Miss开销。&lt;/p&gt;</description></item><item><title>libcopp的线程安全、栈池和merge boost.context 1.64.0</title><link>//owent.net/2017/1446.html</link><pubDate>Fri, 12 May 2017 19:45:17 +0000</pubDate><guid>//owent.net/2017/1446.html</guid><description>&lt;!-- toc --&gt;
&lt;h2 id="线程安全"&gt;线程安全&lt;/h2&gt;
&lt;p&gt;前段时间看到了一个完成读比较高的协程库-&lt;a href="https://github.com/yyzybb537/libgo"&gt;libgo&lt;/a&gt;，里面提供了线程安全的协程实现，并且也是使用锁。本来我并没有给&lt;a href="https://github.com/owent/libcopp"&gt;libcopp&lt;/a&gt;里的功能加锁的打算，因为上层dispatcher还是比较容易做到安全分发的，所以原来并不保证线程安全。而且线程安全这种问题单元测试比较难写，可能还得碰点运气。但是思来想去，还是为线程安全做点什么吧。反正也不是很复杂。&lt;/p&gt;
&lt;p&gt;由于我并没有给utils加互斥锁的跨平台适配，所以先就直接用了自旋锁，来锁住需要考虑线程安全的地方。其实需要加锁的地方并不多，无非是管理器的增删查和task的next函数需要加锁。这些逻辑都很短，功能也很简单，并不会占用太多时间，所以自旋锁的问题也不大。而且以后真发现有问题，换掉也不是什么难事儿。&lt;/p&gt;</description></item></channel></rss>