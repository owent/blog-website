<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Logstash on I'm OWenT</title><link>//owent.net/tags/logstash.html</link><description>Recent content in Logstash on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md"&gt;&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /&gt;&lt;/a&gt;</copyright><lastBuildDate>Sat, 17 Nov 2018 02:00:00 +0000</lastBuildDate><atom:link href="//owent.net/tags/logstash/index.xml" rel="self" type="application/rss+xml"/><item><title>使用ELK辅助监控开发测试环境服务质量和问题定位</title><link>//owent.net/2018/1812.html</link><pubDate>Sat, 17 Nov 2018 02:00:00 +0000</pubDate><guid>//owent.net/2018/1812.html</guid><description>&lt;h2 id="什么是elk"&gt;什么是ELK？&lt;/h2&gt;
&lt;p&gt;ELK 是 &lt;a href="https://www.elastic.co/cn/products/elasticsearch"&gt;elasticsearch&lt;/a&gt; + &lt;a href="https://www.elastic.co/cn/products/logstash"&gt;logstash&lt;/a&gt; + &lt;a href="https://www.elastic.co/cn/products/kibana"&gt;kibana&lt;/a&gt;的缩写。这一套是现在比较流行的日志全文索引系统了。我之前的项目也有用它来做过日志分析，这次主要是拿来搭建开发测试环境的监控和分析系统，顺带记录一下部署脚本和流程。&lt;/p&gt;
&lt;p&gt;其中 &lt;a href="https://www.elastic.co/cn/products/elasticsearch"&gt;elasticsearch&lt;/a&gt; 是日志索引系统，我按两个master，3个数据和处理节点来部署。 &lt;a href="https://www.elastic.co/cn/products/logstash"&gt;logstash&lt;/a&gt; 和 &lt;a href="https://www.elastic.co/cn/products/kibana"&gt;kibana&lt;/a&gt; 因为是开发测试环境使用，量级不大，所以只部署了一个节点。但是在使用过程中发现 &lt;a href="https://www.elastic.co/cn/products/elasticsearch"&gt;elasticsearch&lt;/a&gt; 在jre的GC的时候还是有较长时间的 &lt;em&gt;&lt;strong&gt;Stop The World&lt;/strong&gt;&lt;/em&gt; 的问题，而且这期间的数据会倍丢弃。所以为了缓解这个状况，又引入了 &lt;a href="https://redis.io/"&gt;redis&lt;/a&gt; 作为消息队列使用。然后使用两组pipeline，一个从 client -&amp;gt; &lt;a href="https://www.elastic.co/cn/products/logstash"&gt;logstash&lt;/a&gt; -&amp;gt; &lt;a href="https://redis.io/"&gt;redis&lt;/a&gt; ，另一个从 &lt;a href="https://redis.io/"&gt;redis&lt;/a&gt; -&amp;gt; &lt;a href="https://www.elastic.co/cn/products/logstash"&gt;logstash&lt;/a&gt; -&amp;gt; &lt;a href="https://www.elastic.co/cn/products/elasticsearch"&gt;elasticsearch&lt;/a&gt; 来传输。这样如果在 &lt;a href="https://www.elastic.co/cn/products/elasticsearch"&gt;elasticsearch&lt;/a&gt; GC的 &lt;em&gt;&lt;strong&gt;Stop The World&lt;/strong&gt;&lt;/em&gt; 结束的时候会把数据补回去。 外面更大型的部署也有用 &lt;a href="https://kafka.apache.org/"&gt;kafka&lt;/a&gt; 或者更进一步优化的 &lt;a href="https://pulsar.apache.org/"&gt;pulsar&lt;/a&gt;。不过我们目前的应用也不太需要 &lt;a href="https://kafka.apache.org/"&gt;kafka&lt;/a&gt; 和 &lt;a href="https://pulsar.apache.org/"&gt;pulsar&lt;/a&gt; 那种数据落地和强一致性，使用 &lt;a href="https://redis.io/"&gt;redis&lt;/a&gt; 也已经够了。&lt;/p&gt;</description></item></channel></rss>