<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thread on I'm OWenT</title><link>//owent.net/tags/thread.html</link><description>Recent content in Thread on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md"&gt;&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /&gt;&lt;/a&gt;</copyright><lastBuildDate>Sun, 23 Apr 2017 23:48:54 +0000</lastBuildDate><atom:link href="//owent.net/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>libatbus的几个藏得很深的bug</title><link>//owent.net/2017/1411.html</link><pubDate>Sun, 23 Apr 2017 23:48:54 +0000</pubDate><guid>//owent.net/2017/1411.html</guid><description>&lt;!-- toc --&gt;
&lt;p&gt;在写这篇文章前，我突然想到以前流行了一段时间的服务器面试题：当一个BUG只有几百万分之一的概率会出现，怎么办？这个问题在这个BUG里只是毛毛雨而已，因为这次的BUG的&lt;strong&gt;出现概率是夸张的三亿分之一&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>boost.context-1.61版本的设计模型变化</title><link>//owent.net/2016/1270.html</link><pubDate>Tue, 14 Jun 2016 17:40:29 +0000</pubDate><guid>//owent.net/2016/1270.html</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;之前写了个C++的协程框架&lt;a href="https://github.com/owent/libcopp"&gt;libcopp&lt;/a&gt;，底层使用的是boost.context实现，然后剥离了对boost的依赖。然而这样意味着我必须时常跟进&lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html"&gt;boost.context&lt;/a&gt;的更新。&lt;/p&gt;
&lt;p&gt;顺带提一下这个协程库已经在我们线上服务器版本中使用了。&lt;/p&gt;
&lt;p&gt;从最初的boost版本（我忘了从哪个版本开始了）一直到1.60版本，&lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html"&gt;boost.context&lt;/a&gt;的变化都不大，都只是补全一些新的架构和体系结构，还有就是修复一些小细节的BUG，再就是增加了对valgrind的支持（之前写过一个&lt;a href="//owent.net/2015/1194.html"&gt;Merge记录&lt;/a&gt;提到过）。新增的功能也只有&lt;a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html"&gt;execution_context&lt;/a&gt;(现在叫execution_context_v1)，这个东西我的&lt;a href="https://github.com/owent/libcopp"&gt;libcopp&lt;/a&gt;里其实包含了这个功能，并且本身做得比它要功能丰富，所以没有接入的必要。另外在1.60版本的时候尝试使用Windows里的fiber（当然默认是关闭的），在1.61版本里被移除了。这些细节都不是特别重要，主要还是1.61版本的变化。&lt;/p&gt;</description></item><item><title>libatbus基本功能及单元测试终于写完啦</title><link>//owent.net/2016/1214.html</link><pubDate>Fri, 19 Feb 2016 12:44:53 +0000</pubDate><guid>//owent.net/2016/1214.html</guid><description>&lt;h2 id="libatbus"&gt;&lt;a href="https://github.com/atframework/libatbus"&gt;libatbus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;经过茫茫长时间的编写+过年在家无聊补充和修正单元测试，再加上这两天的整理，终于把以前的这个关于服务器通信中间件的基本功能和相应的单元测试完成啦。还是可以热烈庆祝一下的。&lt;/p&gt;</description></item><item><title>libcopp更新 (merge boost 1.59 context)</title><link>//owent.net/2015/1194.html</link><pubDate>Mon, 17 Aug 2015 11:43:45 +0000</pubDate><guid>//owent.net/2015/1194.html</guid><description>&lt;h1 id="libcopp更新-merge-boost-159-context"&gt;libcopp更新 (merge boost 1.59 context)&lt;/h1&gt;
&lt;!-- toc --&gt;
&lt;p&gt;之前由于兴趣写了一个&lt;a href="https://www.owent.net/2014/1000.html"&gt;协程框架&lt;/a&gt;，目前这个框架已经投入项目中使用。&lt;/p&gt;
&lt;p&gt;这个框架的上下文部分是使用了&lt;a href="http://www.boost.org/doc/libs/1_59_0/libs/context"&gt;boost.context&lt;/a&gt;，但是从开始写&lt;a href="https://github.com/owent/libcopp"&gt;libcopp&lt;/a&gt;到现在，boost.context也更新了几个版本。而之前几次merge基本都是简单地跟进了&lt;em&gt;make_fcontext&lt;/em&gt;和&lt;em&gt;jump_fcontext&lt;/em&gt;两个函数，这次就再稍微翻了一遍其他部分的代码。&lt;/p&gt;
&lt;h2 id="boostcontext的变化"&gt;boost.context的变化&lt;/h2&gt;
&lt;p&gt;首先是它在非windows栈分配的时候，增加了valgrind的适配。不过boost.context里的不同平台的栈缓冲区其实结构差不多，但是boost的实现里给复制粘贴了很多遍，所以我就干脆把这些地方合并啦。减少了一些重复代码。&lt;/p&gt;</description></item><item><title>捣鼓一个协程库</title><link>//owent.net/2014/1000.html</link><pubDate>Wed, 05 Mar 2014 21:52:49 +0000</pubDate><guid>//owent.net/2014/1000.html</guid><description>&lt;p&gt;今年准备安安心心写一个协程库。一方面是觉得协程挺有意思，另一方面也是因为C/C++在这方面没有一个非常权威的解决方案。
按照我自己风格还是喜欢C++，所以协程库定名为 libcopp 。
源码托管在 github: &lt;a href="https://github.com/owent/libcopp"&gt;https://github.com/owent/libcopp&lt;/a&gt;
镜像托管 &lt;a href="http://git.oschina.net/owent/distinctionpp"&gt;http://git.oschina.net/owent/distinctionpp&lt;/a&gt;&lt;/p&gt;</description></item><item><title>试试Boost.Asio</title><link>//owent.net/2013/811.html</link><pubDate>Thu, 23 May 2013 18:13:58 +0000</pubDate><guid>//owent.net/2013/811.html</guid><description>&lt;p&gt;慢慢一点一点看看Boost，这段时间就Asio库吧。
据说这货和libevent的效率差不多，但是Boost的平台兼容性，你懂得。还有它帮忙干掉了很多线程安全和线程分发的事情。&lt;/p&gt;</description></item><item><title>C++ 新特性学习（八） — 原子操作和多线程库[多工内存模型]</title><link>//owent.net/2012/611.html</link><pubDate>Tue, 12 Jun 2012 08:58:09 +0000</pubDate><guid>//owent.net/2012/611.html</guid><description>&lt;p&gt;这是我对C++新特性系统学习的最后一部分，之后就靠实践中再来看新标准的新特性啦。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在之前，我对这部分没太在意，直到看到了一篇文章 [http://blog.csdn.net/pongba/article/details/1659952](http://blog.csdn.net/pongba/article/details/1659952) 才意识到，C++的多线程操作也是个麻烦的问题。

简而言之，C++编译器在进行编译优化的时候，认为当前是单进程的，并且遵循**可观察行为**（Observable Behavior）不变的原则。就是说在可观察行为不变的情况下，操作是可以被改变顺序的，而单进程可观察行为不变，不代表在多进程的情况下仍然不变。还是上大牛的例子：

_**例子一：**_
&lt;/code&gt;&lt;/pre&gt;
&lt;table border="0" cellpadding="1" cellspacing="1"&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td colspan="2"&gt;x = y = 0;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;线程1&lt;/td&gt;
			&lt;td&gt;线程2&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;if(x == 1)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ++y;&lt;/td&gt;
			&lt;td&gt;if(y == 1)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ++x;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;完全可以优化成&lt;/p&gt;</description></item></channel></rss>