<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thread on I'm OWenT</title><link>//owent.net/tags/thread.html</link><description>Recent content in Thread on I'm OWenT</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Sun, 23 Apr 2017 23:48:54 +0000</lastBuildDate><atom:link href="//owent.net/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>libatbus的几个藏得很深的bug</title><link>//owent.net/2017/1411.html</link><pubDate>Sun, 23 Apr 2017 23:48:54 +0000</pubDate><guid>//owent.net/2017/1411.html</guid><description>在写这篇文章前，我突然想到以前流行了一段时间的服务器面试题：当一个BUG只有几百万分之一的概率会出现，怎么办？这个问题在这个BUG里只是毛毛</description></item><item><title>boost.context-1.61版本的设计模型变化</title><link>//owent.net/2016/1270.html</link><pubDate>Tue, 14 Jun 2016 17:40:29 +0000</pubDate><guid>//owent.net/2016/1270.html</guid><description>前言 之前写了个C++的协程框架libcopp，底层使用的是boost.context实现，然后剥离了对boost的依赖。然而这样意味着我必须</description></item><item><title>libatbus基本功能及单元测试终于写完啦</title><link>//owent.net/2016/1214.html</link><pubDate>Fri, 19 Feb 2016 12:44:53 +0000</pubDate><guid>//owent.net/2016/1214.html</guid><description>libatbus 经过茫茫长时间的编写+过年在家无聊补充和修正单元测试，再加上这两天的整理，终于把以前的这个关于服务器通信中间件的基本功能和相应的单元测试完</description></item><item><title>libcopp更新 (merge boost 1.59 context)</title><link>//owent.net/2015/1194.html</link><pubDate>Mon, 17 Aug 2015 11:43:45 +0000</pubDate><guid>//owent.net/2015/1194.html</guid><description>libcopp更新 (merge boost 1.59 context) 之前由于兴趣写了一个协程框架，目前这个框架已经投入项目中使用。 这个框架的上下文部分是使用了boost.contex</description></item><item><title>捣鼓一个协程库</title><link>//owent.net/2014/1000.html</link><pubDate>Wed, 05 Mar 2014 21:52:49 +0000</pubDate><guid>//owent.net/2014/1000.html</guid><description>今年准备安安心心写一个协程库。一方面是觉得协程挺有意思，另一方面也是因为C/C++在这方面没有一个非常权威的解决方案。 按照我自己风格还是喜欢</description></item><item><title>试试Boost.Asio</title><link>//owent.net/2013/811.html</link><pubDate>Thu, 23 May 2013 18:13:58 +0000</pubDate><guid>//owent.net/2013/811.html</guid><description>慢慢一点一点看看Boost，这段时间就Asio库吧。 据说这货和libevent的效率差不多，但是Boost的平台兼容性，你懂得。还有它帮忙干</description></item><item><title>C++ 新特性学习（八） — 原子操作和多线程库[多工内存模型]</title><link>//owent.net/2012/611.html</link><pubDate>Tue, 12 Jun 2012 08:58:09 +0000</pubDate><guid>//owent.net/2012/611.html</guid><description>这是我对C++新特性系统学习的最后一部分，之后就靠实践中再来看新标准的新特性啦。 在之前，我对这部分没太在意，直到看到了一篇文章 [http://blog.csdn.net/pongba/article/details/1659952](http://blog.csdn.net/pongba/article/details/1659952) 才意识到，C</description></item></channel></rss>