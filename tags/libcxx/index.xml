<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>libcxx on I'm OWenT</title><link>//owent.net/tags/libcxx.html</link><description>Recent content in libcxx on I'm OWenT</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>admin@owent.net (OWenT)</managingEditor><webMaster>admin@owent.net (OWenT)</webMaster><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Mon, 14 Feb 2022 20:36:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/libcxx/index.xml" rel="self" type="application/rss+xml"/><item><title>记录一些bazel适配用编译选项</title><link>//owent.net/2022/2202.html</link><pubDate>Mon, 14 Feb 2022 20:36:45 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2022/2202.html</guid><description>之前搞 opentelemetry-cpp 的时候接触了下 bazel 构建系统。这玩意儿用起来有一点坑，特别是使用自定义编译环境的时候。 在使用我自己编译的很新版本的 GCC 和 clang+libc++ 的时候，涉及对l</description></item><item><title>再次重构LLVM+Clang+libcxx+libc++abi+其他相关工具的构建流程</title><link>//owent.net/2021/2107.html</link><pubDate>Sun, 29 Aug 2021 20:29:56 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2021/2107.html</guid><description>背景 我们有时候写一些基础性类库或者实验新功能的时候，常常需要使用到最新版本的GCC和Clang。一些Linux发行版的源里和一些工具链（比如</description></item><item><title>新版GCC和LLVM+Clang终于Release啦</title><link>//owent.net/2021/2105.html</link><pubDate>Sun, 16 May 2021 14:34:34 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2021/2105.html</guid><description>可能是疫情的原因，GCC好久没发布啦。最近总于又Release了，还是大版本。并且三大编译器对C++20的支持也都七七八八了。所以特意立贴庆</description></item><item><title>C++20 Coroutine 性能测试 (附带和libcopp/libco/libgo/goroutine/linux ucontext对比)</title><link>//owent.net/2019/1911.html</link><pubDate>Sat, 05 Oct 2019 14:52:00 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2019/1911.html</guid><description>前言 之前写了 《协程框架(libcopp)v2优化、自适应栈池和同类库的Benchmark对比》 和 《C++20 Coroutine》 ，但是一直没</description></item><item><title>C++20 Coroutine</title><link>//owent.net/2019/1904.html</link><pubDate>Mon, 04 Mar 2019 20:38:00 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2019/1904.html</guid><description>前言 最近的新闻里 C++20 已经确认的内容里已经有了协程组件，之前都是粗略看过这个协程草案。最近抽时间更加系统性的看了下接入和实现细节。 我的测试代码都</description></item><item><title>重写了llvm+clang+libc++和libc++abi的构建脚本</title><link>//owent.net/2016/1309.html</link><pubDate>Sat, 19 Nov 2016 15:42:21 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2016/1309.html</guid><description>由于之前整理的服务器框架已经完成了，就需要用各种静态分析工具跑一遍。原来的llvm+clang的编译脚本是从GCC那个脚本copy过来然后改</description></item><item><title>LLVM+Clang+Libcxx+Libcxxabi（3.6）工具链编译（完成自举编译）</title><link>//owent.net/2015/1149.html</link><pubDate>Wed, 08 Apr 2015 17:41:02 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2015/1149.html</guid><description>LLVM和Clang工具链的生成配置文件写得比较搓，所以略微麻烦，另外这个脚本没有经过多环境测试，不保证在其他Linux发行版里正常使用。 CHANGE</description></item></channel></rss>