<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Prediction on I'm OWenT</title><link>//owent.net/tags/prediction.html</link><description>Recent content in Prediction on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Fri, 12 May 2017 19:45:17 +0000</lastBuildDate><atom:link href="//owent.net/tags/prediction/index.xml" rel="self" type="application/rss+xml"/><item><title>libcopp的线程安全、栈池和merge boost.context 1.64.0</title><link>//owent.net/2017/1446.html</link><pubDate>Fri, 12 May 2017 19:45:17 +0000</pubDate><guid>//owent.net/2017/1446.html</guid><description>&lt;h2 id="线程安全">线程安全&lt;/h2>
&lt;p>前段时间看到了一个完成读比较高的协程库-&lt;a href="https://github.com/yyzybb537/libgo">libgo&lt;/a>，里面提供了线程安全的协程实现，并且也是使用锁。本来我并没有给&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>里的功能加锁的打算，因为上层dispatcher还是比较容易做到安全分发的，所以原来并不保证线程安全。而且线程安全这种问题单元测试比较难写，可能还得碰点运气。但是思来想去，还是为线程安全做点什么吧。反正也不是很复杂。&lt;/p>
&lt;p>由于我并没有给utils加互斥锁的跨平台适配，所以先就直接用了自旋锁，来锁住需要考虑线程安全的地方。其实需要加锁的地方并不多，无非是管理器的增删查和task的next函数需要加锁。这些逻辑都很短，功能也很简单，并不会占用太多时间，所以自旋锁的问题也不大。而且以后真发现有问题，换掉也不是什么难事儿。&lt;/p></description></item></channel></rss>