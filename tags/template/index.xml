<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Template on I'm OWenT</title><link>//owent.net/tags/template.html</link><description>Recent content in Template on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Tue, 03 Jun 2014 20:55:44 +0000</lastBuildDate><atom:link href="//owent.net/tags/template/index.xml" rel="self" type="application/rss+xml"/><item><title>再议 C++ 11 Lambda表达式</title><link>//owent.net/2014/1060.html</link><pubDate>Tue, 03 Jun 2014 20:55:44 +0000</pubDate><guid>//owent.net/2014/1060.html</guid><description>&lt;h2 id="目录">目录&lt;/h2>
&lt;h2 id="c-的lambda表达式">C++ 的Lambda表达式&lt;/h2>
&lt;p>C++ 11 标准发布，各大编译器都开始支持里面的各种新特性，其中一项比较有意思的就是lambda表达式。&lt;/p>
&lt;h2 id="语法规则">语法规则&lt;/h2>
&lt;p>C++ 11 Lambda表达式的四种声明方式&lt;/p></description></item><item><title>捣鼓一个协程库</title><link>//owent.net/2014/1000.html</link><pubDate>Wed, 05 Mar 2014 21:52:49 +0000</pubDate><guid>//owent.net/2014/1000.html</guid><description>&lt;p>今年准备安安心心写一个协程库。一方面是觉得协程挺有意思，另一方面也是因为C/C++在这方面没有一个非常权威的解决方案。
按照我自己风格还是喜欢C++，所以协程库定名为 libcopp 。
源码托管在 github: &lt;a href="https://github.com/owent/libcopp">https://github.com/owent/libcopp&lt;/a>
镜像托管 &lt;a href="http://git.oschina.net/owent/distinctionpp">http://git.oschina.net/owent/distinctionpp&lt;/a>&lt;/p></description></item><item><title>C++11动态模板参数和type_traits</title><link>//owent.net/2014/971.html</link><pubDate>Mon, 27 Jan 2014 16:27:46 +0000</pubDate><guid>//owent.net/2014/971.html</guid><description>&lt;p>C++11标准里有动态模板参数已经是众所周知的事儿了。但是当时还有个主流编译器还不支持。
但是现在，主要的编译器。VC(Windows),GCC(Windows,Linux),Clang(Mac,IOS)都已经支持了。所以就可以准备用于生产环境了。
type_traits没啥好说的。主要是一些静态检测。主要还是要看动态模板参数和他们两的结合使用上。
动态模版参数标准文档见:
&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf&lt;/a>
和
&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf&lt;/a>
虽然贴出来了。估计是没人看得。所以就直接说重点。&lt;/p></description></item><item><title>std和boost的function与bind实现剖析</title><link>//owent.net/2013/938.html</link><pubDate>Thu, 28 Nov 2013 22:01:30 +0000</pubDate><guid>//owent.net/2013/938.html</guid><description>&lt;p>用过std和boost的function对象和bind函数的童鞋们都知道这玩意用起来腰不酸了，腿不疼了，心情也舒畅了。先上一个简单得示例：&lt;/p>
&lt;pre>&lt;code class="language-cpp">std::string str;
std::function&amp;lt;bool()&amp;gt; func = std::bind(&amp;amp;std::string::at, &amp;amp;str);
bool is_empty = func();
&lt;/code>&lt;/pre>
&lt;p>但是这是怎么做到的呢？看完源码以后，你会发现这里面有着一些很巧妙的设计。&lt;/p></description></item><item><title>ACM 计算几何 个人模板</title><link>//owent.net/2010/11.html</link><pubDate>Mon, 04 Oct 2010 11:19:02 +0000</pubDate><guid>//owent.net/2010/11.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * 二维ACM计算几何模板
 * 注意变量类型更改和EPS
 * #include &amp;lt;cmath&amp;gt;
 * #include &amp;lt;cstdio&amp;gt;
 * By OWenT
 */

const double eps = 1e-8;
const double pi = std::acos(-1.0);
//点
class point
{
public:
 double x, y;
 point(){};
 point(double x, double y):x(x),y(y){};

 static int xmult(const point &amp;amp;ps, const point &amp;amp;pe, const point &amp;amp;po)
 {
 return (ps.x - po.x) * (pe.y - po.y) - (pe.x - po.x) * (ps.y - po.y);
 }

 //相对原点的差乘结果，参数：点[_Off]
 //即由原点和这两个点组成的平行四边形面积
 double operator *(const point &amp;amp;_Off) const
 {
 return x * _Off.y - y * _Off.x;
 }
 //相对偏移
 point operator - (const point &amp;amp;_Off) const
 {
 return point(x - _Off.x, y - _Off.y);
 }
 //点位置相同(double类型)
 bool operator == (const point &amp;amp;_Off) const
 {
 return std::fabs(_Off.x - x) &amp;lt; eps &amp;amp;&amp;amp; std::fabs(_Off.y - y) &amp;lt; eps;
 }
 //点位置不同(double类型)
 bool operator != (const point &amp;amp;_Off) const
 {
 return ((*this) == _Off) == false;
 }
 //两点间距离的平方
 double dis2(const point &amp;amp;_Off) const
 {
 return (x - _Off.x) * (x - _Off.x) + (y - _Off.y) * (y - _Off.y);
 }
 //两点间距离
 double dis(const point &amp;amp;_Off) const
 {
 return std::sqrt((x - _Off.x) * (x - _Off.x) + (y - _Off.y) * (y - _Off.y));
 }
};

//两点表示的向量
class pVector
{
public:
 point s, e;//两点表示，起点[s]，终点[e]
 double a, b, c;//一般式,ax+by+c=0

 pVector(){}
 pVector(const point &amp;amp;s, const point &amp;amp;e):s(s),e(e){}

 //向量与点的叉乘,参数：点[_Off]
 //[点相对向量位置判断]
 double operator *(const point &amp;amp;_Off) const
 {
 return (_Off.y - s.y) * (e.x - s.x) - (_Off.x - s.x) * (e.y - s.y);
 }
 //向量与向量的叉乘,参数：向量[_Off]
 double operator *(const pVector &amp;amp;_Off) const
 {
 return (e.x - s.x) * (_Off.e.y - _Off.s.y) - (e.y - s.y) * (_Off.e.x - _Off.s.x);
 }
 //从两点表示转换为一般表示
 bool pton()
 {
 a = s.y - e.y;
 b = e.x - s.x;
 c = s.x * e.y - s.y * e.x;
 return true;
 }

 //-----------点和直线（向量）-----------
 //点在向量左边（右边的小于号改成大于号即可,在对应直线上则加上=号）
 //参数：点[_Off],向量[_Ori]
 friend bool operator&amp;lt;(const point &amp;amp;_Off, const pVector &amp;amp;_Ori)
 {
 return (_Ori.e.y - _Ori.s.y) * (_Off.x - _Ori.s.x)
 &amp;lt; (_Off.y - _Ori.s.y) * (_Ori.e.x - _Ori.s.x);
 }

 //点在直线上,参数：点[_Off]
 bool lhas(const point &amp;amp;_Off) const
 {
 return std::fabs((*this) * _Off) &amp;lt; eps;
 }
 //点在线段上,参数：点[_Off]
 bool shas(const point &amp;amp;_Off) const
 {
 return lhas(_Off)
 &amp;amp;&amp;amp; _Off.x - std::min(s.x, e.x) &amp;gt; -eps &amp;amp;&amp;amp; _Off.x - std::max(s.x, e.x) &amp;lt; eps
 &amp;amp;&amp;amp; _Off.y - std::min(s.y, e.y) &amp;gt; -eps &amp;amp;&amp;amp; _Off.y - std::max(s.y, e.y) &amp;lt; eps;
 }

 //点到直线/线段的距离
 //参数： 点[_Off], 是否是线段[isSegment](默认为直线)
 double dis(const point &amp;amp;_Off, bool isSegment = false)
 {
 //化为一般式
 pton();

 //到直线垂足的距离
 double td = (a * _Off.x + b * _Off.y + c) / sqrt(a * a + b * b);

 //如果是线段判断垂足
 if(isSegment)
 {
 double xp = (b * b * _Off.x - a * b * _Off.y - a * c) / ( a * a + b * b);
 double yp = (-a * b * _Off.x + a * a * _Off.y - b * c) / (a * a + b * b);
 double xb = std::max(s.x, e.x);
 double yb = std::max(s.y, e.y);
 double xs = s.x + e.x - xb;
 double ys = s.y + e.y - yb;
 if(xp &amp;gt; xb + eps || xp &amp;lt; xs - eps || yp &amp;gt; yb + eps || yp &amp;lt; ys - eps)
 td = std::min(_Off.dis(s), _Off.dis(e));
 }

 return fabs(td);
 }

 //关于直线对称的点
 point mirror(const point &amp;amp;_Off) const
 {
 //注意先转为一般式
 point ret;
 double d = a * a + b * b;
 ret.x = (b * b * _Off.x - a * a * _Off.x - 2 * a * b * _Off.y - 2 * a * c) / d;
 ret.y = (a * a * _Off.y - b * b * _Off.y - 2 * a * b * _Off.x - 2 * b * c) / d;
 return ret;
 }
 //计算两点的中垂线
 static pVector ppline(const point &amp;amp;_a, const point &amp;amp;_b)
 {
 pVector ret;
 ret.s.x = (_a.x + _b.x) / 2;
 ret.s.y = (_a.y + _b.y) / 2;
 //一般式
 ret.a = _b.x - _a.x;
 ret.b = _b.y - _a.y;
 ret.c = (_a.y - _b.y) * ret.s.y + (_a.x - _b.x) * ret.s.x;
 //两点式
 if(std::fabs(ret.a) &amp;gt; eps)
 {
 ret.e.y = 0.0;
 ret.e.x = - ret.c / ret.a;
 if(ret.e == ret. s)
 {
 ret.e.y = 1e10;
 ret.e.x = - (ret.c - ret.b * ret.e.y) / ret.a;
 }
 }
 else
 {
 ret.e.x = 0.0;
 ret.e.y = - ret.c / ret.b;
 if(ret.e == ret. s)
 {
 ret.e.x = 1e10;
 ret.e.y = - (ret.c - ret.a * ret.e.x) / ret.b;
 }
 }
 return ret;
 }

 //------------直线和直线（向量）-------------
 //直线重合,参数：直线向量[_Off]
 bool equal(const pVector &amp;amp;_Off) const
 {
 return lhas(_Off.e) &amp;amp;&amp;amp; lhas(_Off.s);
 }
 //直线平行，参数：直线向量[_Off]
 bool parallel(const pVector &amp;amp;_Off) const
 {
 return std::fabs((*this) * _Off) &amp;lt; eps;
 }
 //两直线交点，参数：目标直线[_Off]
 point crossLPt(pVector _Off)
 {
 //注意先判断平行和重合
 point ret = s;
 double t = ((s.x - _Off.s.x) * (_Off.s.y - _Off.e.y) - (s.y - _Off.s.y) * (_Off.s.x - _Off.e.x))
 / ((s.x - e.x) * (_Off.s.y - _Off.e.y) - (s.y - e.y) * (_Off.s.x - _Off.e.x));
 ret.x += (e.x - s.x) * t;
 ret.y += (e.y - s.y) * t;
 return ret;
 }

 //------------线段和直线（向量）----------
 //线段和直线交
 //参数：线段[_Off]
 bool crossSL(const pVector &amp;amp;_Off) const
 {
 double rs = (*this) * _Off.s;
 double re = (*this) * _Off.e;
 return rs * re &amp;lt; eps;
 }

 //------------线段和线段（向量）----------
 //判断线段是否相交(注意添加eps)，参数：线段[_Off]
 bool isCrossSS(const pVector &amp;amp;_Off) const
 {
 //1.快速排斥试验判断以两条线段为对角线的两个矩形是否相交
 //2.跨立试验（等于0时端点重合）
 return (
 (std::max(s.x, e.x) &amp;gt;= std::min(_Off.s.x, _Off.e.x)) &amp;amp;&amp;amp;
 (std::max(_Off.s.x, _Off.e.x) &amp;gt;= std::min(s.x, e.x)) &amp;amp;&amp;amp;
 (std::max(s.y, e.y) &amp;gt;= std::min(_Off.s.y, _Off.e.y)) &amp;amp;&amp;amp;
 (std::max(_Off.s.y, _Off.e.y) &amp;gt;= std::min(s.y, e.y)) &amp;amp;&amp;amp;
 ((pVector(_Off.s, s) * _Off) * (_Off * pVector(_Off.s, e)) &amp;gt;= 0.0) &amp;amp;&amp;amp;
 ((pVector(s, _Off.s) * (*this)) * ((*this) * pVector(s, _Off.e)) &amp;gt;= 0.0)
 );
 }
};

class polygon
{
public:
 const static long maxpn = 100;
 point pt[maxpn];//点（顺时针或逆时针）
 long n;//点的个数

 point&amp;amp; operator[](int _p)
 {
 return pt[_p];
 }

 //求多边形面积，多边形内点必须顺时针或逆时针
 double area() const
 {
 double ans = 0.0;
 int i;
 for(i = 0; i &amp;lt; n; i ++)
 {
 int nt = (i + 1) % n;
 ans += pt[i].x * pt[nt].y - pt[nt].x * pt[i].y;
 }
 return std::fabs(ans / 2.0);
 }
 //求多边形重心，多边形内点必须顺时针或逆时针
 point gravity() const
 {
 point ans;
 ans.x = ans.y = 0.0;
 int i;
 double area = 0.0;
 for(i = 0; i &amp;lt; n; i ++)
 {
 int nt = (i + 1) % n;
 double tp = pt[i].x * pt[nt].y - pt[nt].x * pt[i].y;
 area += tp;
 ans.x += tp * (pt[i].x + pt[nt].x);
 ans.y += tp * (pt[i].y + pt[nt].y);
 }
 ans.x /= 3 * area;
 ans.y /= 3 * area;
 return ans;
 }
 //判断点在凸多边形内，参数：点[_Off]
 bool chas(const point &amp;amp;_Off) const
 {
 double tp = 0, np;
 int i;
 for(i = 0; i &amp;lt; n; i ++)
 {
 np = pVector(pt[i], pt[(i + 1) % n]) * _Off;
 if(tp * np &amp;lt; -eps)
 return false;
 tp = (std::fabs(np) &amp;gt; eps)?np: tp;
 }
 return true;
 }
 //判断点是否在任意多边形内[射线法]，O(n)
 bool ahas(const point &amp;amp;_Off) const
 {
 int ret = 0;
 double infv = 1e-10;//坐标系最大范围
 pVector l = pVector(_Off, point( -infv ,_Off.y));
 for(int i = 0; i &amp;lt; n; i ++)
 {
 pVector ln = pVector(pt[i], pt[(i + 1) % n]);
 if(fabs(ln.s.y - ln.e.y) &amp;gt; eps)
 {
 point tp = (ln.s.y &amp;gt; ln.e.y)? ln.s: ln.e;
 if(fabs(tp.y - _Off.y) &amp;lt; eps &amp;amp;&amp;amp; tp.x &amp;lt; _Off.x + eps)
 ret ++;
 }
 else if(ln.isCrossSS(l))
 ret ++;
 }
 return (ret % 2 == 1);
 }
 //凸多边形被直线分割,参数：直线[_Off]
 polygon split(pVector _Off)
 {
 //注意确保多边形能被分割
 polygon ret;
 point spt[2];
 double tp = 0.0, np;
 bool flag = true;
 int i, pn = 0, spn = 0;
 for(i = 0; i &amp;lt; n; i ++)
 {
 if(flag)
 pt[pn ++] = pt[i];
 else
 ret.pt[ret.n ++] = pt[i];
 np = _Off * pt[(i + 1) % n];
 if(tp * np &amp;lt; -eps)
 {
 flag = !flag;
 spt[spn ++] = _Off.crossLPt(pVector(pt[i], pt[(i + 1) % n]));
 }
 tp = (std::fabs(np) &amp;gt; eps)?np: tp;
 }
 ret.pt[ret.n ++] = spt[0];
 ret.pt[ret.n ++] = spt[1];
 n = pn;
 return ret;
 }

 //-------------凸包-------------
 //Graham扫描法，复杂度O(nlg(n)),结果为逆时针
 //#include &amp;lt;algorithm&amp;gt;
 static bool graham_cmp(const point &amp;amp;l, const point &amp;amp;r)//凸包排序函数
 {
 return l.y &amp;lt; r.y || (l.y == r.y &amp;amp;&amp;amp; l.x &amp;lt; r.x);
 }
 polygon&amp;amp; graham(point _p[], int _n)
 {
 int i, len;
 std::sort(_p, _p + _n, polygon::graham_cmp);
 n = 1;
 pt[0] = _p[0], pt[1] = _p[1];
 for(i = 2; i &amp;lt; _n; i ++)
 {
 while(n &amp;amp;&amp;amp; point::xmult(_p[i], pt[n], pt[n - 1]) &amp;gt;= 0)
 n --;
 pt[++ n] = _p[i];
 }
 len = n;
 pt[++ n] = _p[_n - 2];
 for(i = _n - 3; i &amp;gt;= 0; i --)
 {
 while(n != len &amp;amp;&amp;amp; point::xmult(_p[i], pt[n], pt[n - 1]) &amp;gt;= 0)
 n --;
 pt[++ n] = _p[i];
 }
 return (*this);
 }

 //凸包旋转卡壳(注意点必须顺时针或逆时针排列)
 //返回值凸包直径的平方（最远两点距离的平方）
 double rotating_calipers()
 {
 int i = 1;
 double ret = 0.0;
 pt[n] = pt[0];
 for(int j = 0; j &amp;lt; n; j ++)
 {
 while(fabs(point::xmult(pt[j], pt[j + 1], pt[i + 1])) &amp;gt; fabs(point::xmult(pt[j], pt[j + 1], pt[i])) + eps)
 i = (i + 1) % n;
 //pt[i]和pt[j],pt[i + 1]和pt[j + 1]可能是对踵点
 ret = std::max(ret, std::max(pt[i].dis(pt[j]), pt[i + 1].dis(pt[j + 1])));
 }
 return ret;
 }

 //凸包旋转卡壳(注意点必须逆时针排列)
 //返回值两凸包的最短距离
 double rotating_calipers(polygon &amp;amp;_Off)
 {
 int i = 0;
 double ret = 1e10;//inf
 pt[n] = pt[0];
 _Off.pt[_Off.n] = _Off.pt[0];
 //注意凸包必须逆时针排列且pt[0]是左下角点的位置
 while(_Off.pt[i + 1].y &amp;gt; _Off.pt[i].y)
 i = (i + 1) % _Off.n;
 for(int j = 0; j &amp;lt; n; j ++)
 {
 double tp;
 //逆时针时为 &amp;gt;,顺时针则相反
 while((tp = point::xmult(pt[j], pt[j + 1], _Off.pt[i + 1]) - point::xmult( pt[j], pt[j + 1], _Off.pt[i])) &amp;gt; eps)
 i = (i + 1) % _Off.n;
 //(pt[i],pt[i+1])和(_Off.pt[j],_Off.pt[j + 1])可能是最近线段
 ret = std::min(ret, pVector(pt[j], pt[j + 1]).dis(_Off.pt[i], true));
 ret = std::min(ret, pVector(_Off.pt[i], _Off.pt[i + 1]).dis(pt[j + 1], true));
 if(tp &amp;gt; -eps)//如果不考虑TLE问题最好不要加这个判断
 {
 ret = std::min(ret, pVector(pt[j], pt[j + 1]).dis(_Off.pt[i + 1], true));
 ret = std::min(ret, pVector(_Off.pt[i], _Off.pt[i + 1]).dis(pt[j], true));
 }
 }
 return ret;
 }

 //-----------半平面交-------------
 //复杂度:O(nlog2(n))
 //#include &amp;lt;algorithm&amp;gt;
 //半平面计算极角函数[如果考虑效率可以用成员变量记录]
 static double hpc_pa(const pVector &amp;amp;_Off)
 {
 return atan2(_Off.e.y - _Off.s.y, _Off.e.x - _Off.s.x);
 }
 //半平面交排序函数[优先顺序: 1.极角 2.前面的直线在后面的左边]
 static bool hpc_cmp(const pVector &amp;amp;l, const pVector &amp;amp;r)
 {
 double lp = hpc_pa(l), rp = hpc_pa(r);
 if(fabs(lp - rp) &amp;gt; eps)
 return lp &amp;lt; rp;
 return point::xmult(l.s, r.e, r.s) &amp;lt; 0.0;
 }
 //用于计算的双端队列
 pVector dequeue[maxpn];
 //获取半平面交的多边形（多边形的核）
 //参数：向量集合[l]，向量数量[ln];(半平面方向在向量左边）
 //函数运行后如果n[即返回多边形的点数量]为0则不存在半平面交的多边形（不存在区域或区域面积无穷大）
 polygon&amp;amp; halfPanelCross(pVector _Off[], int ln)
 {
 int i, tn;
 n = 0;
 std::sort(_Off, _Off + ln, hpc_cmp);
 //平面在向量左边的筛选
 for(i = tn = 1; i &amp;lt; ln; i ++)
 if(fabs(hpc_pa(_Off[i]) - hpc_pa(_Off[i - 1])) &amp;gt; eps)
 _Off[tn ++] = _Off[i];
 ln = tn;
 int bot = 0, top = 1;
 dequeue[0] = _Off[0];
 dequeue[1] = _Off[1];
 for(i = 2; i &amp;lt; ln; i ++)
 {
 if(dequeue[top].parallel(dequeue[top - 1]) ||
 dequeue[bot].parallel(dequeue[bot + 1]))
 return (*this);
 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[top].crossLPt(dequeue[top - 1]), _Off[i].e, _Off[i].s) &amp;gt; eps)
 top --;
 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[bot].crossLPt(dequeue[bot + 1]), _Off[i].e, _Off[i].s) &amp;gt; eps)
 bot ++;
 dequeue[++ top] = _Off[i];
 }

 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[top].crossLPt(dequeue[top - 1]), dequeue[bot].e, dequeue[bot].s) &amp;gt; eps)
 top --;
 while(bot &amp;lt; top &amp;amp;&amp;amp;
 point::xmult(dequeue[bot].crossLPt(dequeue[bot + 1]), dequeue[top].e, dequeue[top].s) &amp;gt; eps)
 bot ++;
 //计算交点(注意不同直线形成的交点可能重合)
 if(top &amp;lt;= bot + 1)
 return (*this);
 for(i = bot; i &amp;lt; top; i ++)
 pt[n ++] = dequeue[i].crossLPt(dequeue[i + 1]);
 if(bot &amp;lt; top + 1)
 pt[n ++] = dequeue[bot].crossLPt(dequeue[top]);
 return (*this);
 }
};
class circle
{
public:
 point c;//圆心
 double r;//半径
 double db, de;//圆弧度数起点， 圆弧度数终点(逆时针0-360)

 //-------圆---------

 //判断圆在多边形内
 bool inside(const polygon &amp;amp;_Off) const
 {
 if(_Off.ahas(c) == false)
 return false;
 for(int i = 0; i &amp;lt; _Off.n; i ++)
 {
 pVector l = pVector(_Off.pt[i], _Off.pt[(i + 1) % _Off.n]);
 if(l.dis(c, true) &amp;lt; r - eps)
 return false;
 }
 return true;
 }

 //判断多边形在圆内（线段和折线类似）
 bool has(const polygon &amp;amp;_Off) const
 {
 for(int i = 0; i &amp;lt; _Off.n; i ++)
 if(_Off.pt[i].dis2(c) &amp;gt; r * r - eps)
 return false;
 return true;
 }

 //-------圆弧-------
 //圆被其他圆截得的圆弧，参数：圆[_Off]
 circle operator-(circle &amp;amp;_Off) const
 {
 //注意圆必须相交，圆心不能重合
 double d2 = c.dis2(_Off.c);
 double d = c.dis(_Off.c);
 double ans = std::acos((d2 + r * r - _Off.r * _Off.r) / (2 * d * r));
 point py = _Off.c - c;
 double oans = std::atan2(py.y, py.x);
 circle res;
 res.c = c;
 res.r = r;
 res.db = oans + ans;
 res.de = oans - ans + 2 * pi;
 return res;
 }
 //圆被其他圆截得的圆弧，参数：圆[_Off]
 circle operator+(circle &amp;amp;_Off) const
 {
 //注意圆必须相交，圆心不能重合
 double d2 = c.dis2(_Off.c);
 double d = c.dis(_Off.c);
 double ans = std::acos((d2 + r * r - _Off.r * _Off.r) / (2 * d * r));
 point py = _Off.c - c;
 double oans = std::atan2(py.y, py.x);
 circle res;
 res.c = c;
 res.r = r;
 res.db = oans - ans;
 res.de = oans + ans;
 return res;
 }

 //过圆外一点的两条切线
 //参数：点[_Off](必须在圆外),返回：两条切线(切线的s点为_Off,e点为切点)
 std::pair&amp;lt;pVector, pVector&amp;gt; tangent(const point &amp;amp;_Off) const
 {
 double d = c.dis(_Off);
 //计算角度偏移的方式
 double angp = std::acos(r / d), ango = std::atan2(_Off.y - c.y, _Off.x - c.x);
 point pl = point(c.x + r * std::cos(ango + angp), c.y + r * std::sin(ango + angp)),
 pr = point(c.x + r * std::cos(ango - angp), c.y + r * std::sin(ango - angp));
 return std::make_pair(pVector(_Off, pl), pVector(_Off, pr));
 }

 //计算直线和圆的两个交点
 //参数：直线[_Off](两点式)，返回两个交点，注意直线必须和圆有两个交点
 std::pair&amp;lt;point, point&amp;gt; cross(pVector _Off) const
 {
 _Off.pton();
 //到直线垂足的距离
 double td = fabs(_Off.a * c.x + _Off.b * c.y + _Off.c) / sqrt(_Off.a * _Off.a + _Off.b * _Off.b);

 //计算垂足坐标
 double xp = (_Off.b * _Off.b * c.x - _Off.a * _Off.b * c.y - _Off.a * _Off.c) / ( _Off.a * _Off.a + _Off.b * _Off.b);
 double yp = (- _Off.a * _Off.b * c.x + _Off.a * _Off.a * c.y - _Off.b * _Off.c) / (_Off.a * _Off.a + _Off.b * _Off.b);

 double ango = std::atan2(yp - c.y, xp - c.x);
 double angp = std::acos(td / r);

 return std::make_pair(point(c.x + r * std::cos(ango + angp), c.y + r * std::sin(ango + angp)),
 point(c.x + r * std::cos(ango - angp), c.y + r * std::sin(ango - angp)));
 }
};

class triangle
{
public:
 point a, b, c;//顶点
 triangle(){}
 triangle(point a, point b, point c): a(a), b(b), c(c){}

 //计算三角形面积
 double area()
 {
 return fabs(point::xmult(a, b, c)) / 2.0;
 }

 //计算三角形外心
 //返回：外接圆圆心
 point circumcenter()
 {
 pVector u,v;
 u.s.x = (a.x + b.x) / 2;
 u.s.y = (a.y + b.y) / 2;
 u.e.x = u.s.x - a.y + b.y;
 u.e.y = u.s.y + a.x - b.x;
 v.s.x = (a.x + c.x) / 2;
 v.s.y = (a.y + c.y) / 2;
 v.e.x = v.s.x - a.y + c.y;
 v.e.y = v.s.y + a.x - c.x;
 return u.crossLPt(v);
 }

 //计算三角形内心
 //返回：内接圆圆心
 point incenter()
 {
 pVector u, v;
 double m, n;
 u.s = a;
 m = atan2(b.y - a.y, b.x - a.x);
 n = atan2(c.y - a.y, c.x - a.x);
 u.e.x = u.s.x + cos((m + n) / 2);
 u.e.y = u.s.y + sin((m + n) / 2);
 v.s = b;
 m = atan2(a.y - b.y, a.x - b.x);
 n = atan2(c.y - b.y, c.x - b.x);
 v.e.x = v.s.x + cos((m + n) / 2);
 v.e.y = v.s.y + sin((m + n) / 2);
 return u.crossLPt(v);
 }

 //计算三角形垂心
 //返回：高的交点
 point perpencenter()
 {
 pVector u,v;
 u.s = c;
 u.e.x = u.s.x - a.y + b.y;
 u.e.y = u.s.y + a.x - b.x;
 v.s = b;
 v.e.x = v.s.x - a.y + c.y;
 v.e.y = v.s.y + a.x - c.x;
 return u.crossLPt(v);
 }

 //计算三角形重心
 //返回：重心
 //到三角形三顶点距离的平方和最小的点
 //三角形内到三边距离之积最大的点
 point barycenter()
 {
 pVector u,v;
 u.s.x = (a.x + b.x) / 2;
 u.s.y = (a.y + b.y) / 2;
 u.e = c;
 v.s.x = (a.x + c.x) / 2;
 v.s.y = (a.y + c.y) / 2;
 v.e = b;
 return u.crossLPt(v);
 }

 //计算三角形费马点
 //返回：到三角形三顶点距离之和最小的点
 point fermentpoint()
 {
 point u, v;
 double step = fabs(a.x) + fabs(a.y) + fabs(b.x) + fabs(b.y) + fabs(c.x) + fabs(c.y);
 int i, j, k;
 u.x = (a.x + b.x + c.x) / 3;
 u.y = (a.y + b.y + c.y) / 3;
 while (step &amp;gt; eps)
 {
 for (k = 0; k &amp;lt; 10; step /= 2, k ++)
 {
 for (i = -1; i &amp;lt;= 1; i ++)
 {
 for (j =- 1; j &amp;lt;= 1; j ++)
 {
 v.x = u.x + step * i;
 v.y = u.y + step * j;
 if (u.dis(a) + u.dis(b) + u.dis(c) &amp;gt; v.dis(a) + v.dis(b) + v.dis(c))
 u = v;
 }
 }
 }
 }
 return u;
 }
};
&lt;/code>&lt;/pre></description></item><item><title>简易四则运算(ACM个人模板)</title><link>//owent.net/2010/17.html</link><pubDate>Tue, 10 Aug 2010 18:40:31 +0000</pubDate><guid>//owent.net/2010/17.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * 简易四则运算（栈实现）
 * #include &amp;lt;stack&amp;gt;
 * #include &amp;lt;cstring&amp;gt;
 */
std::stack&amp;lt;char&amp;gt; opr;
std::stack&amp;lt;double&amp;gt; num;
char oprPRI[256];
//初始化调用
void initCalc()
{
 //优先级设置
 char oprMap[7][2] = { {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}, {'^', 3}, {'(', 100}, {')', 0} };
 for(int i = 0; i &amp;lt; 7; i ++)
 oprPRI[oprMap[i][0]] = oprMap[i][1];
}
bool checkNum(char c)
{
 return c == '.' || (c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9');
}
double calcOpr(double l, double r, char opr)
{
 switch(opr)
 {
 case '+': return l + r;
 case '-': return l - r;
 case '*': return l * r;
 case '/': return l / r;
 case '^': return ::pow(l, r);
 }
 return 0.0;
}
void calcStack()
{
 double cl, cr;
 cr = num.top();
 num.pop();
 cl = num.top();
 num.pop();
 num.push(::calcOpr(cl, cr, opr.top()));
 opr.pop();
}
double calc(const char str[])
{
 while(!opr.empty())
 opr.pop();
 while(!num.empty())
 num.pop();
 int i = 0, len = strlen(str);
 num.push(0.0);
 opr.push('(');
 while(i &amp;lt; len)
 {
 if(::checkNum(str[i]))
 {
 double l;
 ::sscanf(str + i, &amp;quot;%lf&amp;quot;, &amp;amp;l);
 while(::checkNum(str[i]))
 i ++;
 num.push(l);
 }
 else
 {
 char c = str[i ++];
 if(c == ')')
 {
 while(opr.top() != '(')
 calcStack();
 opr.pop();
 }
 else if(oprPRI[c] &amp;gt; oprPRI[opr.top()])
 opr.push(c);
 else
 {
 while(opr.top() != '(' &amp;amp;&amp;amp; oprPRI[c] &amp;lt;= oprPRI[opr.top()])
 calcStack();
 opr.push(c);
 }
 }
 }
 while(opr.size() &amp;gt; 1)
 calcStack();
 return num.top();
}
&lt;/code>&lt;/pre></description></item><item><title>数论模板（个人模板）</title><link>//owent.net/2010/18.html</link><pubDate>Mon, 09 Aug 2010 15:54:02 +0000</pubDate><guid>//owent.net/2010/18.html</guid><description>&lt;h2 id="基础函数">基础函数:&lt;/h2>
&lt;pre>&lt;code class="language-cpp">// 最大公约数,欧几里得定理
int gcd(int a, int b)
{
 return b?gcd(b, a % b): a;
}
// 拓展欧几里得定理
// 求解ax + by = gcd(a,b)
int ext_gcd(int a, int b, int &amp;amp;x, int &amp;amp;y)
{
 int tmp, ret;
 if(!b)
 {
 x = 1;
 y = 0;
 return a;
 }
 ret = ext_gcd(b, a % b, x, y);
 tmp = x;
 x = y;
 y = tmp - (a / b) * y;
 return ret;
}
//交换数值
void swap(int &amp;amp;a, int &amp;amp;b)
{
 a ^= b ^= a ^= b;
}

/**
 * a的b次方Mod c
 * 参数为整数
 * 使用时注意修改类型
 */
int PowerMod(int a, int b, int c)
{
 int tp = 1;
 while (b)
 {
 if (b &amp;amp; 1)
 tp = (tp * a) % c;
 a = (a * a) % c;
 b &amp;gt;&amp;gt;= 1;
 }
 return tp;
}
&lt;/code>&lt;/pre>
&lt;h2 id="1欧拉函数">1.欧拉函数&lt;/h2>
&lt;p>Ψ（n） = 小于n且与n互质的数的个数&lt;/p></description></item><item><title>树状数组模块(个人模板)</title><link>//owent.net/2010/30.html</link><pubDate>Thu, 06 May 2010 13:51:29 +0000</pubDate><guid>//owent.net/2010/30.html</guid><description>&lt;p>树状数组模块&lt;/p>
&lt;p>ACM个人模板&lt;/p>
&lt;p>POJ 2155 题目测试通过&lt;/p>
&lt;pre>&lt;code class="language-cpp">/**
 * 树状数组模块
 * 下标从0开始
 */
typedef long DG_Ran;
typedef long DG_Num;
const DG_Num DG_MAXN = 1005;

//2^n
DG_Num LowBit(DG_Num n)
{
 return n &amp;amp; (-n);
}
//获取父节点索引
DG_Num DGFather(DG_Num n)
{
 return n + LowBit(n + 1);
}
//获取小的兄弟节点索引
DG_Num DGBrother(DG_Num n)
{
 return n - LowBit(n + 1);
}
//查找增加树状数组前pos项和
//参数(树状数组[in],索引[in],初始赋0即查找前n项和[out])
//复杂度:log(n)
void DGFind(DG_Ran *g,DG_Num pos,DG_Ran &amp;amp;sum)
{
 sum += *(g + pos);
 if(pos &amp;gt;= LowBit(pos + 1))
 DGFind(g, pos - LowBit(pos + 1), sum);
}
//查找对应线性数组元素
//参数(树状数组[in],索引[in]).
//返回值:对应线性数组元素log(n)
//复杂度:log(n)
DG_Ran DGFindEle(DG_Ran *g,DG_Num pos)
{
 DG_Ran a = 0 , b = 0;
 DGFind(g, pos, a);
 if(pos)
 {
 DGFind(g,pos - 1,b);
 return a - b;
 }
 else
 return a;
}
//树状数组,增加节点
//参数:树状数组[out],原数组大小[in],新增线性数组值[in]
//复杂度:log(n)
DG_Ran DGAdd(DG_Ran *g,DG_Num n,DG_Ran val)
{
 *(g + n) = val;
 DG_Num a = n;
 DG_Num b = 1;
 while((a &amp;amp; (~b)) != a)
 {
 *(g + n) += *(g + a - 1);
 a &amp;amp;= (~b);
 b &amp;lt;&amp;lt;= 1;
 }
 return n + 1;
}
//构建树状数组
//参数:线性数组[in],数组大小[in],树状数组[out]
//复杂度:nlog(n)
DG_Ran DGCreate(DG_Ran *g,DG_Num n,DG_Ran *tg)
{
 DG_Num i;
 *tg = *g;
 for(i = 1 ; i &amp;lt; n ; i ++)
 DGAdd(tg,i,*(g + i));
 return n;
}
//修改指定位置值
//参数:线性数组[in],数组位置[in],数组大小[in],新值[in]
//复杂度:log(n)
DG_Ran DGEdit(DG_Ran *g,DG_Num pos,DG_Num n,DG_Ran val)
{
 DG_Num f = DGFather(pos);
 DG_Ran o = *( g + pos );
 *( g + pos ) = val;
 if(f &amp;lt; n)
 {
 DG_Ran fv = val - o + *( g + f );
 DGEdit(g, f, n, fv);
 }
 return n;
}

//树状数组的翻转(树状数组的应用)
//一维 复杂度log(n)
//小于等于指定位置的元素的翻转&amp;lt;=pos
void DGDown1(DG_Ran g[],DG_Num pos,DG_Ran av)
{
 while(pos &amp;gt;= 0)
 g[pos] += av , pos = DGBrother(pos);
}
//获取位置pos的元素翻转次数
DG_Ran DGCUp1(DG_Ran g[],DG_Num pos , DG_Num n)
{
 DG_Ran t = 0;
 while(pos &amp;lt; n)
 t += g[pos] , pos = DGFather(pos);
 return t;
}
//二维 复杂度(log(n))^2
//小于等于指定位置的元素的翻转(0,0)-&amp;gt;(x,y)
void DGDown2(DG_Ran g[][DG_MAXN],DG_Num x ,DG_Num y,DG_Ran av)
{
 while(x &amp;gt;= 0)
 {
 DG_Num tmp = y;
 while (tmp &amp;gt;= 0)
 {
 g[x][tmp] += av;
 tmp = DGBrother(tmp);
 }
 x = DGBrother(x);
 }
}
//获取位置(x,y)的元素翻转次数
DG_Ran DGCUp2(DG_Ran g[][DG_MAXN],DG_Num x ,DG_Num y , DG_Num n)
{
 DG_Ran t = 0;
 while(x &amp;lt; n)
 {
 DG_Num tmp = y;
 while (tmp &amp;lt; n)
 {
 t += g[x][tmp];
 tmp = DGFather(tmp);
 }
 x = DGFather(x);
 }
 return t;
}
&lt;/code>&lt;/pre></description></item><item><title>线性筛法求质数(素数)表 及其原理</title><link>//owent.net/2010/32.html</link><pubDate>Mon, 03 May 2010 11:20:33 +0000</pubDate><guid>//owent.net/2010/32.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * 线性筛法求素数表
 * 复杂度: O(n)
 */
const long MAXP = 1000000;
long prime[MAXP] = {0},num_prime = 0;
int isNotPrime[MAXP] = {1, 1};
void GetPrime_Init()//初始化调用
{
 for(long i = 2 ; i &amp;lt; MAXP ; i ++)
 {
 if(! isNotPrime[i])
 prime[num_prime ++]=i;
 for(long j = 0 ; j &amp;lt; num_prime &amp;amp;&amp;amp; i * prime[j] &amp;lt; MAXP ; j ++)
 {
 isNotPrime[i * prime[j]] = 1;
 if( !(i % prime[j]))
 break;
 }
 }
}
&lt;/code>&lt;/pre>
&lt;p>线性筛法,即是筛选掉所有合数,留下质数&lt;/p></description></item><item><title>Hash模板 个人模板</title><link>//owent.net/2010/54.html</link><pubDate>Mon, 15 Mar 2010 12:58:47 +0000</pubDate><guid>//owent.net/2010/54.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * Hash模板
 * Based: 0
 * template&amp;lt;unsigned long _SZ,class _T, unsigned long *pFun(_T _Off)&amp;gt;
 * class _My_Hash_ToInt
 * 传入数据大小_SZ,传入类型_T,Hash函数
 * 传入类型_T必须重载 = 和 == 符号
 * 收录了ELFHash函数
 * 主要是为了判重的简化些的模板
 * Hash算法性能比较见 http://www.cnblogs.com/lonelycatcher/archive/2011/08/23/2150587.html
 */

const long hashsize = 51071; //Hash表大小(注意修改)
// 各种Hash算法
unsigned int SDBMHash(char *str)
{
 unsigned int hash = hashsize;

 while (*str)
 {
 // equivalent to: hash = 65599*hash + (*str++);
 hash = (*str++) + (hash &amp;lt;&amp;lt; 6) + (hash &amp;lt;&amp;lt; 16) - hash;
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// RS Hash Function
unsigned int RSHash(char *str)
{
 unsigned int b = 378551;
 unsigned int a = 63689;
 unsigned int hash = hashsize;

 while (*str)
 {
 hash = hash * a + (*str++);
 a *= b;
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// JS Hash Function
unsigned int JSHash(char *str)
{
 unsigned int hash = 1315423911;

 while (*str)
 {
 hash ^= ((hash &amp;lt;&amp;lt; 5) + (*str++) + (hash &amp;gt;&amp;gt; 2));
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// P. J. Weinberger Hash Function
unsigned int PJWHash(char *str)
{
 unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8);
 unsigned int ThreeQuarters = (unsigned int)((BitsInUnignedInt * 3) / 4);
 unsigned int OneEighth = (unsigned int)(BitsInUnignedInt / 8);
 unsigned int HighBits = (unsigned int)(0xFFFFFFFF) &amp;lt;&amp;lt; (BitsInUnignedInt - OneEighth);
 unsigned int hash = hashsize;
 unsigned int test = 0;

 while (*str)
 {
 hash = (hash &amp;lt;&amp;lt; OneEighth) + (*str++);
 if ((test = hash &amp;amp; HighBits) != 0)
 {
 hash = ((hash ^ (test &amp;gt;&amp;gt; ThreeQuarters)) &amp;amp; (~HighBits));
 }
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// ELF Hash Function
unsigned int ELFHash(char *str)
{
 unsigned int hash = hashsize;
 unsigned int x = 0;

 while (*str)
 {
 hash = (hash &amp;lt;&amp;lt; 4) + (*str++);
 if ((x = hash &amp;amp; 0xF0000000L) != 0)
 {
 hash ^= (x &amp;gt;&amp;gt; 24);
 hash &amp;amp;= ~x;
 }
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// BKDR Hash Function
unsigned int BKDRHash(char *str)
{
 unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
 unsigned int hash = hashsize;

 while (*str)
 {
 hash = hash * seed + (*str++);
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// DJB Hash Function
unsigned int DJBHash(char *str)
{
 unsigned int hash = 5381;

 while (*str)
 {
 hash += (hash &amp;lt;&amp;lt; 5) + (*str++);
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// AP Hash Function
unsigned int APHash(char *str)
{
 unsigned int hash = hashsize;
 int i;

 for (i=0; *str; i++)
 {
 if ((i &amp;amp; 1) == 0)
 {
 hash ^= ((hash &amp;lt;&amp;lt; 7) ^ (*str++) ^ (hash &amp;gt;&amp;gt; 3));
 }
 else
 {
 hash ^= (~((hash &amp;lt;&amp;lt; 11) ^ (*str++) ^ (hash &amp;gt;&amp;gt; 5)));
 }
 }

 return (hash &amp;amp; 0x7FFFFFFF);
}

// 程序模板
template&amp;lt;typename _T&amp;gt;
class _My_Hash_ToInt_Data
{
public:
 _My_Hash_ToInt_Data()
 {
 times = 0;
 next = -1;
 }
 _T data;
 long times;
 long next;
};
template&amp;lt;long _SZ,class _T, unsigned long pFun(_T&amp;amp; _Off)&amp;gt;
class _My_Hash_ToInt
{
public:
 _My_Hash_ToInt()
 {
 memset(hash, -1, sizeof(hash));
 length = 0;
 };
 ~_My_Hash_ToInt(){};
 long find(_T _Off)
 {
 long pos = hash[pFun(_Off)];
 while(pos &amp;gt;= 0)
 {
 if(data[pos].data == _Off)
 return pos;
 else
 pos = data[pos].next;
 }
 return -1;
 }
 long insert(_T _Off)
 {
 long oldPos = pFun(_Off);
 long pos = hash[oldPos];
 while(pos &amp;gt;= 0)
 {
 if(data[pos].data == _Off)
 {
 data[pos].times ++;
 return pos;
 }
 else
 pos = data[pos].next;
 }
 data[length].data = _Off;
 data[length].times = 1;
 data[length].next = hash[oldPos];
 hash[oldPos] = length ;
 return length ++;
 }
 void clear()
 {
 length = 0;
 memset(hash, -1, sizeof(hash));
 memset(data, -1, sizeof(data));
 }
 //Member
 long length;
 _My_Hash_ToInt_Data&amp;lt;_T&amp;gt; data[_SZ];
 long hash[hashsize];
};

//节点类（注意修改）
class node
{
public:
 char str[60];
 bool operator == (node &amp;amp;strin)
 {
 return !strcmp(str, strin.str);
 }
 node&amp;amp; operator = (node &amp;amp;strin)
 {
 strcpy(str, strin.str);
 return (*this);
 }
};
//扩展Hash函数（注意修改）
unsigned long ELFHashEx(node &amp;amp;strIn)
{
 return ELFHash(strIn.str);
}
_My_Hash_ToInt&amp;lt;10005, node, ELFHashEx&amp;gt;hash;//Hash类例子
&lt;/code>&lt;/pre></description></item><item><title>最长单调子序列 复杂度nlog(n)</title><link>//owent.net/2009/74.html</link><pubDate>Wed, 16 Sep 2009 04:44:59 +0000</pubDate><guid>//owent.net/2009/74.html</guid><description>&lt;pre>&lt;code class="language-cpp">//最长单调子序列 复杂度nlog(n)
//参数(原序列,序列长度,生成的序列),传入序列长度必须大于0
//返回值中lengthRecord中前k项表示长度为k的最小字序列
//LIScmp为关系函数,原函数表明lengthRecord为递增(不含等于)
typedef double LISTYPE;
#define LISMAXN 10000
int LIScmp(LISTYPE a,LISTYPE b)
{
 return a &amp;lt; b;
}
long LISLength(LISTYPE list[],long n,LISTYPE lengthRecord[])
{
 long length = 1,lth;
 LISTYPE lR[LISMAXN];
 lR[0] = list[0];

 for(int i = 1 ; i &amp;lt; n ; i ++)
 {
 //二分查找,复杂度 log(n)
 int b,e,m;
 b = 0;
 e = length - 1;
 while(b &amp;lt;= e &amp;amp;&amp;amp; e &amp;gt;= 0)
 {
 m = (b + e) / 2;
 if(LIScmp(lR[m],list[i]))
 b = m + 1;
 else
 e = m - 1;
 }
 lR[b] = list[i];
 if(b &amp;gt;= length)
 length ++;
 }
 /*
 *计算序列部分
 *复杂度nlog(n)
 */
 lth = 1;
 for(int i = 1 ; i &amp;lt; n ; i ++)
 {
 //二分查找,复杂度 log(n)
 int b,e,m;
 b = 0;
 e = lth - 1;
 while(b &amp;lt;= e &amp;amp;&amp;amp; e &amp;gt;= 0)
 {
 m = (b + e) / 2;
 if(LIScmp(lR[m],list[i]))
 b = m + 1;
 else
 e = m - 1;
 }
 lR[b] = list[i];
 if(b &amp;gt;= lth)
 lth ++;
 if(lth == length)
 {
 for(b = 0 ; b &amp;lt; length ; b ++)
 lengthRecord[b] = lR[b];
 break;
 }
 }
 //计算序列部分代码与之前的类似,可以直接Copy然后修改
 return length;
}
&lt;/code>&lt;/pre></description></item><item><title>Prime最小生成树(个人模板)</title><link>//owent.net/2009/75.html</link><pubDate>Tue, 15 Sep 2009 16:43:29 +0000</pubDate><guid>//owent.net/2009/75.html</guid><description>&lt;pre>&lt;code class="language-cpp">//Prime连通路模块
#define N 1000 //最大数据规模
#define MAXNUM 3000000 //最大路径长度
typedef double PrimeType;//路径类型

PrimeType PrimeRecord[N];
PrimeType dis[N][N];
int isLined[N] = {1,0};

PrimeType GetPrimeLength(const long n)
{
 PrimeType tmpLen = MAXNUM;
 long tmpPos = 0,left = n - 1;
 PrimeType sumLen = 0;

 for(long i = 1 ; i &amp;lt; n ; i ++)
 PrimeRecord[i] = dis[0][i];
 while(left --)
 {
 tmpLen = MAXNUM;
 for(long i = 1 ; i &amp;lt; n ; i ++)
 if(!isLined[i] &amp;amp;&amp;amp; PrimeRecord[i] &amp;lt; tmpLen)
 tmpPos = i,tmpLen = PrimeRecord[i];

 sumLen += tmpLen;
 isLined[tmpPos] ++;
 for(long i = 1 ; i &amp;lt; n ; i ++)
 if(dis[tmpPos][i] &amp;lt; PrimeRecord[i])
 PrimeRecord[i] = dis[tmpPos][i];
 }

 return sumLen;
}
&lt;/code>&lt;/pre></description></item><item><title>矩阵相关 (增强中)</title><link>//owent.net/2009/76.html</link><pubDate>Tue, 15 Sep 2009 16:39:11 +0000</pubDate><guid>//owent.net/2009/76.html</guid><description>&lt;pre>&lt;code class="language-cpp">//MULDATATYPE为矩阵元素类型,MAXMAT为最大矩阵大小

typedef long MULDATATYPE;
#define MAXMAT 100
#define inf 1000000000

#define fabs(x) ((x)&amp;gt;0?(x):-(x))
#define zero(x) (fabs(x)&amp;lt;1e-10)

struct mat
{
 long n,m;
 MULDATATYPE data[MAXMAT][MAXMAT];
 void operator =(const mat&amp;amp; a);
 mat operator +(const mat&amp;amp; a);
 mat operator -(const mat&amp;amp; a);
 //0-1邻接矩阵
 mat operator &amp;amp;(const mat&amp;amp; a);
 mat operator |(const mat&amp;amp; a);
};

//c=a*b
//注意引用
int Mat_MulMode(mat&amp;amp; c,const mat&amp;amp; a,const mat&amp;amp; b,MULDATATYPE mod)
{
 long i,j,k;
 if (a.m != b.n)
 return 0;
 c.n = a.n , c.m = b.m;
 for (i = 0 ; i &amp;lt; c.n ; i ++)
 for (j = 0 ; j &amp;lt; c.m ; j ++)
 for (c.data[i][j] = k = 0 ; k &amp;lt; a.m ; k ++)
 c.data[i][j] = (c.data[i][j] + a.data[i][k] * b.data[k][j]) % mod;
 return 1;
}
//c=a^b(其中必须满足b&amp;gt;0)
int Mat_PowMode(mat&amp;amp; c,mat a,long b,MULDATATYPE mod)
{
 c = a;
 b --;
 while(b)
 {
 mat tmp;
 if(b &amp;amp; 1)
 {
 tmp = c;
 Mat_MulMode(c,tmp,a,mod);
 }
 tmp = a;
 Mat_MulMode(a,tmp,tmp,mod);
 b = b&amp;gt;&amp;gt;1;
 }
 return 1;
}
//c=a+b
int Mat_AddMode(mat&amp;amp; c,const mat&amp;amp; a,const mat&amp;amp; b,MULDATATYPE mod)
{
 long i,j;
 if (a.n != b.n || a.m != b.m)
 return 0;
 c.n = a.n , c.m = b.m;
 for (i = 0 ; i &amp;lt; c.n ; i ++)
 for (j = 0 ; j &amp;lt; c.m ; j ++)
 c.data[i][j] = (a.data[i][j] + b.data[i][j]) % mod;
 return 1;
}
//c=a-b
int Mat_SubMode(mat&amp;amp; c,const mat&amp;amp; a,const mat&amp;amp; b,MULDATATYPE mod)
{
 long i,j;
 if (a.n != b.n || a.m != b.m)
 return 0;
 c.n = a.n , c.m = b.m;
 for (i = 0 ; i &amp;lt; c.n ; i ++)
 for (j = 0 ; j &amp;lt; c.m ; j ++)
 c.data[i][j] = (a.data[i][j] - b.data[i][j]) % mod;
 return 1;
}


void mat::operator =(const mat&amp;amp; a)
{
 n = a.n;
 m = a.m;
 for(int i = 0 ; i &amp;lt; n ; i ++)
 for(int j = 0 ; j &amp;lt; m ; j ++)
 data[i][j] = a.data[i][j];
}
mat mat::operator +(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] + a.data[i][j];
 return tmpMat;
}
mat mat::operator -(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] - a.data[i][j];
 return tmpMat;
}
mat mat::operator &amp;amp;(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] &amp;amp; a.data[i][j];
 return tmpMat;
}
mat mat::operator |(const mat &amp;amp;a)
{
 long i,j;
 mat tmpMat;
 tmpMat.m = m;
 tmpMat.n = n;
 for(i = 0 ; i &amp;lt; n ; i ++)
 for(j = 0 ; j &amp;lt; m ; j ++)
 tmpMat.data[i][j] = data[i][j] | a.data[i][j];
 return tmpMat;
}
&lt;/code>&lt;/pre></description></item><item><title>点到直线距离 和 线段间最短距离 (OWenT 模板)</title><link>//owent.net/2009/80.html</link><pubDate>Fri, 14 Aug 2009 11:33:38 +0000</pubDate><guid>//owent.net/2009/80.html</guid><description>&lt;p>点到直线距离&lt;/p>
&lt;pre>&lt;code class="language-cpp">// (x0,y0)到(x1,y1)和(x2,y2)确定的直线的距离

double disBetweenPointAndLine(double x0,double y0,double x1,double y1,double x2,double y2)
{
 //化为ax+by+c=0的形式
 double a = y1-y2;
 double b = x2-x1;
 double c = x1*y2-x2*y1;
 double d = (a*x0+b*y0+c)/sqrt(a*a+b*b);
 /*
 如果是线段判断垂足

 double xp = (b*b*x0-a*b*y0-a*c)/(a*a+b*b);
 double yp = (-a*b*x0+a*a*y0-b*c)/(a*a+b*b);
 double xb = (x1&amp;gt;x2)?x1:x2;
 double yb = (y1&amp;gt;y2)?y1:y2;
 double xs = x1+x2-xb;
 double ys = y1+y2-yb;
 if(xp &amp;gt; xb || xp &amp;lt; xs || yp &amp;gt; yb || yp &amp;lt; ys)
 {
 d = sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
 if(d &amp;gt; sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2)))
 d = sqrt((x0 - x2) * (x0 - x2) + (y0 - y2) * (y0 - y2));
 }
 */
 return fabs(d);
}
&lt;/code>&lt;/pre>
&lt;p>线段间最短距离&lt;/p></description></item><item><title>连接最多点直线 (OWenT 个人模板)</title><link>//owent.net/2009/81.html</link><pubDate>Fri, 14 Aug 2009 11:30:49 +0000</pubDate><guid>//owent.net/2009/81.html</guid><description>&lt;pre>&lt;code class="language-cpp">//n每个用例的点个数
//MAXN为最大点个数
//PTYPE为坐标值类型
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;

#define MAXN 1005
#define EPS 1e-10
typedef double PTYPE;

struct point
{
 PTYPE x,y;
};
struct node
{
 PTYPE k;
};
int cmp(const void * a, const void * b)
{
 return((*(PTYPE*)a-*(PTYPE*)b&amp;gt;0)?1:-1);
}
node numK[MAXN * MAXN / 2];
point pt[MAXN];
int main()
{

 int n , maxNum = 1 , tmpNum = 0;
 while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n),n)
 {
 for(int i = 0 ; i &amp;lt; n ; i ++)
 scanf(&amp;quot;%lf %lf&amp;quot;,&amp;amp;pt[i].x,&amp;amp;pt[i].y);
 for(int i = 0 ; i &amp;lt; n ; i ++)
 {
 int pos = 0;
 for(int j = i + 1 ; j &amp;lt; n ; j ++)
 if((pt[i].x - pt[j].x) &amp;gt; EPS)
 numK[pos ++].k = (pt[j].y - pt[i].y) / (pt[j].x - pt[i].x);
 else
 numK[pos ++].k = 100000;

 qsort(numK,pos,sizeof(numK[0]),cmp);
 int tmpNum = 2;
 for(int j = 1 ; j &amp;lt; pos ; j ++)
 {
 if(numK[j].k == numK[j - 1].k)
 tmpNum ++;
 else
 {
 if(tmpNum &amp;gt; maxNum)
 maxNum = tmpNum;
 tmpNum = 2;
 }
 }
 if(tmpNum &amp;gt; maxNum)
 maxNum = tmpNum;
 }


 printf(&amp;quot;%d\n&amp;quot;,maxNum);
 maxNum = 1;
 }
 return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>并查集 模板</title><link>//owent.net/2009/91.html</link><pubDate>Wed, 15 Jul 2009 09:05:54 +0000</pubDate><guid>//owent.net/2009/91.html</guid><description>&lt;pre>&lt;code class="language-cpp">//并查集
//注意类型匹配
const int maxn = 100002;
int DSet[maxn];
void init(int n) {
 for(int i = 0 ; i &amp;lt;= n ; i ++)
 DSet[i] = i;
}
int findP(int id) {
if(DSet[id] != id)
 DSet[id] = findP(DSet[id]);
 return DSet[id];
}
//返回根节点ID
int UnionEle(int a,int b) {
 a = findP(a);
 b = findP(b);
 if(a &amp;gt; b)
 a ^= b ^= a ^= b;
 DSet[b] = a;
 return a;
}
&lt;/code>&lt;/pre></description></item><item><title>模式匹配(kmp)个人模板</title><link>//owent.net/2009/92.html</link><pubDate>Mon, 06 Jul 2009 20:34:01 +0000</pubDate><guid>//owent.net/2009/92.html</guid><description>&lt;pre>&lt;code class="language-cpp">/**
 * KMP模式匹配
 * 算法复杂度O(m+n)
 * ACM 模板 
 *
 * @Author OWenT
 * @link http://www.owent.net
 */

// 最大字符串长度
const int maxLen = 10000;
// 前一个匹配位置,多次匹配注意要重新初始化
// 注：preMatch[i]表示0~preMatch[i-1]能和?~i匹配
int preMatch[maxLen]={0};

/**
 * kmp匹配算法
 * @param char[] source 查找源
 * @param char[] checked 查找目标
 * @return int 根据以下两个分支返回值分别表示不同的含义
 */
int kmp_match(char source[],char checked[]) {
 int i = 0, j = 0;
 memset(preMatch, 0, sizeof(preMatch));

 if(!checked[i]) // 被匹配串为空串，直接返回 0
 return 0;

 ++ i;
 while(checked[i]) {
 for(j = preMatch[i - 1]; checked[i] != checked[j] &amp;amp;&amp;amp; j; j = preMatch[j - 1]);
 preMatch[i] = (checked[i] == checked[j])? j + 1 : 0 ;
 ++ i;
 }
 //计算匹配子串个数(子串间无重叠)(与以下一起二选一)
 int num = 0;//计数变量
 for(i = j = 0; source[i]; ++ i) {
 if(checked[j] == source[i])
 ++ j;
 else if(j)
 -- i, j = preMatch[j - 1];

 if(!checked[j])
 ++ num, j = 0;//如果要子串间重叠 则此句中j = 0 改成 j = preMatch[j - 1]
 }
 return num;

 //计算首个匹配子串位置(与以上一起二选一)
 for(i = j = 0; checked[j] &amp;amp;&amp;amp; source[i]; ++ i) {
 if(checked[j] == source[i])
 ++ j;
 else if(j)
 -- i, j = preMatch[j - 1];
 }

 //返回匹配的串的第一个字符出现位置(从1开始计数,0表示无匹配)
 if(!checked[j])
 return i - j + 1;
 else
 return 0;

 return 0;
}
&lt;/code>&lt;/pre></description></item></channel></rss>