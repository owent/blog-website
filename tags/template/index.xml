<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>template on I&#39;m OWenT</title><link>//owent.net/tags/template.html</link><description>Recent content in template on I&#39;m OWenT</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>admin@owent.net (OWenT)</managingEditor><webMaster>admin@owent.net (OWenT)</webMaster><lastBuildDate>Tue, 03 Jun 2014 20:55:44 +0000</lastBuildDate><atom:link href="//owent.net/tags/template/index.xml" rel="self" type="application/rss+xml"/><item><title>再议 C&#43;&#43; 11 Lambda表达式</title><link>//owent.net/2014/1060.html</link><pubDate>Tue, 03 Jun 2014 20:55:44 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1060.html</guid><description>目录 C++ 的Lambda表达式 C++ 11 标准发布，各大编译器都开始支持里面的各种新特性，其中一项比较有意思的就是lambda表达式。 语法规则 C++ 11 Lam</description></item><item><title>捣鼓一个协程库</title><link>//owent.net/2014/1000.html</link><pubDate>Wed, 05 Mar 2014 21:52:49 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/1000.html</guid><description>今年准备安安心心写一个协程库。一方面是觉得协程挺有意思，另一方面也是因为C/C++在这方面没有一个非常权威的解决方案。 按照我自己风格还是喜欢</description></item><item><title>C&#43;&#43;11动态模板参数和type_traits</title><link>//owent.net/2014/971.html</link><pubDate>Mon, 27 Jan 2014 16:27:46 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2014/971.html</guid><description>C++11标准里有动态模板参数已经是众所周知的事儿了。但是当时还有个主流编译器还不支持。 但是现在，主要的编译器。VC(Windows),GC</description></item><item><title>std和boost的function与bind实现剖析</title><link>//owent.net/2013/938.html</link><pubDate>Thu, 28 Nov 2013 22:01:30 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2013/938.html</guid><description>用过std和boost的function对象和bind函数的童鞋们都知道这玩意用起来腰不酸了，腿不疼了，心情也舒畅了。先上一个简单得示例： std::string</description></item><item><title>ACM 计算几何 个人模板</title><link>//owent.net/2010/11.html</link><pubDate>Mon, 04 Oct 2010 11:19:02 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2010/11.html</guid><description>/** * 二维ACM计算几何模板 * 注意变量类型更改和EPS * #include &amp;lt;cmath&amp;gt; * #include &amp;lt;cstdio&amp;gt; * By OWenT */ const double eps = 1e-8; const double pi = std::acos(-1.0); //点 class point { public: double x, y; point(){}; point(double x, double y):x(x),y(y){}; static int xmult(const point &amp;amp;ps, const point &amp;amp;pe, const</description></item><item><title>简易四则运算(ACM个人模板)</title><link>//owent.net/2010/17.html</link><pubDate>Tue, 10 Aug 2010 18:40:31 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2010/17.html</guid><description>/** * 简易四则运算（栈实现） * #include &amp;lt;stack&amp;gt; * #include &amp;lt;cstring&amp;gt; */ std::stack&amp;lt;char&amp;gt; opr; std::stack&amp;lt;double&amp;gt; num; char oprPRI[256]; //初始化调用 void initCalc() { //优先级设置 char oprMap[7][2] = { {&#39;+&#39;, 1}, {&#39;-&#39;, 1}, {&#39;*&#39;, 2}, {&#39;/&#39;, 2}, {&#39;^&#39;, 3}, {&#39;(&#39;, 100}, {&#39;)&#39;, 0} }; for(int i = 0; i &amp;lt; 7; i</description></item><item><title>数论模板（个人模板）</title><link>//owent.net/2010/18.html</link><pubDate>Mon, 09 Aug 2010 15:54:02 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2010/18.html</guid><description>基础函数: // 最大公约数,欧几里得定理 int gcd(int a, int b) { return b?gcd(b, a % b): a; } // 拓展欧几里得定理 // 求解ax + by = gcd(a,b) int ext_gcd(int a, int b, int &amp;amp;x, int &amp;amp;y) { int tmp, ret; if(!b) { x = 1; y = 0;</description></item><item><title>树状数组模块(个人模板)</title><link>//owent.net/2010/30.html</link><pubDate>Thu, 06 May 2010 13:51:29 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2010/30.html</guid><description>树状数组模块 ACM个人模板 POJ 2155 题目测试通过 /** * 树状数组模块 * 下标从0开始 */ typedef long DG_Ran; typedef long DG_Num; const DG_Num DG_MAXN = 1005; //2^n DG_Num LowBit(DG_Num n) { return n &amp;amp; (-n); } //获取父节点索引 DG_Num DGFather(DG_Num n)</description></item><item><title>线性筛法求质数(素数)表 及其原理</title><link>//owent.net/2010/32.html</link><pubDate>Mon, 03 May 2010 11:20:33 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2010/32.html</guid><description>/** * 线性筛法求素数表 * 复杂度: O(n) */ const long MAXP = 1000000; long prime[MAXP] = {0},num_prime = 0; int isNotPrime[MAXP] = {1, 1}; void GetPrime_Init()//初始化调用 { for(long i = 2 ; i &amp;lt; MAXP ; i ++) { if(!</description></item><item><title>Hash模板 个人模板</title><link>//owent.net/2010/54.html</link><pubDate>Mon, 15 Mar 2010 12:58:47 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2010/54.html</guid><description>/** * Hash模板 * Based: 0 * template&amp;lt;unsigned long _SZ,class _T, unsigned long *pFun(_T _Off)&amp;gt; * class _My_Hash_ToInt * 传入数据大小_SZ,传入类型_T,Hash函数 * 传入类型_T必须重载 = 和 == 符号 * 收录了ELF</description></item><item><title>最长单调子序列 复杂度nlog(n)</title><link>//owent.net/2009/74.html</link><pubDate>Wed, 16 Sep 2009 04:44:59 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/74.html</guid><description>//最长单调子序列 复杂度nlog(n) //参数(原序列,序列长度,生成的序列),传入序列长度必须大于0 //返回值中lengthRecord中</description></item><item><title>Prime最小生成树(个人模板)</title><link>//owent.net/2009/75.html</link><pubDate>Tue, 15 Sep 2009 16:43:29 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/75.html</guid><description>//Prime连通路模块 #define N 1000 //最大数据规模 #define MAXNUM 3000000 //最大路径长度 typedef double PrimeType;//路径类型 PrimeType PrimeRecord[N]; PrimeType dis[N][N]; int isLined[N] = {1,0}; PrimeType GetPrimeLength(const long n) { PrimeType tmpLen = MAXNUM; long</description></item><item><title>矩阵相关 (增强中)</title><link>//owent.net/2009/76.html</link><pubDate>Tue, 15 Sep 2009 16:39:11 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/76.html</guid><description>//MULDATATYPE为矩阵元素类型,MAXMAT为最大矩阵大小 typedef long MULDATATYPE; #define MAXMAT 100 #define inf 1000000000 #define fabs(x) ((x)&amp;gt;0?(x):-(x)) #define zero(x) (fabs(x)&amp;lt;1e-10) struct mat { long n,m; MULDATATYPE data[MAXMAT][MAXMAT]; void operator =(const mat&amp;amp; a); mat operator +(const mat&amp;amp; a); mat operator -(const mat&amp;amp;</description></item><item><title>点到直线距离 和 线段间最短距离 (OWenT 模板)</title><link>//owent.net/2009/80.html</link><pubDate>Fri, 14 Aug 2009 11:33:38 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/80.html</guid><description>点到直线距离 // (x0,y0)到(x1,y1)和(x2,y2)确定的直线的距离 double disBetweenPointAndLine(double x0,double y0,double x1,double y1,double x2,double y2) { //化为ax+by+c=0的形式 double a = y1-y2; double b =</description></item><item><title>连接最多点直线 (OWenT 个人模板)</title><link>//owent.net/2009/81.html</link><pubDate>Fri, 14 Aug 2009 11:30:49 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/81.html</guid><description>//n每个用例的点个数 //MAXN为最大点个数 //PTYPE为坐标值类型 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cmath&amp;gt; using namespace std; #define MAXN 1005 #define EPS 1e-10 typedef double PTYPE; struct point { PTYPE x,y; }; struct node { PTYPE k; }; int cmp(const void * a, const void *</description></item><item><title>并查集 模板</title><link>//owent.net/2009/91.html</link><pubDate>Wed, 15 Jul 2009 09:05:54 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/91.html</guid><description>//并查集 //注意类型匹配 const int maxn = 100002; int DSet[maxn]; void init(int n) { for(int i = 0 ; i &amp;lt;= n ; i ++) DSet[i] = i; } int findP(int id) { if(DSet[id] != id) DSet[id] = findP(DSet[id]); return DSet[id]; } //返回根节点ID int UnionEle(int a,int b) { a = findP(a); b</description></item><item><title>模式匹配(kmp)个人模板</title><link>//owent.net/2009/92.html</link><pubDate>Mon, 06 Jul 2009 20:34:01 +0000</pubDate><author>admin@owent.net (OWenT)</author><guid>//owent.net/2009/92.html</guid><description>/** * KMP模式匹配 * 算法复杂度O(m+n) * ACM 模板 * * @Author OWenT * @link http://www.owent.net */ // 最大字符串长度 const int maxLen = 10000; // 前一个匹配位置,多次匹配注意要重新初始化 // 注：</description></item></channel></rss>