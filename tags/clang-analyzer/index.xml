<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clang-Analyzer on I'm OWenT</title><link>//owent.net/tags/clang-analyzer.html</link><description>Recent content in Clang-Analyzer on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md"&gt;&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /&gt;&lt;/a&gt;</copyright><lastBuildDate>Mon, 22 Dec 2025 00:15:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/clang-analyzer/index.xml" rel="self" type="application/rss+xml"/><item><title>UE使用CodeChecker和clang-tidy生成静态分析报告</title><link>//owent.net/2025/2507.html</link><pubDate>Mon, 22 Dec 2025 00:15:45 +0000</pubDate><guid>//owent.net/2025/2507.html</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;现代化的C++项目可以借助多种静态分析工具来检查和发现潜在问题，包括空指针访问风险、未定义行为（UB）、内存错误等。&lt;/p&gt;
&lt;p&gt;在我们的项目中，服务器工程基于 CMake 构建系统，可以方便地利用社区支持来集成这些静态分析工具，如 &lt;a href="https://clang.llvm.org/extra/clang-tidy/"&gt;clang-tidy&lt;/a&gt;、&lt;a href="https://clang-analyzer.llvm.org/"&gt;clang-analyzer&lt;/a&gt;、&lt;a href="https://codechecker.readthedocs.io/"&gt;CodeChecker&lt;/a&gt; 等。然而，另一部分 C++ 代码运行在 UE（Unreal Engine）引擎中。由于 UE 在编译流程上做了一些特殊扩展，再加上 UBT（UnrealBuildTool）工具在某些能力上的限制，直接开启静态分析会遇到一些问题：&lt;/p&gt;</description></item><item><title>再度优化GCC、LLVM、Clang、libc++、libc++abi等套件的构建脚本</title><link>//owent.net/2022/2205.html</link><pubDate>Sun, 17 Apr 2022 23:43:45 +0000</pubDate><guid>//owent.net/2022/2205.html</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;一直以来，我都维护了完整的 &lt;a href="https://github.com/owent-utils/bash-shell/tree/main/GCC%20Installer"&gt;GCC 工具链构建工具&lt;/a&gt; 和 &lt;a href="https://github.com/owent-utils/bash-shell/tree/main/LLVM%26Clang%20Installer"&gt;LLVM,Clang,libc++,libc++abi工具链构建工具&lt;/a&gt; 。
一方面是为了测试和体验新版本编译器的功能和利用一些更现代化的工具检查代码中的风险，另一方面也是为了给我得很多开源仓库做多版本适配。
其中所有的编译期依赖项（不包括 tar,awk等可执行程序的工具）都是自己构建的，这样也能管理好某些新版本组件需要的新版本依赖项，并且做到跨发行版兼容。同时很多发行版自带的 LLVM+Clang 套件都缺斤少两，有的缺少 &lt;code&gt;clang-analyzer&lt;/code&gt; ，有的缺少 &lt;code&gt;clang-format&lt;/code&gt; ，也有的缺少 &lt;code&gt;libc++&lt;/code&gt; 和 &lt;code&gt;libc++abi&lt;/code&gt; 或者缺少sanitizer组件。我也是根据自己的需要编译并输出了大多数开发工具，甚至还有一些开发库以便二次开发（比如用libclang写工具来复用libcang的AST功能）。&lt;/p&gt;</description></item><item><title>再次重构LLVM+Clang+libcxx+libc++abi+其他相关工具的构建流程</title><link>//owent.net/2021/2107.html</link><pubDate>Sun, 29 Aug 2021 20:29:56 +0000</pubDate><guid>//owent.net/2021/2107.html</guid><description>&lt;h2 id="背景"&gt;背景&lt;/h2&gt;
&lt;p&gt;我们有时候写一些基础性类库或者实验新功能的时候，常常需要使用到最新版本的GCC和Clang。一些Linux发行版的源里和一些工具链（比如MSYS2）里其实自带LLVM套件的包，&lt;a href="https://llvm.org/"&gt;LLVM&lt;/a&gt; 官网也提供一些常见平台的预编译包下载。
那为什么我们还要自己编译呢？如果有注意到的小伙伴可能会发现，很多平台的源和 &lt;a href="https://llvm.org/"&gt;LLVM&lt;/a&gt; 官网 里下载的预编译包，其实是缺失很多组件的。有些没有libc++和libc++abi（CentOS 8），有些没有Sanitizer相关的组件，有些缺失其他的组件。而Clang虽然支持GCC的libstdc++，但是一方面我们写基础性类库还是要优先考虑原生STL库的兼容性，另一方面Clang对libstdc++的支持也不是太好，特别是有些第三方库在这个组合下也是没有适配得很好，同时gdb和libc++的搭配有时候也不是很完善。
所以我们就需要一个组件尽可能开完整地包含LLVM，Clang,libc++,libc++abi还有其他周边工具（各类Sanitizer，clang-tiny,clang-analyzer等等）的工具链。&lt;/p&gt;</description></item></channel></rss>