<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on I'm OWenT</title><link>//owent.net/tags/rust.html</link><description>Recent content in Rust on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Tue, 09 Mar 2021 19:19:45 +0000</lastBuildDate><atom:link href="//owent.net/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>[Rust] 实现一个线程安全且迭代器可以保存的链表</title><link>//owent.net/2021/2102.html</link><pubDate>Tue, 09 Mar 2021 19:19:45 +0000</pubDate><guid>//owent.net/2021/2102.html</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>今年有个想法，重新设计 &lt;a href="https://github.com/atframework/libatbus">libatbus&lt;/a> 然后用 &lt;a href="https://www.rust-lang.org/">Rust&lt;/a> 实现出来，然后可以加入一些云原生的支持。这需要一个定时器模块，我看了下 &lt;a href="https://www.rust-lang.org/">Rust&lt;/a> 现有的几种定时器的实现，大多是基于堆或树的结构的，没有找到jiffies定时器的实现，所以想自己实现一个算了。这个定时器的实现又需要类似 C++ 的 &lt;code>std::list::iterator&lt;/code> 的 &lt;strong>插入和删除某个迭代器对其他迭代器没有影响&lt;/strong> 的特性，但是 &lt;a href="https://www.rust-lang.org/">Rust&lt;/a> 的数据结构都不是这种设计模型。所以就决定自己写一个吧。&lt;/p></description></item><item><title>libcopp接入C++20 Coroutine和一些过渡期的设计</title><link>//owent.net/2020/2004.html</link><pubDate>Fri, 22 May 2020 15:36:58 +0000</pubDate><guid>//owent.net/2020/2004.html</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近GCC 10.1.0 发布，三大编译器（MSVC、GCC、Clang）都已经支持了&lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20协程&lt;/a>，之前给 &lt;a href="https://github.com/owent/libcopp/">libcopp&lt;/a> 接入 &lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20协程&lt;/a> 的计划也就提上了日程。&lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20协程&lt;/a> 在创建、切换开销和内存分配上和传统有栈协程相比有着无可比拟的优势。但是C++20全面普及还有相当长一段时间，所以我们设计的重要目标之一就是能够让以后的迁移更容易且更平滑地进行，本文则是记录了 &lt;a href="https://github.com/owent/libcopp/">libcopp&lt;/a> 接入 &lt;a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20协程&lt;/a> 时地一些性能上和平滑接入上的思考和成果。&lt;/p></description></item><item><title>Rust玩具-企业微信机器人通用服务</title><link>//owent.net/2019/1901.html</link><pubDate>Thu, 03 Jan 2019 17:08:50 +0000</pubDate><guid>//owent.net/2019/1901.html</guid><description>&lt;h2 id="新玩具-企业微信机器人">新玩具-企业微信机器人&lt;/h2>
&lt;p>这个机器人其实蛮久前就做好了，现在才写了点分享出来。 最近企业微信不断地开放了机器人的接口，所以我想想拿来做一些开发工具集成也是挺不错的，顺便也是为了继续熟悉一下 &lt;a href="https://rust-lang.org/">Rust&lt;/a> 的编程习惯。 那么这次就大量使用 &lt;a href="https://crates.io/crates/futures">futures&lt;/a> 来实现这个机器人的接口服务，这也是即将到来的无栈协程语法糖 &lt;a href="https://crates.io/crates/futures-await">await&lt;/a> 的基石。&lt;/p></description></item><item><title>Rust的第二次接触-写个小服务器程序</title><link>//owent.net/2018/1809.html</link><pubDate>Wed, 12 Sep 2018 12:29:50 +0000</pubDate><guid>//owent.net/2018/1809.html</guid><description>&lt;h2 id="just-practice">JUST PRACTICE&lt;/h2>
&lt;p>蛮久前入门了一下 &lt;a href="https://rust-lang.org/">Rust&lt;/a> 语言。它的设计模型非常地吸引C/C++的开发者。但是学习语言嘛还是要练习一下，之前也用它给我们项目写了个命令行小工具。这回拿来写个小型的服务器程序吧。&lt;/p></description></item><item><title>可执行文件压缩</title><link>//owent.net/2018/1805.html</link><pubDate>Tue, 24 Apr 2018 10:58:05 +0000</pubDate><guid>//owent.net/2018/1805.html</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>最近看&lt;a href="https://rust-lang.org/">Rust&lt;/a>相关东西的时候看到一篇关于压缩可执行文件的文章。压缩可执行文件对嵌入式开发特别有用，但是延伸一下用来减少我们游戏行业里预编译的工具二进制包大小和Android/iOS的库也是蛮有用的。&lt;/p>
&lt;p>原文见这里： &lt;a href="https://jamesmunns.com/blog/tinyrocket/">https://jamesmunns.com/blog/tinyrocket/&lt;/a>&lt;/p>
&lt;h1 id="基本流程">基本流程&lt;/h1>
&lt;ol>
&lt;li>Release编译，移除调试符号文件，开启最小化size优化(-Oz)&lt;/li>
&lt;li>使用LLVM的全量LTO&lt;/li>
&lt;li>使用xargo重新编译标准库(std)和核心库(core)（这个C/C++不容易模仿，而且编译选项十分难搞）&lt;/li>
&lt;li>移除&lt;a href="https://github.com/jemalloc/jemalloc">jemalloc&lt;/a>（服务器程序还是留着比较好，内置的malloc实现一般碎片比较厉害。虽然C/C++默认也不是&lt;a href="https://github.com/jemalloc/jemalloc">jemalloc&lt;/a>，很多项目为了新能还是会用它）&lt;/li>
&lt;li>移除panic的详情信息（这个仅适用于&lt;a href="https://rust-lang.org/">Rust&lt;/a>）&lt;/li>
&lt;li>strip（由GNU的&lt;a href="https://www.gnu.org/software/binutils/">binutils&lt;/a>提供），参考命令: &lt;code>strip [二进制]&lt;/code>&lt;/li>
&lt;li>&lt;a href="https://upx.github.io/">UPX&lt;/a>进一步压缩加壳&lt;/li>
&lt;/ol>
&lt;h1 id="尝试改造优化">尝试改造优化&lt;/h1>
&lt;p>然后尝试使用上面的流程改造我们的 &lt;strong>gmtools-cli&lt;/strong> 。原先我是直接开LTO+Release编译的，编出的文件大小为4.4MB（4520728字节）。&lt;/p></description></item><item><title>初识Rust</title><link>//owent.net/2018/1804.html</link><pubDate>Mon, 23 Apr 2018 21:54:50 +0000</pubDate><guid>//owent.net/2018/1804.html</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>虽然我主要使用C++，但是最近也想学点现代化的新语言。初步想的是从&lt;a href="https://golang.org/">golang&lt;/a>和&lt;a href="https://rust-lang.org/">Rust&lt;/a>里先选一个。&lt;/p>
&lt;p>这两年&lt;a href="https://golang.org/">golang&lt;/a>在国内很火，最大的特点莫过于语言层面提供了协程支持，能够极大地简化异步逻辑地理解。我之前也接触过一点，还写了个&lt;a href="https://gist.github.com/owent/2286768f2586521600c9fd1700cbf845">goroutine压力测试&lt;/a>对比我的&lt;a href="https://github.com/owent/libcopp">libcopp&lt;/a>的性能。但是&lt;a href="https://golang.org/">golang&lt;/a>的语法我实在不喜欢，特别是那个不管啥类型声明都是反着来，感觉在复杂的类型下会非常反人类。而且听用过的人说&lt;a href="https://golang.org/">golang&lt;/a>的GC还很不稳定。另外之前有新闻说&lt;a href="https://golang.org/">golang&lt;/a>正在准备2.0，2.0版本即将加入泛型支持，然后导致很多语法不兼容和语法分析得重写。所以我还是懒得踩这个坑了，至少等2.0出来再说。&lt;/p>
&lt;p>&lt;a href="https://rust-lang.org/">Rust&lt;/a>是Mozilla搞出来想拿来重写Firefox的。说实话Mozilla和Google还有点差距，导致&lt;a href="https://rust-lang.org/">Rust&lt;/a>的发展还比较慢。对比起来就是感觉&lt;a href="https://golang.org/">golang&lt;/a>很快就提供了一些快速可用的原型给大型项目使用，标准库也足够丰富。而&lt;a href="https://rust-lang.org/">Rust&lt;/a>还纠结在底层、语言层面的优化和最求极致。很多组件都还不成熟，编程设计模型也还没完全统一。&lt;/p>
&lt;p>但是接触了一点&lt;a href="https://rust-lang.org/">Rust&lt;/a>以后，我发现&lt;a href="https://rust-lang.org/">Rust&lt;/a>真的是挠到了C++程序员的痒点，语言层面解决了用C++得费很多脑力和用各种奇技淫巧实现并且还不能完全阻止被绕过的质量控制问题，而且保留了C++很多编译期推断得高级特性。并且和C++一样，提供给你能力，但不限定你方法提供 &lt;strong>零成本抽象（zero-cost abstractions）&lt;/strong> 或者说叫 &lt;strong>零开销（zero-overhead）&lt;/strong>。&lt;/p></description></item></channel></rss>