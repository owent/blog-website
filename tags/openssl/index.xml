<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Openssl on I'm OWenT</title><link>//owent.net/tags/openssl.html</link><description>Recent content in Openssl on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md"&gt;&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /&gt;&lt;/a&gt;</copyright><lastBuildDate>Sun, 12 Dec 2021 15:23:00 +0000</lastBuildDate><atom:link href="//owent.net/tags/openssl/index.xml" rel="self" type="application/rss+xml"/><item><title>适配Boringssl和OpenSSL 3.0</title><link>//owent.net/2021/2110.html</link><pubDate>Sun, 12 Dec 2021 15:23:00 +0000</pubDate><guid>//owent.net/2021/2110.html</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.openssl.org/"&gt;openssl&lt;/a&gt; 3.0发布好一阵子了，我的 &lt;a href="https://github.com/atframework/atframe_utils"&gt;atframe_utils&lt;/a&gt; 其实也挺早前就完成了对 &lt;a href="https://www.openssl.org/"&gt;openssl&lt;/a&gt; 3.0 和 &lt;a href="https://github.com/google/boringssl"&gt;boringssl&lt;/a&gt; 的适配。但是由于懒，一直没写这篇文章。在升级 [openssl] 3.0 和 &lt;a href="https://github.com/google/boringssl"&gt;boringssl&lt;/a&gt; 还是碰到了一些问题的，有些是由于接口变化，有些是由于功能支持还有些也和构建系统相关。还是有必要记录一下，至少能方便以后查找。&lt;/p&gt;</description></item><item><title>近期对libatapp的一些优化调整(增加服务发现和连接管理,支持yaml等)</title><link>//owent.net/2020/2007.html</link><pubDate>Sun, 04 Oct 2020 15:43:17 +0000</pubDate><guid>//owent.net/2020/2007.html</guid><description>&lt;p&gt;最近给 &lt;a href="https://github.com/atframework/libatapp"&gt;libatapp&lt;/a&gt; 增加了一系列改造，非常多且琐碎，这里简单记录下吧。&lt;/p&gt;
&lt;p&gt;首先是重构了配置管理。原来是手写在代码里的，因为原来上层的 &lt;a href="https://github.com/atframework/libatbus"&gt;libatbus&lt;/a&gt; 是不依赖 &lt;a href="https://github.com/protocolbuffers/protobuf"&gt;protobuf&lt;/a&gt; 的，现在 既然已经依赖 &lt;a href="https://github.com/protocolbuffers/protobuf"&gt;protobuf&lt;/a&gt; 了就转为 &lt;a href="https://github.com/protocolbuffers/protobuf"&gt;protobuf&lt;/a&gt; 管理了。同时现在还支持YAML配置，使用 &lt;a href="https://github.com/jbeder/yaml-cpp"&gt;yaml-cpp&lt;/a&gt; 来解析YAML文件，这个库也被一些其他知名的大型项目使用了，比如 &lt;a href="https://www.envoyproxy.io/"&gt;Envoy proxy&lt;/a&gt; 。 原来的conf/ini模式的配置也是支持的，现在加载配置的时候会尝试猜测以下配置文件是yaml还是conf/ini模式。 并且增加了统一的 &lt;em&gt;YAML转&lt;a href="https://github.com/protocolbuffers/protobuf"&gt;protobuf&lt;/a&gt;&lt;/em&gt; 、 &lt;em&gt;conf/ini转&lt;a href="https://github.com/protocolbuffers/protobuf"&gt;protobuf&lt;/a&gt;&lt;/em&gt; 和 &lt;em&gt;指定层级配置导出到&lt;a href="https://github.com/protocolbuffers/protobuf"&gt;protobuf&lt;/a&gt;&lt;/em&gt; 的接口来方便使用。比较特殊的是自定义日志配置后端的接入接口有了一些小变化，问题也不大。&lt;/p&gt;</description></item><item><title>Rust玩具-企业微信机器人通用服务</title><link>//owent.net/2019/1901.html</link><pubDate>Thu, 03 Jan 2019 17:08:50 +0000</pubDate><guid>//owent.net/2019/1901.html</guid><description>&lt;h2 id="新玩具-企业微信机器人"&gt;新玩具-企业微信机器人&lt;/h2&gt;
&lt;p&gt;这个机器人其实蛮久前就做好了，现在才写了点分享出来。 最近企业微信不断地开放了机器人的接口，所以我想想拿来做一些开发工具集成也是挺不错的，顺便也是为了继续熟悉一下 &lt;a href="https://rust-lang.org/"&gt;Rust&lt;/a&gt; 的编程习惯。 那么这次就大量使用 &lt;a href="https://crates.io/crates/futures"&gt;futures&lt;/a&gt; 来实现这个机器人的接口服务，这也是即将到来的无栈协程语法糖 &lt;a href="https://crates.io/crates/futures-await"&gt;await&lt;/a&gt; 的基石。&lt;/p&gt;</description></item><item><title>Rust的第二次接触-写个小服务器程序</title><link>//owent.net/2018/1809.html</link><pubDate>Wed, 12 Sep 2018 12:29:50 +0000</pubDate><guid>//owent.net/2018/1809.html</guid><description>&lt;h2 id="just-practice"&gt;JUST PRACTICE&lt;/h2&gt;
&lt;p&gt;蛮久前入门了一下 &lt;a href="https://rust-lang.org/"&gt;Rust&lt;/a&gt; 语言。它的设计模型非常地吸引C/C++的开发者。但是学习语言嘛还是要练习一下，之前也用它给我们项目写了个命令行小工具。这回拿来写个小型的服务器程序吧。&lt;/p&gt;</description></item><item><title>理解和适配AEAD加密套件</title><link>//owent.net/2018/1808.html</link><pubDate>Sun, 01 Jul 2018 20:49:50 +0000</pubDate><guid>//owent.net/2018/1808.html</guid><description>&lt;h2 id="什么是aead"&gt;什么是AEAD&lt;/h2&gt;
&lt;p&gt;按照维基百科的说法。AEAD的全称是Authenticated encryption (AE) and authenticated encryption with associated data (AEAD, variant of AE)。也就是带附加数据的加密和验证算法。&lt;/p&gt;
&lt;p&gt;我们很多涉及IO的系统收发数据的时候一般会加上一些校验码，以便检测IO错误。而对外的socket里，这个校验码还有一个功能是挡掉一些不正常的数据。如果这时候如果我们的数据需要带上加密的话，那就是AE了。然后AEAD就是在AE的基础上，增加一些自定义数据，用于防止猜解。&lt;/p&gt;</description></item></channel></rss>