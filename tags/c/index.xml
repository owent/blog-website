<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on I'm OWenT</title><link>//owent.net/tags/c.html</link><description>Recent content in C on I'm OWenT</description><generator>Hugo</generator><language>zh-cn</language><copyright>&lt;a rel="license" href="https://github.com/owent/blog-hugo/blob/master/LICENSE.md">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />&lt;/a></copyright><lastBuildDate>Tue, 24 Apr 2018 10:58:05 +0000</lastBuildDate><atom:link href="//owent.net/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>可执行文件压缩</title><link>//owent.net/2018/1805.html</link><pubDate>Tue, 24 Apr 2018 10:58:05 +0000</pubDate><guid>//owent.net/2018/1805.html</guid><description>前言 最近看Rust相关东西的时候看到一篇关于压缩可执行文件的文章。压缩可执行文件对嵌入式开发特别有用，但是延伸一下用来减少我们游戏行业里预编</description></item><item><title>C++的backtrace</title><link>//owent.net/2018/1801.html</link><pubDate>Mon, 08 Jan 2018 17:55:00 +0000</pubDate><guid>//owent.net/2018/1801.html</guid><description>开始之前 很多语言的log模块都有一个功能，就是在打log的时候能够追溯调用栈，有的时候对查bug能有点帮助。之前我也想过给我们的log模块加</description></item><item><title>GCC 7和LLVM+Clang+libc++abi 4.0的构建脚本</title><link>//owent.net/2017/1431.html</link><pubDate>Tue, 09 May 2017 11:17:55 +0000</pubDate><guid>//owent.net/2017/1431.html</guid><description>之前的版本发完，有空来更新一下之前的gcc和llvm+clang工具链的编译脚本了。其实GCC 7是才release没多久但是llvm 4.0发</description></item><item><title>重写了llvm+clang+libc++和libc++abi的构建脚本</title><link>//owent.net/2016/1309.html</link><pubDate>Sat, 19 Nov 2016 15:42:21 +0000</pubDate><guid>//owent.net/2016/1309.html</guid><description>由于之前整理的服务器框架已经完成了，就需要用各种静态分析工具跑一遍。原来的llvm+clang的编译脚本是从GCC那个脚本copy过来然后改</description></item><item><title>小记最近踩得两个C++坑</title><link>//owent.net/2015/1189.html</link><pubDate>Sat, 25 Jul 2015 14:53:44 +0000</pubDate><guid>//owent.net/2015/1189.html</guid><description>小记最近踩得两个C++坑 记一下最近踩得两个C++独有的暗坑，其中一个和ABI相关。第二个坑其实之前研究过，但是没有实例，这次算是碰到了个典型</description></item><item><title>Redis全异步(HA)Driver设计稿</title><link>//owent.net/2015/1182.html</link><pubDate>Sat, 04 Jul 2015 22:24:46 +0000</pubDate><guid>//owent.net/2015/1182.html</guid><description>Redis全异步高可用Driver设计稿 前言 现在Redis的集群功能已经Release。但是并没有一个官方直接提供的高可用性的API可以使用</description></item><item><title>我们的Lua类绑定机制</title><link>//owent.net/2015/1153.html</link><pubDate>Wed, 15 Apr 2015 16:16:39 +0000</pubDate><guid>//owent.net/2015/1153.html</guid><description>前言 最近一个人搞后台，框架底层+逻辑功能茫茫多，扛得比较辛苦，一直没抽出空来写点东西。 空闲的时间，完善了LLVM+Clang+libc++和</description></item><item><title>Android NDK undefined reference to ___tls_get_addr 错误</title><link>//owent.net/2015/1140.html</link><pubDate>Fri, 06 Feb 2015 20:27:16 +0000</pubDate><guid>//owent.net/2015/1140.html</guid><description>本来看到Android的ndk都开始用gcc4.8和gcc4.9了，而且gcc4.8.1开始支持全部的c++11的特性，我就很happy地用</description></item><item><title>tolua++内存释放坑</title><link>//owent.net/2015/1133.html</link><pubDate>Thu, 08 Jan 2015 22:03:42 +0000</pubDate><guid>//owent.net/2015/1133.html</guid><description>前言 本来想参考下tolua++的对象生命周期维护方式。一不小心发现了一个坑。 代码追踪 我这里用得是tolua++ 1.0.93版本。 tolua+</description></item><item><title>[libiniloader] Project</title><link>//owent.net/2014/1081.html</link><pubDate>Mon, 14 Jul 2014 19:28:49 +0000</pubDate><guid>//owent.net/2014/1081.html</guid><description>INI 配置读取库发布 Github地址: https://github.com/owent/libiniloader OSChina镜像: http://git.oschina.net/owent/libiniloader 项目中经常会碰到需要读取配置的情况，而用ini配置最大的优势就是简单易懂。 但是现在</description></item><item><title>捣鼓一个协程库</title><link>//owent.net/2014/1000.html</link><pubDate>Wed, 05 Mar 2014 21:52:49 +0000</pubDate><guid>//owent.net/2014/1000.html</guid><description>今年准备安安心心写一个协程库。一方面是觉得协程挺有意思，另一方面也是因为C/C++在这方面没有一个非常权威的解决方案。 按照我自己风格还是喜欢</description></item><item><title>C++又一坑:动态链接库中的全局变量</title><link>//owent.net/2014/962.html</link><pubDate>Sat, 04 Jan 2014 17:30:32 +0000</pubDate><guid>//owent.net/2014/962.html</guid><description>前几天我们项目的日志系统出现了一点问题，但是一直没有时间去深究。 昨天在同事的帮助下，无意中猜了一种可能性，结果还真被我猜中了，于是今天就特别</description></item><item><title>不知道是哪一年的腾讯马拉松题目 照片评级 解题报告</title><link>//owent.net/2013/930.html</link><pubDate>Fri, 25 Oct 2013 15:45:05 +0000</pubDate><guid>//owent.net/2013/930.html</guid><description>在某个神奇的下午，收到一个垃圾邮件（至少被邮件系统当成了垃圾邮件）。 结果就一不小心看到了这个充满回忆的ACM模式竞赛，还有咱腾讯的，就忍不住</description></item><item><title>Lua 挺好用的样子</title><link>//owent.net/2013/918.html</link><pubDate>Thu, 24 Oct 2013 20:59:44 +0000</pubDate><guid>//owent.net/2013/918.html</guid><description>项目里面引入了Lua，就特别学习了一下。 其实对于理解Javascipt的人来说，Lua也很容易理解，因为他们太多的地方相像了。 初步看来，Lu</description></item><item><title>VC和GCC成员函数指针实现的研究(三)</title><link>//owent.net/2013/902.html</link><pubDate>Wed, 11 Sep 2013 14:57:15 +0000</pubDate><guid>//owent.net/2013/902.html</guid><description>接上一篇 VC和GCC内成员函数指针实现的研究(二) 虚继承 终于到最后的虚继承了。 测试代码如下: #include &amp;lt;ctime&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;cstddef&amp;gt; #include &amp;lt;string&amp;gt; class foo_a { public: virtual ~foo_a(){} virtual void info() {</description></item><item><title>VC和GCC成员函数指针实现的研究(二)</title><link>//owent.net/2013/896.html</link><pubDate>Wed, 11 Sep 2013 14:44:06 +0000</pubDate><guid>//owent.net/2013/896.html</guid><description>接上一篇 VC和GCC内成员函数指针实现的研究(一) 接下来是多重继承，用到的测试代码如下所示: #include &amp;lt;ctime&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;cstddef&amp;gt; #include &amp;lt;string&amp;gt; class foo_a { public: virtual ~foo_a(){} virtual void info() {</description></item><item><title>VC和GCC内成员函数指针实现的研究(一)</title><link>//owent.net/2013/890.html</link><pubDate>Fri, 06 Sep 2013 12:55:58 +0000</pubDate><guid>//owent.net/2013/890.html</guid><description>最近在《C++对象模型》一书里说到的virtual的成员函数指针，低于128的被cfront编译器认为是虚表偏移量（支持子类对父类函数的覆盖</description></item><item><title>一个C++关于成员变量偏移地址的小Trick</title><link>//owent.net/2013/879.html</link><pubDate>Mon, 26 Aug 2013 14:16:37 +0000</pubDate><guid>//owent.net/2013/879.html</guid><description>今天看到一个小例子，发现了一个小trick。见代码： #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; class base_1 { public: int a; }; class base_2 { public: int b; }; class base_3: public base_1, public base_2 { public: int c; }; int main(int argc, char* argv[]) { printf(&amp;quot;&amp;amp;base_1::a = %p\n&amp;quot;, &amp;amp;base_1::a); printf(&amp;quot;&amp;amp;base_2::b = %p\n&amp;quot;, &amp;amp;base_2::b); printf(&amp;quot;&amp;amp;base_3::a</description></item><item><title>ptmalloc,tcmalloc和jemalloc内存分配策略研究</title><link>//owent.net/2013/867.html</link><pubDate>Wed, 31 Jul 2013 13:02:53 +0000</pubDate><guid>//owent.net/2013/867.html</guid><description>最近看了glibc的ptmaoolc，Goolge的tcmalloc和jemalloc，顺便做了一点记录。可能有些地方理解地不太对，如有发现</description></item><item><title>Boost.Spirit 初体验</title><link>//owent.net/2012/674.html</link><pubDate>Thu, 08 Nov 2012 18:57:34 +0000</pubDate><guid>//owent.net/2012/674.html</guid><description>使用代码生成代码是一件十分美妙的事情，于是有了各种代码生成器。但是生成代码，意味着要有对生成规则的分析和处理。 Boost.Spirit 就是这么一个语法分析工具，它</description></item><item><title>C++ 新特性学习（二） -- Array、Tuple和Hash库</title><link>//owent.net/2011/518.html</link><pubDate>Fri, 14 Oct 2011 12:17:17 +0000</pubDate><guid>//owent.net/2011/518.html</guid><description>这回的两个库没怎么用过，这里的记录就用VC++写了，使用G++和BOOST的时候和智能指针类似。 首先是Tuple库 要注意的是这里G++，VC</description></item><item><title>C++ 新特性学习（一） -- 概述+智能指针（smart_ptr）</title><link>//owent.net/2011/508.html</link><pubDate>Fri, 14 Oct 2011 04:12:48 +0000</pubDate><guid>//owent.net/2011/508.html</guid><description>C++ 0x/11 终于通过了,真是个很爽的消息。于是乎我决定对新的东西系统学习一下。 首先当然要从tr1开始，智能指针实际上我已经用过很多次了，但是为了完整</description></item><item><title>2011 Google Code Jam 小记</title><link>//owent.net/2011/416.html</link><pubDate>Sun, 22 May 2011 07:46:12 +0000</pubDate><guid>//owent.net/2011/416.html</guid><description>好久没写这种类型的代码，感觉真是退步了很多。 这是我第一次参加Google Code Jam，以前有过报名可是没有做过。 我发现Google Code Jam的题目</description></item><item><title>C++总是很神奇</title><link>//owent.net/2011/359.html</link><pubDate>Tue, 26 Apr 2011 07:08:13 +0000</pubDate><guid>//owent.net/2011/359.html</guid><description>很多时候看到C/C++的一些奇妙的应用，每次都是惊奇一点时间就随风飘过了 现在我还是决定记录一下这些有意思的东西。 2010/04 a ^= b ^= a ^=b; 这是一个交换值</description></item><item><title>常用官方文档整理</title><link>//owent.net/2011/264.html</link><pubDate>Tue, 08 Feb 2011 14:04:26 +0000</pubDate><guid>//owent.net/2011/264.html</guid><description>网站及网页： 基本知识中文学习站（中）：http://www.w3school.com.cn W3C官网（英）：http://www.w3.or</description></item><item><title>常用官方文档整理</title><link>//owent.net/2011/264.html</link><pubDate>Tue, 08 Feb 2011 14:04:26 +0000</pubDate><guid>//owent.net/2011/264.html</guid><description>网站及网页： 基本知识中文学习站（中）：http://www.w3school.com.cn W3C官网（英）：http://www.w3.or</description></item><item><title>C#格式化输出(记录)</title><link>//owent.net/2010/26.html</link><pubDate>Tue, 08 Jun 2010 05:39:06 +0000</pubDate><guid>//owent.net/2010/26.html</guid><description>int a = 12345678; //格式为sring输出 Label1.Text = string.Format(&amp;quot;asdfadsf{0}adsfasdf&amp;quot;,a); Label2.Text = &amp;quot;asdfadsf&amp;quot;+a.ToString()+&amp;quot;adsfasdf&amp;quot;; Label1.Text = string.Format(&amp;quot;asdfadsf{0:C}adsfasdf&amp;quot</description></item><item><title>C/C++语言常用排序算法</title><link>//owent.net/2009/89.html</link><pubDate>Mon, 20 Jul 2009 12:31:10 +0000</pubDate><guid>//owent.net/2009/89.html</guid><description>资料由互联网收集整理，供新手参考学习 这里又生动点的演示：http://www.cnblogs.com/wangfupeng1988/arch</description></item></channel></rss>