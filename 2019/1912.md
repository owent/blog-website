---
author: owent
categories:
  - Article
  - Blablabla
date: 2019-10-19 16:10:00
draft: true
id: 1912
tags: 
  - cxx
  - cpp
  - coroutine
  - 协程
  - libcopp
title: 跨平台协程库 - libcopp 简介
type: post
---

前端时间有同事联系我想看看可能推广我之前写的协程库 [libcopp][1]，虽然 [libcopp][1] 已经用到过好几个项目上，这几年也断断续续地写了些部分细节的东西，但是也一直没有概览性地写过 [libcopp][1] 的介绍，所以就有了这篇文章。

Github: https://github.com/owt5008137/libcopp
Document: https://libcopp.atframe.work/

引言
------------------------------------------------

协程的概念并不是什么非常新颖的东西，最早有做 [libcopp][1] 的想法的时候，是听了微信分享的 [libco][17] 。但是我们游戏业务里大部分的实现都还是走的事务和Task/Step的模型，特别是C++上异步调用非常得绕。而这种协程的方法可以比较容易地把接口设计得很简洁，而且后续得功能集成上也很容易补破坏原有得API约定，还有微信这么大的业务背书，我们就想在游戏业务里也使用这种方案。我们先是预研了一些类似的方案，但是都不是很尽人意。

### 相似方案

首先是 [libco][17]， [libco][17] 其实文档比较少，有些使用方式要看它的代码，而且是只支持Linux，但是对编译器得要求还不太明确，而我们项目组有时候会用一些比较新的东西，也是怕后面兼容性上不一定能得到保证。[libco][17] 其实又一大特色是它的共享栈功能和对IO API的hook。前者的设计模式其实我是不太赞同的，因为它会留下一些坑（比如不能传出栈上变量到外部使用），而且对性能影响很大；后者其实对我们的用处不大，因为我们很少会直接去使用那些底层API，而是会接入很多库或者其他接入层来使用，更需要的是容易自定义。另外 [libco][17] 开源出来的仓库似乎几乎没有测试，只有一些sample，总给人一种不太放心的感觉。

我们还研究了 [boost.context][13] ，现在 [boost][13] 又有了新的 boost.coroutine 和 boost.coroutin2 库，但是当时还没有。 [boost][13] 库的兼容性和测试都一流，而且整个编程风格都是C++的，性能足够高，看起来非常良好。但是当时 [boost.context][13] 只有很底层的接口，使用上并不是很方便，另外 [boost.context][13] 对上下文对象管理的部分其实适配上也有一些问题。比如当时我们测过一些环境里，编译器版本比较高，但是缺失STL的TLS实现，[boost.context][13]就会直接链接不过。另外 [boost.context][13] 最大的问题是它依赖整个 [boost][13] 的平台和环境检测代码，非常得重（即便用 [bcp][9] 提取依赖，仍然非常重）。我们其实非常排斥为了引入一个小组件，而导入一个超大规模得框架的。而后来出现的 boost.coroutine 其实实现架构上我觉得式有一些问题的，兼容性更差，实用性也不好，现在已经被 deprecated 掉了， 再后来的 coroutin2 我之前初步看了一下，感觉结构和 [libcopp][1] 的 [copp][18] 部分差不多。

在当时 [libgo][15] 当时也算是一个比较完善的协程框架了。它做了很多语法糖，上手很简单。当时他也做了和 [libco][17] 一样的共享栈功能，但是后来作者不建议使用了，不知道是不是和我们一样的想法。[libgo][15] 也是依赖的 [boost.context][13]， 但是当时它还没有打包一份出来自己维护，所以也算是依赖很重的框架。它的自定义接入层很简单，但是其实底层是绕了一圈，而且我们的业务需要自己控制调度曾，而它提供的调度层我们似乎并不是很容易剥离，即便剥离了也会有一部分不必要的开销。

直接基于linux的swap_context和make_context的方案也是不是很完整，还是需要自己封装而且性能不太尽人意。其他的方案其实大同小异，我们就没有逐个去看了，最终还是选择了自己实现一个。于是 [libcopp][1] 就诞生了。

### 设计目标

我设计 [libcopp][1] 的时候优先还是考虑到我涉及的业务类型（游戏服务器）的。 首先我当时的想法是，既然用协程，就是为了简化业务开发人员的心智负担，并且能够容易排查问题，而且非共享栈带来的问题可以通过其他手段消除掉，所以没有去实现共享栈的功能（其实早期是预留了实现共享栈的空间的，后来觉得没必要去掉了）。

在游戏业务服务器里，会有需要接入各种各样的SDK和调度方式，所以容易集成其他系统就成了最大的优先级。

跨平台的特性是为了我们当时不同人都有自己的开发喜好，每个人都有自己喜欢的工具、环境和流程，我希望是能够适配大家的环境，提供可用且功能一致的版本，在这个基础上，我们线上业务时运行在Linux上的，所以Linux上性能最大化也是优先考虑的。

在设计 [libcopp][1] 的时候，我也是尽量按照C++的设计风格。因为我觉得现代C++的很多工具对我们排除一些初级错误很有帮助（比如 ```static_assert``` ），所以在实现 [libcopp][1] 的过程中，我们是会检测环境并且尽可能地使用 C++ 的一些新特性来优化性能或是规避问题；另外，因为整体架构和一些编程方法是可能随着时间而演进的，所以我们设计 [libcopp][1] 还会尽可能地让其内部的组件，是可单独拆卸下来的，并且容易剥离和重组，这点一定程度上参考了 [boost.context][13] 的设计；同时我们也会注重单元测试，保持比较高的覆盖率，这样对以后的修改能够更放心一些。

所以下面就是我们总结的设计目标了:

+ 跨平台（Linux/macOS/Windows/MinGW + GCC/Clang/MSVC）
+ 高性能
+ 易集成
+ 功能简洁，正交性
+ 容易定制化
+ 依赖少
+ Modern C++

上面的目标其实也不只是游戏服务器业务的需求点，而是想要保持足够灵活。这样如果其他业务要使用，只需要做少量的接入工作即可。

基本原理和实现架构
------------------------------------------------

[libcopp][1] 属于对称式有栈协程，有栈协程的基本原理很简单。不同平台，不同架构的架构下的ABI对函数调用都有一定的规范，比如 x86_64 的基本规范是要求函数的被调方保留好上一帧的 ```R12``` 、 ```R13``` 、 ```R14``` 、 ```R15``` 、 ```RBX``` 、 ```RBP``` （其他特殊的功能比如TSX或者Linux下GCC的动态栈还需要有其他的内容）， 在函数返回后还原，然后函数栈的起始地址有对齐要求。 而有栈协程即是把这些要求被调方处理的寄存器内容保存在栈上，然后直接jmp到新的执行地址即可。在跳回来以后需要还原这些寄存器，对调用方来说，就像调用了一个函数一样。

我没有挨个平台去看 ABI 的文档，所以为了实现跨平台，我在 [libcopp][1] 里是直接引用了 [boost.context][13] 里的 fcontext 部分。但是我把它的平台判定和汇编层代码剥离出来并且符号重命名了，这样可以不依赖庞大的 [boost][13] 库，而且如果哪个项目要用 [boost][13] 也不会冲突。项目里的 [BOOST_LICENSE_1_0.txt](https://github.com/owt5008137/libcopp/blob/v2/BOOST_LICENSE_1_0.txt) 也是这个原因而存在。

[libcopp][1] 大体上分为两部分.第一部分是 [copp][18] ，这部分主要负责偏底层的协程上下文管理、栈管理； 第二部分是 [cotask][19] ， 这部分主要用于一些更高层面设计模式和基于协程的任务模型（包括但不限于进程内唯一ID分配、超时管理、await语义、自定义参数的关联和分配等等）。

![../2018/1806-02.dot.png](../2018/1806-02.dot.png)

其中 [copp][18] 里还分为 **栈分配器** 、 **执行上下文管理** 和 **用户自定义数据** ， 其中 **栈分配器** 是可自定义的，只需要类似 ```std::allocator``` 实现几个接口即可，我们也提供了几个内置的分配器供直接使用，包括 *通过malloc分配* 、 *mmap/unmap(Windows下是VirtualAlloc/VirtualFree)* 、 *自定义指定内存地址的分配器* 、 *Linux下的动态增长栈分配器* 和 *栈池分配器* 。这里面 *栈池分配器*  还支持搭配底层使用上面其他的分配器。[cotask][19] 是可选的，如果业务有自己的任务系统也可以不用，并且可以通过编译选项完全关闭， 而在 [cotask][19] 里，*ID分配器* 也是可以自定义的。 这样所使用的业务可以根据自己的需要来选择、搭配或是自定义用自己项目里统一的管理系统。

性能对比
------------------------------------------------

工具集成
------------------------------------------------

CMake Modern Module
vcpkg

未来的开发计划
------------------------------------------------

C++20 Coroutine

最后
------------------------------------------------

[libcopp][1] 刚开始的时候就是开源的，当时并没有什么特别的想法，只是说这样存取代码和交流会更方便写。 开源出来以后有一些小伙伴们提出过一些很实用的意见和建议，我也根据实际使用场景针对性地做了各种优化，也算查漏补缺吧。欢迎有兴趣的小伙伴们一起提意见和交流哈。

[1]: https://github.com/owt5008137/libcopp
[2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0973r0.pdf
[3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf
[4]: https://github.com/ultramanhu
[5]: https://owent.net/2019/1904.html
[6]: https://owent.net/2018/1806.html
[7]: https://en.cppreference.com/w/cpp/language/coroutines
[8]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0912r5.html
[9]: https://www.boost.org/tools/bcp/
[10]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf
[11]: https://golang.org/
[12]: https://golang.org/dl/#go1.13.1
[13]: https://www.boost.org/
[14]: https://www.boost.org/users/history/version_1_71_0.html
[15]: https://github.com/yyzybb537/libgo
[16]: https://github.com/yuanzhubi/call_in_stack
[17]: https://github.com/Tencent/libco
[18]: https://github.com/owt5008137/libcopp/tree/v2/include/libcopp
[19]: https://github.com/owt5008137/libcopp/tree/v2/include/libcotask
