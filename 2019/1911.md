---
author: owent
categories:
  - Article
  - Blablabla
date: 2019-09-22 14:25:00
draft: true
id: 1911
tags: 
  - cxx
  - cpp
  - coroutine
  - std
  - iso
  - 协程
  - msvc
  - clang
  - llvm
  - libcxx
  - libc++
  - libcxxabi
  - libc++abi
  - libcopp
title: C++20 Coroutine 性能测试
type: post
---

前言
------------------------------------------------

之前写了 [《协程框架(libcopp)v2优化、自适应栈池和同类库的Benchmark对比》][6] 和 [《C++20 Coroutine》][5] ，但是一直没写 [C++20 Coroutine][7] 的测试报告。

本来呢，我我以前的理解，以为 [C++20 Coroutine][7] 是无栈式协程，那样的话就没啥好测得了。因为本身不带什么额外开销，并且开销可控。但是上次写 [《C++20 Coroutine》][5] 得时候发现他也是有栈协程，也是要切换上下文得。今天我就照着之前的构造 L1 Cache Miss 的方式来benchmark一波 [C++20 Coroutine][7] 吧。

测试代码
------------------------------------------------

[C++20 Coroutine][7] 上手比较麻烦，所以测试代码那是真滴长。 ```co_await``` 的原理和 ```co_yield``` 是一样的，只是 ```co_await``` 多了一点点对封装类似 [libcotask][1] 的支持，单纯的上下文切换仅使用 ```co_yield``` 就可以了。这样也更能公平地拿来和其他几个协程库对比。

```cpp
#include <iostream>
#include <iomanip>
#include <vector>

#include <memory>

#include <experimental/coroutine>

static std::vector<std::pair<int*, std::experimental::coroutine_handle<> > > g_test_rpc_manager;

struct test_custom_coroutine_data;
struct test_custom_coroutine {
    using data_ptr = std::unique_ptr<test_custom_coroutine_data>;

    struct promise_type {
        test_custom_coroutine_data* refer_data;
        promise_type();

        static test_custom_coroutine get_return_object_on_allocation_failure();

        test_custom_coroutine get_return_object();

        std::experimental::suspend_never initial_suspend();

        std::experimental::suspend_always final_suspend();

        void unhandled_exception();

        // 用以支持 co_return
        void return_void();

        // 用以支持 co_yield
        std::experimental::suspend_always yield_value(test_custom_coroutine_data*&);
    };

    // 下面的接入用侵入式的方式支持 co_await test_rpc_generator
    // MSVC 目前支持使用非侵入式的方式实现，但是clang不支持
    bool await_ready() noexcept;

    void await_resume();

    void await_suspend(std::experimental::coroutine_handle<promise_type>);

private:
    test_custom_coroutine(data_ptr &&);
    data_ptr data;
};

struct test_custom_coroutine_data {
    int sum_times;
    int yield_times;

    std::experimental::coroutine_handle<test_custom_coroutine::promise_type> handle;
};

test_custom_coroutine::promise_type::promise_type(): refer_data(nullptr) {}
test_custom_coroutine test_custom_coroutine::promise_type::get_return_object_on_allocation_failure() {
    return test_custom_coroutine{ nullptr };
}

test_custom_coroutine test_custom_coroutine::promise_type::get_return_object() {
    data_ptr data = std::make_unique<test_custom_coroutine_data>();
    if (data) {
        data->sum_times = 0;
        data->yield_times = 0;
        refer_data = data.get();
    }
    return test_custom_coroutine{ std::move(data) };
}

std::experimental::suspend_never test_custom_coroutine::promise_type::initial_suspend() {
    return std::experimental::suspend_never{}; // STL提供了一些自带的awaiter实现，我们其实很多情况下也不需要另外写，直接用STL就好了
}

std::experimental::suspend_always test_custom_coroutine::promise_type::final_suspend() {
    return std::experimental::suspend_always{}; // 和上面一样，也是STL自带的awaiter实现
}

void test_custom_coroutine::promise_type::unhandled_exception() {
    std::terminate();
}

// 用以支持 co_return
void test_custom_coroutine::promise_type::return_void() {}

// 用以支持 co_yield
std::experimental::suspend_always test_custom_coroutine::promise_type::yield_value(test_custom_coroutine_data*& coro_data) {
    // 每次调用都会执行,创建handle用以后面恢复数据
    if(nullptr != refer_data) {
        refer_data->handle = std::experimental::coroutine_handle<promise_type>::from_promise(*this);
        ++ refer_data->yield_times;
    }

    coro_data = refer_data;
    return std::experimental::suspend_always{};
}

// 下面的接入用侵入式的方式支持 co_await test_custom_coroutine , 实际上benchmark过程中并没有用到
// MSVC 目前支持使用非侵入式的方式实现，但是clang不支持
bool test_custom_coroutine::await_ready() noexcept {
    // 准备好地标志是协程handle执行完毕了
    return !data || !data->handle || data->handle.done();
}

void test_custom_coroutine::await_resume() {
    // do nothing when benchmark
}

void test_custom_coroutine::await_suspend(std::experimental::coroutine_handle<promise_type>) {
    // do nothing when benchmark
    // 被外部模块 co_await , 这里完整的协程任务链流程应该是要把coroutine_handle记录到test_custom_coroutine
    // 在return_void后需要对这些coroutine_handle做resume操作，但是这里为了减少benchmark的额外开销和保持干净
    // 所以留空
}

test_custom_coroutine::test_custom_coroutine(data_ptr && d) : data(std::move(d)) {}

// 异步协程函数
test_custom_coroutine coroutine_start_main() {
    test_custom_coroutine_data* coro_data;
    // create done and first yield
    co_yield coro_data;
    
    while (coro_data != nullptr && coro_data->yield_times < coro_data->sum_times) {
        co_yield coro_data;
    }

    // finish all yield
    co_return;
}

// 这里模拟生成数据
void test_rpc_manager_run() {
    std::vector<std::pair<int*, std::experimental::coroutine_handle<> > > rpc_manager;
    g_test_rpc_manager.swap(rpc_manager);

    for (auto& generator : rpc_manager) {
        if (generator.first) {
            *generator.first = ++g_test_rpc_fake_data;
        }

        if (generator.second && !generator.second.done()) {
            generator.second.resume();
        }
    }
}

int main(int argc, char* argv[]) {
#ifdef __cpp_coroutines
    std::cout << "__cpp_coroutines: " << __cpp_coroutines << std::endl;
#endif

    // 创建一个任务
    test_task::ptr_t task = std::make_shared<test_task>(3);
    // 运行任务
    auto fut = g(task);
    // 模拟从外部获取数据然会恢复协程
    while (!fut.done()) {
        test_rpc_manager_run();
    }

    return 0;
}
```

测试结果和总结
------------------------------------------------

[1]: https://github.com/owt5008137/libcopp
[2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0973r0.pdf
[3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf
[4]: https://github.com/ultramanhu
[5]: https://owent.net/2019/1904.html
[6]: https://owent.net/2018/1806.html
[7]: https://en.cppreference.com/w/cpp/language/coroutines
