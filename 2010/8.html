<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>线段树相关问题 (引用 PKU POJ题目) 整理|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/2010/8.html><link rel=icon href=../favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script type=importmap>
{
  "imports": {
    "react": "//unpkg.com/react@latest",
    "react-bootstrap": "//unpkg.com/react-bootstrap@latest",
    "mermaid": "//unpkg.com/mermaid@latest/dist/mermaid.esm.min.mjs",
    "bootstrap": "//unpkg.com/bootstrap@latest/dist/js/bootstrap.esm.min.js",
    "@popperjs/core": "//unpkg.com/@popperjs/core@latest/dist/esm/popper.js"
  }
}
</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta name=baidu-site-verification content="codeva-4M5iohb9TW"></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=../ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=../archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=../about.html title=About>About</a></li><li class="nav-item nav-ads ads-placeholder ads-container"><ins class="adsbygoogle ads_menu" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=4450372783 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=post-content><article id=post-973084b5c81898d7a3ada19395467f65 class="article-panel article article-type-post" itemscope itemprop=blogPost><div class="article-panel-inner article-inner"><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=//owent.net/2010/8.html target=_blank itemprop=url>线段树相关问题 (引用 PKU POJ题目) 整理</a></h1></header><hr><div id=toc class="well toc m-3 p-1 pr-1 pt-1 pb-2 float-md-right float-md-end"><nav id=TableOfContents><ul><li><a href=#1rangeminimummaximum-query问题计算单调区间内出现最多少的次数>1.RangeMinimum、Maximum Query问题（计算单调区间内出现最多（少）的次数）</a></li><li><a href=#2排队插队问题id为i的人插到第j位求最后序列>2.排队插队问题(ID为i的人插到第j位，求最后序列)</a></li><li><a href=#3矩形交求面积周长>3.矩形交求面积/周长</a></li><li><a href=#普通线段树无离散化>普通线段树[无离散化]：</a></li><li><a href=#矩形交map离散化>矩形交[MAP离散化]：</a></li><li><a href=#涂色覆盖问题sort数值离散化>涂色覆盖问题[[Sort数值离散化]：</a></li><li><a href=#二维线段树这段不是自己写的copy来的>二维线段树（这段不是自己写的Copy来的）：</a></li></ul></nav><div class="ads-placeholder ads-container"><ins class="adsbygoogle ads_toc" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=1249494377 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><br><div class=article-entry itemprop=articleBody><h2 id=1rangeminimummaximum-query问题计算单调区间内出现最多少的次数>1.RangeMinimum、Maximum Query问题（计算单调区间内出现最多（少）的次数）</h2><p>对元素的起点做离散化，再把离散化后的位置作为线段树的[l, r),记录次数为t.</p><p>对输入区间a, b:</p><p>如果（a = b）{很好处理}，</p><p>如果（a = b – 1）{分别计算a、b的次数，取大（小）的一项}，</p><p>如果（a &lt; b – 1）{分别计算a、b的次数和线段树[a + 1, b – 1)的次数，取大（小）的一项};</p><blockquote><p>pku3264-Balanced Lineup RMQ问题,求区间最大最小值的差</p><p>pku3368-Frequent values 转化为RMQ问题求解</p></blockquote><h2 id=2排队插队问题id为i的人插到第j位求最后序列>2.排队插队问题(ID为i的人插到第j位，求最后序列)</h2><p>先把插队顺序记录下来，然后倒序插入。用线段树记录已有的序列，计算当前人物的序号,注意重复插入的情况(重复插入则结果序列中只处理第一次出现位置)。
线段树记录[i, j)中的已插入的人数，所以每次插入都是insert(n, n + 1)，Query函数和一般的find有所不同,传入的是偏移量，通过偏移量计算.
忘了哪道题了，反正有的。</p><h2 id=3矩形交求面积周长>3.矩形交求面积/周长</h2><p>对纵坐标离散化并做扫描线。</p><p>如果求周长则记录原始y轴覆盖段数ocn，原始和当前覆盖区域长度ocl，cl，则ans+=abs(ocl-cl)+ocn*(x_now-x_pre)</p><p>如果计算面积只需要记录原始覆盖区域长度ocl，然后ans+=ocl*(x_now-x_pre)</p><blockquote><p>pku1151-Atlantis 求矩形并的面积,用线段树+离散化+扫描线</p><p>pku1177-picture 求矩形并的周长,用线段树+离散化+扫描线</p></blockquote><p>4.覆盖涂色查找颜色种数问题</p><p>把坐标离散化，注意边界如果是整数，右边+1取开区间，防止出现[(1,10),(1,3),(6,10)]输出为2的情况。</p><p>离散化可以放在线段树里，尽量不要用map离散化（效率问题），Insert到字节点时，先把父节点颜色插入子节点并重置父节点为未涂色。</p><p>查询时查询涂色子节点数量即可</p><p>pku2528-Mayor&rsquo;s posters 区间涂色问题,使用离散化+线段树</p><p>注意开线段树的大小，由于用数组模拟有空间浪费，注意不要RE，一般节点数可设为最大子节点数的8倍</p><p>注意离散化尽量用sort取不重复点而不是用map，用sort的效率大约是map的10倍</p><p>相关代码：</p><h2 id=普通线段树无离散化>普通线段树[无离散化]：</h2><pre><code class=language-cpp>struct _SegTree_Data
{
    int l, r;
    int v;
};
struct SegTree
{
    const static int maxn = 500000;
    _SegTree_Data data[4 * maxn];

    //初始化函数（如果需要）
    void init(int l, int r, int f = 0)
    {
        data[f].l = l;
        data[f].r = r;
        data[f].v = 0;
        if(r &gt; l + 1)
        {
            int m = (l + r) / 2;
            init(l, m, 2 * f + 1);
            init(m, r, 2 * f + 2);
        }
    }

    //参数：插入区间[l,r),区间父结点[f]
    void insert(int l, int r, int f = 0)
    {
        //根据需要修改
        data[f].v ++;
        if(data[f].l == l &amp;&amp; data[f].r == r)
            return;
        //--------------
        int m = (data[f].l + data[f].r) / 2;
        if(l &gt;= m)//区间在右子节点上
            insert(l, r, 2 * f + 2);
        else if(r &lt;= m)//区间在作左子节点上
            insert(l, r, 2 * f + 1);
        else
            insert(l, m, 2 * f + 1), insert(m, r, 2 * f + 2);
    }

    //参数：查找区间[l,r),区间父结点[f]
    //返回：区间值
    int find(int l, int r, int f = 0)
    {
        if(data[f].l == l &amp;&amp; data[f].r == r)
            return data[f].v;
        int m = (data[f].l + data[f].r) / 2;
        if(l &gt;= m)//区间在右子节点上
            return find(l, r, 2 * f + 2);
        else if(r &lt;= m)//区间在作左子节点上
            return find(l, r, 2 * f + 1);
        else // 根据需要修改
            return find(l, m, 2 * f + 1) + find(m, r, 2 * f + 2);
    }

    //排队问题的查找位置函数
    //参数：插入位置[rp](相对父结点起始位置的偏移),区间父结点[f]
    //返回：实际位置
    int query(int rp, int f = 0)
    {
        if(data[f].v == 0)
            return data[f].l + rp;
        int lc = 2 * f + 1;
        int ll = data[lc].r - data[lc].l - data[lc].v;//计算左子节点剩余位置数量
        //注意rp是偏移量[0,rp],ll是个数[1,ll]
        if(rp &lt; ll)//目标在左子节点中
            return query(rp , lc);
        else//目标在右子节点中
            return query(rp - ll, lc + 1);
    }
};
</code></pre><h2 id=矩形交map离散化>矩形交[MAP离散化]：</h2><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;

//注释代码为计算周长时使用
struct SegTree;
//用于离散化y轴坐标
std::map&lt;double, int&gt; hash;//离散化映射
std::map&lt;double, int&gt;::iterator itr;
double mapOf[2 * 10500];//离散化位置对应的值

struct _SegTree
{
    int l, r;//作用域[l,r)
    int c/*, cn*/;//全覆盖次数[c]，覆盖区间段数[cn]
    double cl;//覆盖区域长度[cl]
    //bool lc, rc;//左顶点覆盖[lc]，右顶点覆盖[rc]
    _SegTree(){}
    _SegTree(int l, int r)
    {
        this-&gt;l = l;
        this-&gt;r = r;
        //lc = rc = false;
        c /*= cn*/ = 0;
        cl = 0.0;
    }
};

struct SegTree
{
    const static int maxn = 10500;
    _SegTree data[4 * maxn];
    //初始化，置零
    void init(int l, int r, int f = 0)
    {
        data[f] = _SegTree(l, r);
        if(r - l &gt; 1)
        {
            int m = (l + r) / 2;
            init(l, m, 2 * f + 1);
            init(m, r, 2 * f + 2);
        }
    }

    //插入区间[l,f)
    void insert(int l, int r, int f = 0)
    {
        if(data[f].l == l &amp;&amp; data[f].r == r)
            data[f].c ++;
        else
        {
            int m = (data[f].l + data[f].r) / 2;
            int lc = 2 * f + 1;
            if(l &gt;= m)//区间在右子节点
                insert(l, r, lc + 1);
            else if(r &lt;= m)//区间在左子节点
                insert(l, r, lc);
            else
                insert(l, m, lc), insert(m, r, lc + 1);
        }

        update(f);
    }

    //删除区间
    void del(int l, int r, int f = 0)
    {
        if(data[f].l == l &amp;&amp; data[f].r == r)
            data[f].c --;
        else
        {
            int m = (data[f].l + data[f].r) / 2;
            int lc = 2 * f + 1;
            if(l &gt;= m)//区间在右子节点
                del(l, r, lc + 1);
            else if(r &lt;= m)//区间在左子节点
                del(l, r, lc);
            else
                del(l, m, lc), del(m, r, lc + 1);
        }

        update(f);
    }

    //更新记录状态集
    void update(int f = 0)
    {
        if(data[f].c &gt; 0)//全覆盖判断
        {
            //data[f].lc = data[f].rc = true;
            data[f].cl = mapOf[data[f].r] - mapOf[data[f].l];//离散化的还原
            //data[f].cn = 1;
            return;
        }
        else if(data[f].r - data[f].l &lt;= 1)//单位节点
        {
            //data[f].lc = data[f].rc = false;
            data[f].cl = 0.0;
            //data[f].cn = 0;
            return;
        }
        int lc = 2 * f + 1;
        data[f].cl = data[lc].cl + data[lc + 1].cl;
        //data[f].cn = data[lc].cn + data[lc + 1].cn;
        //if(data[lc].rc == true &amp;&amp; data[lc + 1].lc == true)
            //data[f].cn --;
        //data[f].lc = data[lc].lc;
        //data[f].rc = data[lc + 1].rc;
    }
};

struct node
{
    double x, uy, dy;
    bool isAdd;
    node(){}
    node(double x, double uy, double dy, bool isAdd): x(x), uy(uy), dy(dy), isAdd(isAdd){}
};

SegTree root;//线段树
node ls[2 * SegTree::maxn];//输入矩阵

bool cmp(node l, node r)
{
    if(l.x != r.x)
        return l.x &lt; r.x;
    if(l.isAdd != r.isAdd)
        return l.isAdd;
    return l.dy &lt; r.dy;
}
int main()
{
    int n, hl;
    while(::scanf(&quot;%d&quot;, &amp;n), n)
    {
        double ans = 0;
        double lux, luy, rlx, rly;
        root.init(0, SegTree::maxn);
        hash.clear();
        for(int i = 0; i &lt; n; i ++)
        {
            //读入左上角和右下角
            ::scanf(&quot;%lf %lf %lf %lf&quot;, &amp;lux, &amp;luy, &amp;rlx, &amp;rly);
            ls[2 * i] = node(lux, rly, luy, true);
            ls[2 * i + 1] = node(rlx, rly, luy, false);
            hash[rly] = hash[luy] = 0;
        }
        for(hl = 0, itr = hash.begin(); itr != hash.end(); itr ++, hl ++ )
            itr-&gt;second = hl, mapOf[hl] = itr-&gt;first;

        std::sort(ls, ls + 2 * n, cmp);//排序后从左到右扫描
        double preX = ls[0].x;
        for(int i = 0; i &lt; 2 * n; i ++)
        {
            double ocl = root.data[0].cl;
            //int ocn = root.data[0].cn;
            if(ls[i].isAdd)
                root.insert(hash[ls[i].dy], hash[ls[i].uy]);
            else
                root.del(hash[ls[i].dy], hash[ls[i].uy]);
            //求周长
            //ans += (ls[i].x - preX) * 2 * ocn;
            //ans += abs(ocl - root.data[0].cl);
            //求面积
            ans += ocl * (ls[i].x - preX);
            if(ls[i].x &gt; preX)
                preX = ls[i].x;
        }

        ::printf(&quot;%.2lf\n&quot;, ans);
    }
    return 0;
}
</code></pre><h2 id=涂色覆盖问题sort数值离散化>涂色覆盖问题[[Sort数值离散化]：</h2><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

int map[20010];// 用于离散化
int seg[10005][2];
bool check[10005];
struct _SegTree_Data
{
    int l, r;
    int v;//区间覆盖颜色，夹缝覆盖颜色
    bool leaf;//叶节点
};
struct SegTree
{
    const static int maxn = 10005;
    _SegTree_Data data[8 * maxn];

    //初始化函数（如果需要）
    void init(int l, int r, int f = 0)
    {
        data[f].l = map[l];
        data[f].r = map[r];
        data[f].v = 0;
        if(r &gt; l + 1)
        {
            int m = (l + r) / 2;
            init(l, m, 2 * f + 1);
            init(m, r, 2 * f + 2);
            data[f].leaf = false;
        }
        else
            data[f].leaf = true;
    }

    //参数：插入区间[l,r),插入值[v],区间父结点[f]
    void insert(int l, int r, int v, int f = 0)
    {
        //根据需要修改
        if(data[f].l == l &amp;&amp; data[f].r == r)
        {
            data[f].v = v;
            return;
        }
        //--------------
        int m = data[2 * f + 2].l;
        if(data[f].v &gt; 0)
        {
            data[2 * f + 1].v = data[2 * f + 2].v = data[f].v;
            data[f].v = 0;
        }
        if(l &gt;= m)//区间在右子节点上
            insert(l, r, v, 2 * f + 2);
        else if(r &lt;= m)//区间在作左子节点上
            insert(l, r, v, 2 * f + 1);
        else
            insert(l, m, v, 2 * f + 1), insert(m, r, v, 2 * f + 2);
    }

    //参数：查找区间父结点[f]
    //返回：段数
    int find(int f = 0)
    {
        if(data[f].v &gt; 0)
        {
            if(!check[data[f].v])
            {
                check[data[f].v] = true;
                return 1;
            }
            return 0;
        }
        if(data[f].leaf == false)
            return find(2 * f + 1) + find(2 * f + 2);
        return 0;
    }
};

SegTree root;

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --)
    {
        int n, rn;
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 0; i &lt; n; i ++)
        {
            scanf(&quot;%d %d&quot;, &amp;seg[i][0], &amp;seg[i][1]);
            map[2 * i] = seg[i][0];
            map[2 * i + 1] = seg[i][1] + 1;//注意右边界为开区间
        }
        memset(check, false, sizeof(check));
        std::sort(map, map + 2 * n);
        rn = 1;
        for(int i = 1; i &lt; 2 * n; i ++)//去除重复点
            if(map[i] != map[i - 1])
                map[rn ++] = map[i];

        root.init(0, rn - 1);
        check[0] = true;
        for(int i = 0; i &lt; n; i ++)
            root.insert(seg[i][0], seg[i][1] + 1, i + 1);

        printf(&quot;%d\n&quot;, root.find());
    }
    return 0;
}
</code></pre><h2 id=二维线段树这段不是自己写的copy来的>二维线段树（这段不是自己写的Copy来的）：</h2><pre><code class=language-cpp>//下面我就简单介绍一下我理解中的二维线段树。顾名思义，二维线段树需要有两个维度，所以实现它的最基本思想就是树中套树。假设有一个矩形横坐标范围1—n，纵坐标范围1—m。我们可以以横坐标为一个维度，建立一棵线段树，假设为tree1，在这棵树的每个节点中以纵坐标建立一棵线段树，设为tree2，假设我们在tree1所处在的节点的的横坐标范围为l,r，那么该节点表示的矩形范围为横坐标为l—r，纵坐标范围为1—m。若我们正处在该节点中tree2的某个节点，该节点的纵坐标范围为d—u，那么tree2中的这个节点所代表的矩形范围，横坐标l—r，纵坐标d—u。所以千万不要糊涂应该怎么树中套树，仔细想想其实思想就是这么简单，我们要知道二维线段树并不是一棵树，我们不能把其统一成某种能表示平面的节点，而是根据各个节点的含义组合出能表示平面的节点。
//代码
//1：定义数据结构：
//
//    一维线段树的节点定义。
typedef struct
{
    int l, r;   // 线段左右端点坐标
    int mv;   // 该线段范围内的最大值
} NodeOne;

//一维线段树的类定义。
struct OneDemonTree
{
        const int maxn = 1005;
        NodeOne data[3 * maxn];    // 节点数组
        void init(int l, int r, int step);   // 建立线l—r线段树
        void insert(int l, int r, int var, int step); // 把var插入到线段l—r中
        void delet(int l, int r, int step);   // 删除l—r线段
        int query(int l, int r, int step);   // 查询l---r的最大值
};

//二维线段树节点定义：
typedef struct
{
    int l, r;             // 横坐标范围l—r，
    OneDemonTree tree;    // 以纵坐标建立的线段树
} NodeTwo;

//二维线段树类定义：
struct TwoDemonTree
{
        const int maxn = 1005;
        int l, r;    // 横坐标范围l—r，
        NodeTwo data[3 * maxn]; //二维线段树节点数组
// 建立横坐标范围为xl-xr，纵坐标范围yd—yu的线段树。
        void init(int xl, int xr, int yd, int yu, int step);
// 在xl-xr yd-yu 的矩形范围内插入var
        void insert(int xl, int xr, int yd, int yu, int var, int step);
// 删除…
        void delet(int xl, int xr, int yd, int yu, int step);
//查询xl-xr yd-yu 范围内的最大值
        int query(int xl, int xr, int yd, int yu, int step);
};
//2： 操作实现：
//一维线段树初始化、插入、查询操作
void OneDemonTree::init(int l, int r, int step)
{
    data[step].l = l;
    data[step].r = r;
    data[step].mv = 0;
    if(l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    init(l, mid, 2 * step);
    init(mid + 1, r, 2 * step + 1);
}
void OneDemonTree::insert(int l, int r, int var, int step)
{
    if(data[step].mv &lt; var)
        data[step].mv = var;
    if(data[step].l == data[step].r)
        return;
    int mid = (data[step].l + data[step].r) &gt;&gt; 1;
    if(l &lt;= mid)
        insert(l, r, var, 2 * step);
    if(r &gt; mid)
        insert(l, r, var, 2 * step + 1);
    int v = data[2 * step].mv &gt; data[2 * step + 1].mv ? data[2 * step].mv : data[2 * step + 1].mv;
    if(data[step].mv &lt; v)
        data[step].mv = v;
}

int OneDemonTree::query(int l, int r, int step)
{
    if(l &lt;= data[step].l &amp;&amp; r &gt;= data[step].r)
        return data[step].mv;
    int mid = (data[step].l + data[step].r) &gt;&gt; 1;
    int mv = 0;
    if(l &lt;= mid)
        mv = query(l, r, 2 * step);
    if(r &gt; mid)
    {
        int rs = query(l, r, 2 * step + 1);
        if(rs &gt; mv)
            mv = rs;
    }
    return mv;
}

//二维线段树的建立、插入、查询操作：
void TwoDemonTree::init(int xl, int xr, int yd, int yu, int step)
{
    data[step].l = xl;
    data[step].r = xr;
    data[step].tree.init(yd, yu, 1);
    if(xl == xr)
        return;
    int mid = (xl + xr) &gt;&gt; 1;
    init(xl, mid, yd, yu, 2 * step);
    init(mid + 1, xr, yd, yu, 2 * step + 1);
}

void TwoDemonTree::insert(int xl, int xr, int yd, int yu, int var, int step)
{
    data[step].tree.insert(yd, yu, var, 1);
    if(data[step].l == data[step].r)
        return;
    int mid = (data[step].l + data[step].r) &gt;&gt; 1;
    if(xl &lt;= mid)
        insert(xl, xr, yd, yu, var, 2 * step);
    if(xr &gt; mid)
        insert(xl, xr, yd, yu, var, 2 * step + 1);
}

int TwoDemonTree::query(int xl, int xr, int yd, int yu, int step)
{
   if(xl &lt;= data[step].l &amp;&amp; xr &gt;= data[step].r)
        return data[step].tree.query(yd, yu, 1);
   int mid = (data[step].l + data[step].r) &gt;&gt; 1;
   int rs = 0;
   if(xl &lt;= mid)
        rs = query(xl, xr, yd, yu, 2 * step);
   if(xr &gt; mid)
   {
        int tmp = query(xl, xr, yd, yu, 2 * step + 1);
        if(tmp &gt; rs)
            rs = tmp;
   }
   return rs;
}

//3：二维线段树的时空复杂度分析
//空间复杂度分析：
//一棵坐标范围为1-n的线段数的节点总数不超过3*N，那么二维线段树共需要3*N*3*M个节点，所以空间消耗为O(9*M*N)。
//时间复杂度分析：
//初始化：O(m*n*logm*logn)
//插入： O(logm*logn)。
//删除： O(logm*logn)。
//查询： O(logm*logn)。
</code></pre></div><hr><footer class=article-footer><div class="article-panel-footer article-meta article-footer clearfix"><span class=article-meta-left><ol><li><a href=//owent.net/categories/article.html>Article</a></li><li><a href=//owent.net/categories/my-acm-icpc-career.html>My ACM-ICPC Career</a></li></ol></span><span class=article-meta-right><time datetime=2010-10-12T16:45:11.000+00:00 itemprop=datePublished>2010-10-12</time></span>
<span class=clearfix></span></div><div class=article-tags><ul class=article-tag-list><li class=article-tag-list-item><a href=//owent.net/tags/acm.html>acm</a></li><li class=article-tag-list-item><a href=//owent.net/tags/pku.html>pku</a></li><li class=article-tag-list-item><a href=//owent.net/tags/poj.html>poj</a></li></ul></div></footer><div class="ads-placeholder ads-container"><ins class="adsbygoogle ads_infeed" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=5599802929 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><hr><nav id=article-nav><ul class=pagination><li class=page-item><a class=page-link id=article-nav-newer class=article-nav-link-wrap href=//owent.net/2010/7.html>上一篇<strong>2010 ACM 赛前笔记</strong></a></li><li class=page-item><a class=page-link id=article-nav-older class=article-nav-link-wrap href=//owent.net/2010/10.html>下一篇<strong>POJ PKU 1474 Video Surveillance 解题报告</strong></a></li></ul></nav><hr><script src=https://utteranc.es/client.js repo=owent/blog-website issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></div></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>
2024
OWenT
</strong><strong id=footer-right class="float-right float-end"><a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=module>
import * as Popper from "@popperjs/core";
import * as bootstrap from 'bootstrap';
// import React from "react";

</script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/katex@latest/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
import mermaid from "mermaid";
const config = {
    theme: 'neutral',
    logLevel: 'fatal',
    securityLevel: 'loose', 
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    

};
mermaid.initialize(config);
</script></div></body></html>