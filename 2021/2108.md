---
author: owent
categories:
  - Article
  - Blablabla
date: 2021-12-30 12:19:45
draft: true
id: 2108
tags: 
  - protobuf
  - arena
title: C++20 Text Formatting/fmtlib 适配问题小记
type: post
---

## 前言

C++20 正式发布已经有一段时间了。其中 `Text Formatting` 是一个我个人比较感兴趣的新组件。它主要是解决了之前字符串格式化库 ( `printf` 系 ) 的效率问题和运行时安全的问题。
并且新的格式设置的形式也比较友好。相关规范和用法可以参见:

+ http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html#format.formatter
+ http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2216r3.html
+ https://en.cppreference.com/w/cpp/utility/format

在C++ 20能够普及以前，我们可以用 [fmtlib][1] 这个库来完成一样的功能。实际上我们项目组已经在这么做了。在使用 [fmtlib][1] 之前，比如我们按玩家打日志大概是这种形式。

```cpp
WLOGDEBUG("player %s(%u:%llu) int %d string %s string_view %s from server %llx", 
          user.get_open_id().c_str(), user.get_zone_id(),
          static_cast<unsigned long long>(user.get_user_id()),
          123, str.c_str(), str_v.data(),
          static_cast<unsigned long long>(server_inst_id));
```

之所以使用 `static_cast` 是因为这是在跨平台跨编译器无warning情况下的唯一方式。而在使用 [fmtlib][1] 之后，我们按玩家打印日志可以变成：

```cpp
FWLOGDEBUG("int {} string {} string_view {} from server {:#x}", 
          user, 123, str.c_str(), str_v.data(), server_inst_id);
```

是不是简洁多了？

于此同时，我们的构建系统改成了会检测编译环境是否支持 [C++20 Text Formatting][2] ，在支持的情况下使用 [C++20 Text Formatting][2] ，在不支持的情况下使用 [fmtlib][1] 。
但是因为目前各大编译器和STL实现中，[C++20 Text Formatting][2] 还处于experiment阶段。并且 [C++20 Text Formatting][2] 和 [fmtlib][1] 多多少少还是有一些不同的地方。
我们跨平台上就踩了一些坑，特此记录一下以便互相交流。

## 枚举类型的差异

首先是对枚举类型处理的差异。如果没有自定义 `formatter` ，在 [fmtlib][1] 里是能够自动转换成整数类型的输出的，但是（至少是 MSVC）的 [C++20 Text Formatting][2] 实现里是不会自动转换的，我翻了一下ISO文档好像是没看到对是否隐式转换的说明。这里会造成一处适配上的问题。比如一些小伙伴习惯用的编译器不支持 [C++20 Text Formatting][2] 而fallback到了使用 [fmtlib][1] 实现的时候，可能会忘记这个手动转换。那么切到某些编译环境上使用 [C++20 Text Formatting][2] 的时候可能会编译不过，需要再适配一次。

## Visual Studio 2019 version 16.10(MSVC 1929）的BUG

Visual Studio 2019 version 16.10(MSVC 1929）的第一个版本的实现中 `format_to_n` 实现有个BUG。里面某一层调用本该用它内部的 `_Count()` 或 `_Size()` 接口。但是用了 `size()` 。会导致编译不过。

当时版本的代码已经找不到了，并且最新版本已经修复了这个问题。碰到同类问题的童鞋们可能直接更新VS版本就行了。

## Visual Studio 2019 version 16.11 的变化

https://github.com/microsoft/STL/issues/1814

https://github.com/microsoft/STL/issues/1814#issuecomment-845572895

## fmtlib 8.0 的变化和问题

+ constexpr
+ GCC下模板通用引用对 `fmt::format_string<...>` 的透传。

```bash
/usr/include/fmt/core.h:2835:17: note: ‘consteval fmt::v8::basic_format_string<Char, Args>::basic_format_string(const S&) [with S = fmt::v8::basic_format_string<char, test_custom_object_for_log_formatter&>; typename std::enable_if<std::is_convertible<const S&, fmt::v8::basic_string_view<Char> >::value, int>::type <anonymous> = 0; Char = char; Args = {test_custom_object_for_log_formatter}]’ is not usable as a ‘constexpr’ function because:
 2835 |   FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {
      |                 ^~~~~~~~~~~~~~~~~~~
/usr/include/fmt/core.h:2835:51: error: call to non-‘constexpr’ function ‘fmt::v8::basic_format_string<Char, Args>::operator fmt::v8::basic_string_view<Char>() const [with Char = char; Args = {test_custom_object_for_log_formatter&}]’
 2835 |   FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {
      |                                                   ^~~~~~~
/usr/include/fmt/core.h:2853:14: note: ‘fmt::v8::basic_format_string<Char, Args>::operator fmt::v8::basic_string_view<Char>() const [with Char = char; Args = {test_custom_object_for_log_formatter&}]’ declared here
 2853 |   FMT_INLINE operator basic_string_view<Char>() const { return str_; }
      |              ^~~~~~~~
```

```cpp
template <typename Char, typename... Args> class basic_format_string {
 private:
  basic_string_view<Char> str_;

 public:
  template <typename S,
            FMT_ENABLE_IF(
                std::is_convertible<const S&, basic_string_view<Char>>::value)>
  FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {
    static_assert(
        detail::count<
            (std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
             std::is_reference<Args>::value)...>() == 0,
        "passing views as lvalues is disallowed");
#ifdef FMT_HAS_CONSTEVAL
    if constexpr (detail::count_named_args<Args...>() == 0) {
      using checker = detail::format_string_checker<Char, detail::error_handler,
                                                    remove_cvref_t<Args>...>;
      detail::parse_format_string<true>(str_, checker(s, {}));
    }
#else
    detail::check_format_string<Args...>(s);
#endif
  }
  basic_format_string(basic_runtime<Char> r) : str_(r.str) {}

  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
};

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
// Workaround broken conversion on older gcc.
template <typename... Args> using format_string = string_view;
template <typename S> auto runtime(const S& s) -> basic_string_view<char_t<S>> {
  return s;
}
#else
template <typename... Args>
using format_string = basic_format_string<char, type_identity_t<Args>...>;
// Creates a runtime format string.
template <typename S> auto runtime(const S& s) -> basic_runtime<char_t<S>> {
  return {{s}};
}
#endif

// ================
template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
auto vformat_to_n(OutputIt out, size_t n, string_view fmt, format_args args)
    -> format_to_n_result<OutputIt> {
  using buffer =
      detail::iterator_buffer<OutputIt, char, detail::fixed_buffer_traits>;
  auto buf = buffer(out, n);
  detail::vformat_to(buf, fmt, args, {});
  return {buf.out(), buf.count()};
}

/**
  \rst
  Formats ``args`` according to specifications in ``fmt``, writes up to ``n``
  characters of the result to the output iterator ``out`` and returns the total
  (not truncated) output size and the iterator past the end of the output range.
  \endrst
 */
template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
FMT_INLINE auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt,
                            const T&... args) -> format_to_n_result<OutputIt> {
  return vformat_to_n(out, n, fmt, fmt::make_format_args(args...));
}
```

上面的 `const T&... args` 本应该是 `T&&... args` 。

导致外层 format_string 和里层不一样，没有触发拷贝构造而是走了隐式类型转换。

这个问题我已经提了 [Issue](https://github.com/fmtlib/fmt/issues/2462) 和 [PR](https://github.com/fmtlib/fmt/pull/2463) 了。目前已经合入了，估计下个版本就会包含进去。

[1]: https://fmt.dev/
[2]: https://en.cppreference.com/w/cpp/utility/format
