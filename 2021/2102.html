<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>[Rust] 实现一个线程安全且迭代器可以保存的链表|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/2021/2102.html><link rel=icon href=../favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script type=importmap>
{
  "imports": {
    "react": "//unpkg.com/react@latest",
    "react-bootstrap": "//unpkg.com/react-bootstrap@latest",
    "mermaid": "//unpkg.com/mermaid@latest/dist/mermaid.esm.min.mjs",
    "bootstrap": "//unpkg.com/bootstrap@latest/dist/js/bootstrap.esm.min.js",
    "@popperjs/core": "//unpkg.com/@popperjs/core@latest/dist/esm/popper.js"
  }
}
</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta name=baidu-site-verification content="codeva-4M5iohb9TW"></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=../ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=../archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=../about.html title=About>About</a></li><li class="nav-item nav-ads ads-placeholder ads-container"><ins class="adsbygoogle ads_menu" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=4450372783 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=post-content><article id=post-593fbff35c6c234b90f3a80d4be05295 class="article-panel article article-type-post" itemscope itemprop=blogPost><div class="article-panel-inner article-inner"><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=//owent.net/2021/2102.html target=_blank itemprop=url>[Rust] 实现一个线程安全且迭代器可以保存的链表</a></h1></header><hr><div id=toc class="well toc m-3 p-1 pr-1 pt-1 pb-2 float-md-right float-md-end"><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#为什么不使用现有的链表>为什么不使用现有的链表</a></li><li><a href=#新链表的结构>新链表的结构</a></li><li><a href=#关于send语义sync语义线程安全>关于Send语义、Sync语义、线程安全</a></li><li><a href=#减少锁的临界区>减少锁的临界区</a></li><li><a href=#运行时可变借用>运行时可变借用</a></li><li><a href=#未来可能的偏特化优化>未来可能的偏特化优化</a></li><li><a href=#开源和包>开源和包</a></li></ul></nav><div class="ads-placeholder ads-container"><ins class="adsbygoogle ads_toc" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=1249494377 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><br><div class=article-entry itemprop=articleBody><h2 id=背景>背景</h2><p>今年有个想法，重新设计 <a href=https://github.com/atframework/libatbus>libatbus</a> 然后用 <a href=https://www.rust-lang.org/>Rust</a> 实现出来，然后可以加入一些云原生的支持。这需要一个定时器模块，我看了下 <a href=https://www.rust-lang.org/>Rust</a> 现有的几种定时器的实现，大多是基于堆或树的结构的，没有找到jiffies定时器的实现，所以想自己实现一个算了。这个定时器的实现又需要类似 C++ 的 <code>std::list::iterator</code> 的 <strong>插入和删除某个迭代器对其他迭代器没有影响</strong> 的特性，但是 <a href=https://www.rust-lang.org/>Rust</a> 的数据结构都不是这种设计模型。所以就决定自己写一个吧。</p><h2 id=为什么不使用现有的链表>为什么不使用现有的链表</h2><p>像链表这种基础的数据结构，稍微现代化的语言肯定都是带的。<a href=https://www.rust-lang.org/>Rust</a> 也不例外，提供了标准库的 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 。但是它的实现没法满足上面提到的需求。一个重要的原因是 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 也遵循 <a href=https://www.rust-lang.org/>Rust</a> 的借用和可变借用的规则，另一方面也是由于它的实现是尽可能没有额外开销。</p><blockquote><p><a href=https://www.rust-lang.org/>Rust</a> 是在编译期去分析管理对象的生命周期的，所有对象的生命周期的持有者只能有一个。所有对象都只能有一个可变借用或多个不可变借用。但是可变借用和多个不可变借用直接不能共存，相当于是编译期的读写锁。
借用可以理解为不管理生命周期的引用。</p></blockquote><p>稳定版本的 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 的迭代器 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Iter.html><code>Iter</code></a> 和 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.IterMut.html><code>IterMut</code></a> 是没有插入和删除接口的。只有向前和向后迭代的接口，也就是说只能读写链表内的元素，不能修改链表本身。
Nightly版本的 <a href=https://www.rust-lang.org/>Rust</a> 标准库里的 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 额外提供了 <code>cursor_front(&amp;self)</code> 、<code>cursor_front_mut(&amp;mut self)</code> 、<code>cursor_back(&amp;self)</code> 、<code>cursor_back_mut(&amp;mut self)</code> 来返回游标，这个游标就是在迭代器的基础上有增加了向前向后插入和删除接口，可以修改链表本身。乍看起来好像是可以符合需求，但是实际上也没法使用。</p><p>比如说，如果使用 <code>cursor_front_mut(&amp;mut self)</code> 函数创建一个可变的 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.CursorMut.html>CursorMut</a>。那么会占用掉容器的可变借用的权限。相当于会锁住这个 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 。这时候直到我释放这个 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.CursorMut.html>CursorMut</a> 前，对链表的其他操作都无法进行。所以就不能把这个游标保存起来以后用。那可不可以包一层 <a href=https://doc.rust-lang.org/std/cell/struct.RefCell.html>RefCell</a> 来运行时借用，然后只用不可变的 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 呢? 其实也是不可以的，因为首先 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 和迭代器一样没有提供修改链表本身的接口，另一方面持有 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 也会导致容器本身不能使用mutable的接口，也就无法完成增删链表节点的操作。</p><p>简单来说，无论是 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Iter.html><code>Iter</code></a> 还是 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 都是用于放在栈上临时使用的，迭代器和游标的生命周期都低于容器本身，并不适用于需要长期保存的场景。</p><h2 id=新链表的结构>新链表的结构</h2><p>从另一个角度说，我们需要的是能够保存迭代器，并在需要的时候基于迭代器操作。这本身是一个运行时可以修改容器的行为，属于运行时可变借用。与此同时还需要考虑多线程问题，即迭代器可以在多个线程中转移，就意味着可变借用这个过程可能在多个线程上同时发生。这两点都会带来额外开销。</p><p>链表的实体和节点数据结构如下:</p><pre><code class=language-rust>pub type LinkedListItem&lt;T&gt; = Arc&lt;T&gt;;
type Node&lt;T&gt; = Arc&lt;RwLock&lt;NodeEntry&lt;T&gt;&gt;&gt;;

struct NodeEntry&lt;T&gt; {
    next: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    prev: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    element: Option&lt;LinkedListItem&lt;T&gt;&gt;,
    end: Weak&lt;RwLock&lt;NodeEntry&lt;T&gt;&gt;&gt;,
    leak: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
}

struct UnmoveableLinkedList&lt;T&gt; {
    end: Node&lt;T&gt;,
    len: usize,
}

pub struct Iter&lt;T&gt; {
    node: Weak&lt;RwLock&lt;NodeEntry&lt;T&gt;&gt;&gt;,
    last_back: bool,
}
</code></pre><p>我采用了和 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 类似的做法。数据节点创建完以后，通过 <code>Box::leak</code> 函数转换成指针，然后内部使用指针来手动维护数据。然后还有几个个标准库实现不同的地方。</p><p>首先是增加了 <code>leak</code> 字段，用于简化对自己的地址的访问。像标准库的实现，接口调用的数据源都是上层的 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Iter.html><code>Iter</code></a> 或者 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 或者链表的头尾。里面都记录了对应节点的地址。但是我们这里是需要根据节点自身的数据反推出自己的地址的，不加 <code>leak</code> 字段就必须通过 <code>next</code> 和 <code>prev</code> 访问来取。比较麻烦而且增加冲突率，所以干脆直接加了 <code>leak</code> 字段。</p><p>其次增加了 <code>end</code> 字段指向链表的 <strong>Ghost</strong> 节点。这也有两个作用，其一是用于实现和 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 类似的功能。如果移到最后或者第一个，再往后或往前移一次移到 <strong>Ghost</strong> 节点，之所以要这个字段来辅助是因为 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 的 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 是不能存在两个同时改的，而我们这个链表可以。这意味着可能迭代器向后移到 <strong>Ghost</strong> 之后，接下来最后一个节点被其他地方删除了，这个迭代器再向前移一次能够移动到新的尾部节点。其二是用于检查迭代器的所属容器，因为节点里的 <code>end</code> 总是指向容器的 <code>end</code> ，然后按迭代器做插入删除的时候，我们就能根据这个检查，如果迭代器对应的节点不属于调用的容器的时候要禁止操作。</p><p>至于容器里用 <code>Node&lt;T></code> 包一层而不是像 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList</code></a> 直接存 <code>next</code> 和 <code>prev</code> 也是为了上面提到的目的。这个节点的生命周期也是跟着容器本身的。如果容器释放了，这个节点也就释放了，外部的迭代器对象无论是尝试解引用还是移到末尾都是会失败的。</p><h2 id=关于send语义sync语义线程安全>关于Send语义、Sync语义、线程安全</h2><p>标准库的 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList&lt;T></code></a> 在实例化类型 <code>T</code> 支持 <code>Send</code> 和 <code>Sync</code> 语义的时候，分别也提供了 <code>Send</code> 和 <code>Sync</code> 语义的支持。但是到我们这里会更复杂一点。因为标准库的 <a href=https://doc.rust-lang.org/std/collections/struct.LinkedList.html><code>std::collections::LinkedList&lt;T></code></a> 实际上是走了 <a href=https://www.rust-lang.org/>Rust</a> 语言层面的对修改控制权限的管理。</p><blockquote><p>包括标准库实现里的 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Iter.html><code>Iter</code></a> 和 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html><code>Cursor</code></a> 里都存了 <code>len</code> 和提供方法获取后续有多少可用元素都是依赖于此。
因为 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.IterMut.html><code>IterMut</code></a> 或 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.CursorMut.html><code>CursorMut</code></a> 只要能创建出来，那之前一定没有不可变借用了。那么对 <code>len</code> 字段的修改就有且仅有最后创建出来的这个 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.IterMut.html><code>IterMut</code></a> 或 <a href=https://doc.rust-lang.org/std/collections/linked_list/struct.CursorMut.html><code>CursorMut</code></a>。
也就不存在修改一个迭代器或游标导致影响其他迭代器或游标的问题。</p></blockquote><p>但是我们这里分离了迭代器和容器的生命周期，就不能简单地这么声明了。</p><p>首先，由于我需要让这个链表的迭代器和容器的生命周期解绑，所以对链表的节点包了一层 <code>Arc&lt;U></code> 。所以我们这个链表节点本身，其实对于所有的类型 <code>T</code> 都可以支持 <code>Send</code> 语义。但是访问实际数据的层面还是需要可以 <code>Sync</code> 才能跨线程读的。所以为了防止误用目前只对同时满足 <code>Sync + Send</code> 的 <code>T</code> 类型实现 <code>atlist_rs::LinkedList&lt;T></code> 生命为支持 <code>Send</code> 和 <code>Sync</code> 。</p><h2 id=减少锁的临界区>减少锁的临界区</h2><p>可以看到我们实际节点的类型为 <code>Arc&lt;RwLock&lt;NodeEntry&lt;T>>></code> , 中间还有一层 <code>RwLock&lt;U></code> 。因为我们解绑了迭代器和容器的生命周期，那么就无法在编译期保证多线程的场景下对节点的修改操作互相不冲突，这里的锁的作用其实也是为了支持多线程访问容器。对链表节点的 <code>mutable</code> 操作其实已经在链表接口那一层，通过 <a href=https://www.rust-lang.org/>Rust</a> 自带的借用管理控制了，不会发生冲突。举个例子，在迭代器和容器的生命周期解绑的情况下，可能发生一个线程在做删除操作，另一个线程在做这个节点的 <code>prev</code> 正在执行 <code>next(&amp;mut self)</code> 。这时候需要读这个节点内的数据，然后读到的 <code>next</code> 的指针就有可能是无效的。</p><p>这个 <code>RwLock&lt;U></code> 我们控制在内部使用，不会暴露到外部，这样可以我们自己管理和缩减锁的临界区，并且避免死锁。</p><blockquote><p>首先所有的加锁操作都是先 <code>prev</code> 再 <code>next</code> 这个顺序，就是不会出现一个线程锁 <code>A->B</code> 另一个线程锁 <code>B->A</code> 的死锁操作。另一方面，所有的写操作生命周期都是绑在 <code>atlist_rs::LinkedList&lt;T></code> 上的，根本不会并发。</p></blockquote><p>其实在写操作被限制在 <code>atlist_rs::LinkedList&lt;T></code> 的基础上，这个 <code>RwLock&lt;U></code> 理论上是可以省掉的，如果我们的记录节点内部的 <code>next</code> 和 <code>prev</code> 直接用 <code>Arc&lt;U></code> 保存，而不是按标准库一样存指针，那么也是可以保证多线程安全的，但是目前 <code>Arc&lt;U></code> 只提供了非可变借用的访问接口， <a href=https://doc.rust-lang.org/std/sync/struct.Arc.html#method.get_mut_unchecked><code>pub unsafe fn get_mut_unchecked(this: &amp;mut Arc&lt;T>) -> &amp;mut T</code></a> 还处于nightly阶段。我也不想多去造这个轮子，没啥意义，所以这个去除锁的操作还是等这个特性stable了，我再来优化吧。</p><blockquote><p>另一种不依赖 <a href=https://doc.rust-lang.org/std/sync/struct.Arc.html#method.get_mut_unchecked><code>pub unsafe fn get_mut_unchecked(this: &amp;mut Arc&lt;T>) -> &amp;mut T</code></a> 的方式是再套一层 <code>RefCell</code> 但是这会影响 <code>Send</code> 和 <code>Sync</code> 语义。所以也没有选择这么做。</p></blockquote><h2 id=运行时可变借用>运行时可变借用</h2><p>我们的链表里，用户类型的定义为 <code>pub type LinkedListItem&lt;T> = Arc&lt;T>;</code> 。这意味着对外提供的解引用接口解出的 <code>Arc&lt;T></code> 只能获取 <code>T</code> 的immutable 借用。本来最初我是想要不要套一层 <code>RefCell&lt;U></code> 来实现运行时可变借用的。但是这样感觉会提供整个库使用的难度和复杂度，而且也不线程安全。要线程安全就得也套个 <code>RwLock&lt;U></code> 或者 <code>Mutex&lt;U></code> ， 这样开销高不说也不能覆盖实际使用的场景。所以最终还是决定不套了。由使用者来决定要怎么用，要不要要跨线程等等。</p><h2 id=未来可能的偏特化优化>未来可能的偏特化优化</h2><p>还有个理想的情况是如果实例化的类型 <code>T</code> 不支持 <code>Sync + Send</code> ，那么我们的链表不需要使用 <code>Arc&lt;U></code> 包装，直接用 <code>Rc&lt;U></code> 就可以了，节点管理的 <code>RwLock&lt;U></code>也可以去掉。这样能省掉原子操作时的CPU Cache miss开销。现在的想法是使用 <em><strong>偏特化</strong></em> 实现。但是 <a href=https://www.rust-lang.org/>Rust</a> 里的 <em><strong>偏特化</strong></em> 特性目前还只处于 nightly 阶段，等这个特性stable了再优化吧。</p><h2 id=开源和包>开源和包</h2><p>包地址: <a href=https://crates.io/crates/atlist-rs>https://crates.io/crates/atlist-rs</a>
代码仓库: <a href=https://github.com/atframework/atlist-rs>https://github.com/atframework/atlist-rs</a>
自动化文档: <a href=https://docs.rs/atlist-rs/>https://docs.rs/atlist-rs/</a></p><p>可以直接 <code>Cargo.toml</code> 里通过下面的配置来引用:</p><pre><code class=language-yaml>[dependencies]
atlist-rs &gt;= &quot;0.2&quot;
</code></pre><p>目前单元测试覆盖率只有 <strong>80+%</strong> 。其实是因为有几处代码的分支是为了以后可能接入类似标准库里的splice接口预留的。现在是为了保证每个接口的完整性都实现了，其实没有外部接口引用到。以后看情况是否加这个接口或者补一下非导出接口的单元测试吧。</p></div><hr><footer class=article-footer><div class="article-panel-footer article-meta article-footer clearfix"><span class=article-meta-left><ol><li><a href=//owent.net/categories/article.html>Article</a></li><li><a href=//owent.net/categories/blablabla.html>Blablabla</a></li></ol></span><span class=article-meta-right><time datetime=2021-03-09T19:19:45.000+00:00 itemprop=datePublished>2021-03-09</time></span>
<span class=clearfix></span></div><div class=article-tags><ul class=article-tag-list><li class=article-tag-list-item><a href=//owent.net/tags/rust.html>rust</a></li><li class=article-tag-list-item><a href=//owent.net/tags/linkedlist.html>linkedlist</a></li><li class=article-tag-list-item><a href=//owent.net/tags/list.html>list</a></li></ul></div></footer><div class="ads-placeholder ads-container"><ins class="adsbygoogle ads_infeed" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=5599802929 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><hr><nav id=article-nav><ul class=pagination><li class=page-item><a class=page-link id=article-nav-newer class=article-nav-link-wrap href=//owent.net/2021/2103.html>上一篇<strong>[C++20] Module partitions和符号交叉引用（声明和实现分离）</strong></a></li><li class=page-item><a class=page-link id=article-nav-older class=article-nav-link-wrap href=//owent.net/2021/2101.html>下一篇<strong>基于protobuf的代码生成</strong></a></li></ul></nav><hr><script src=https://utteranc.es/client.js repo=owent/blog-website issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></div></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>
2024
owent
</strong><strong id=footer-right class="float-right float-end"><a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=module>
import * as Popper from "@popperjs/core";
import * as bootstrap from 'bootstrap';
// import React from "react";

</script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="//unpkg.com/katex@latest/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
import mermaid from "mermaid";
const config = {
    theme: 'neutral',
    logLevel: 'fatal',
    securityLevel: 'loose', 
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    

};
mermaid.initialize(config);
</script></div></body></html>