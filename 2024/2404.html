<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>手夯一个STL allocator和对象内存分析组件|I'm OWenT</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/2024/2404.html><link rel=icon href=../favicon.ico><link rel=stylesheet href=//unpkg.com/bootstrap@latest/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><script type=text/javascript src=//unpkg.com/jquery@latest/dist/jquery.slim.min.js crossorigin=anonymous></script><link rel=stylesheet href=//owent.net/css/syntax.css></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-toggle=collapse data-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=../ title=Home>Home</a></li><li class=nav-item><a class=nav-link href=../archives.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=../about.html title=About>About</a></li></ul><div class="col-2 position-absolute end-0"><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-2 my-sm-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=post-content><article id=post-dde8c0f14cc73b976d1889d67f8b92cf class="article-panel article article-type-post" itemscope itemprop=blogPost><div class="article-panel-inner article-inner"><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=//owent.net/2024/2404.html target=_blank itemprop=url>手夯一个STL allocator和对象内存分析组件</a></h1></header><hr><div id=toc class="well toc m-3 p-1 pr-1 pt-1 pb-2 float-md-right float-md-end"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#基础接口>基础接口</a></li><li><a href=#allocator-rebind>Allocator rebind</a></li><li><a href=#检测类型和设置alias的两种方式>检测类型和设置Alias的两种方式</a><ul><li><a href=#实现一-通过类型推导>实现一: 通过类型推导</a></li><li><a href=#实现二-通过模板参数模板推断c172conceptsc-201的requires3关键字>实现二: 通过<a href=https://en.cppreference.com/w/cpp/language/template_parameters#Template_template_arguments>模板参数模板推断（C++17）</a>+<a href=https://en.cppreference.com/w/cpp/concepts>Concepts（C++ 20）</a>的<a href=https://en.cppreference.com/w/cpp/language/requires>requires</a>关键字</a></li></ul></li><li><a href=#检测函数存在的两种实现方法>检测函数存在的两种实现方法</a><ul><li><a href=#实现一-参数类型推导helper类>实现一: 参数类型推导+helper类</a></li><li><a href=#实现二-返回值推导>实现二: 返回值推导</a></li></ul></li><li><a href=#通用标准化-allocator_traits-实现的辅助类>通用标准化 <code>allocator_traits</code> 实现的辅助类</a></li><li><a href=#按对象类型的内存统计模块>按对象类型的内存统计模块</a></li><li><a href=#boost某些容器实现的问题>boost某些容器实现的问题</a></li><li><a href=#demangle的小trick和-no-rtti-的读取符号实现>Demangle的小trick和 NO RTTI 的读取符号实现</a></li><li><a href=#效果>效果</a></li></ul></nav></div><br><div class=article-entry itemprop=articleBody><h2 id=前言>前言</h2><p>我们项目组前段时间排查和分析压测环境下的某些业务模块大量索引结构的内存问题。通用的工具比如 <a href=https://github.com/jemalloc/jemalloc>jemalloc+jeperf</a> 或者 <a href=https://github.com/google/tcmalloc>tcmalloc+gperf</a> 的组合过于底层，一方面开启跟踪开销较高，另一方面也是会产生过多噪音数据影响判断。所以我针对我们的智能指针（包含 <code>std::shared_ptr</code> 和我最近写了个非线程安全的版本的 <code>strong_rc_ptr</code> ， 这个后面有空再分享）和STL容器实现了allocator来帮助动态的手动插桩来分析问题。
最终的效果是可以通过一键替换类型申明的Allocator来插入动态控制和插桩统计的能力，这里分享一下手夯标准STL allocator的一些实现细节，方便其他小伙伴如果需要做类似的实现来参考。</p><h2 id=基础接口>基础接口</h2><p>我们可以参考 <a href=https://en.cppreference.com/w/cpp/memory/allocator><code>std::allocator</code></a> 首先是Allocator有一些基础接口，用于控制内存分配、释放、构造、析构还有max_size等。<code>std::allocator&lt;T>::allocate</code>, <code>std::allocator&lt;T>::deallocate</code>， <code>std::allocator&lt;T>::construct</code>， <code>std::allocator&lt;T>::destroy</code> , <code>std::allocator&lt;T>::max_size</code> 等。这些比较简单就不做过多赘述。仅仅有两个需要稍微关注下的点。</p><ul><li>首先是C++20以后大多数接口开始转入 <code>constexpr</code> , 如果需要完整支持就业需要给自己的实现也加上 <code>constexpr</code> 。</li><li>其次是 <code>std::allocator&lt;T>::construct</code> 和 <code>std::allocator&lt;T>::destroy</code> 这类构造和析构函数在C++20之后被移除了，转而使用 <code>std::allocator_traits&lt;Alloc>::construct</code> 和 <code>std::allocator_traits&lt;Alloc>::destroy</code> 。我们要实现定制化构造和析构的话需要优先实现 <code>allocator_traits</code> 特化。</li></ul><h2 id=allocator-rebind>Allocator rebind</h2><p>我们可以看到 <code>allocator_traits</code> 的标准里有：</p><table><thead><tr><th style=text-align:left>Type</th><th style=text-align:left>Definition</th></tr></thead><tbody><tr><td style=text-align:left><code>rebind_alloc&lt;T></code></td><td style=text-align:left><code>Alloc::rebind&lt;T>::other</code> if present, otherwise <code>SomeAllocator&lt;T, Args></code> if this Alloc is of the form <code>SomeAllocator&lt;U, Args></code>, where Args is zero or more type arguments</td></tr><tr><td style=text-align:left><code>rebind_traits&lt;T></code></td><td style=text-align:left><code>std::allocator_traits&lt;rebind_alloc&lt;T>></code></td></tr></tbody></table><p><code>allocator</code> 的标准里也有：</p><table><thead><tr><th style=text-align:left>Type</th><th style=text-align:left>Definition</th></tr></thead><tbody><tr><td style=text-align:left><code>rebind</code></td><td style=text-align:left><code>template&lt; class U > struct rebind { typedef allocator&lt;U> other; };</code></td></tr></tbody></table><p>那这个有什么用呢？</p><p>比如我们声明一个 <code>std::unordered_map&lt;K, V></code> 的时候，实际指向的是 <code>std::unordered_map&lt;K, V, std::hash&lt;K>, std::euqal_to&lt;V>, std::allocator&lt;std::pair&lt;const K, V>>></code> 。
这里可以看到allocator是 <code>std::allocator&lt;std::pair&lt;const K, V>></code> 。但是实际上unordered_map内部还要维护Hash桶，还要维护Node的树形结构。这些也是需要分配内存的，那这些怎么声明allocator类型呢？
就是通过 <code>rebind_alloc&lt;T>/rebind&lt;T>::other</code> 来实现。</p><p>实际上，对于标准C++容器而言，假设我们有自己的allocator类:</p><pre><code class=language-cpp>template&lt;class T, class... Args&gt;
custom_allocator;
</code></pre><p>我们声明容易使用的类型是 <code>custom_allocator&lt;T></code> ，当需要 <code>U</code> 类型的allocator时，会自动把allocator类型rebind到 <code>custom_allocator&lt;U></code> 。那为什么还需要通过 <code>rebind_alloc&lt;T>/rebind&lt;T>::other</code> 来实现而不是定死这个规则呢？这里的问题就出在 <code>custom_allocator&lt;T, Arg...></code> -> <code>custom_allocator&lt;U, Arg...></code> 的这个后面的类型参数 <code>Args...</code> 上。有时候并不能满足我们的需求。</p><p>比如在我们自己实现的allocator中:</p><pre><code class=language-cpp>template &lt;class T, class BackendAllocator = ::std::allocator&lt;T&gt;&gt;
struct UTIL_SYMBOL_VISIBLE allocator {
  using background_allocator_type = BackendAllocator;
  // ...
};
</code></pre><p>它是在 <code>BackendAllocator</code> 的基础上增加了统计分析能力，实际分配内存和构造析构还是使用 <code>BackendAllocator</code> 。
当STL默认的实现里传入 <code>allocator&lt;T, std::allocator&lt;T>></code> 时，如果rebind到 <code>U</code> 会变成， <code>allocator&lt;U, std::allocator&lt;T>></code> 。
这显然不是我们想要的，我们想要的是 <code>allocator&lt;U, std::allocator&lt;U>></code> 。所以我们就会特化自己的实现:</p><pre><code class=language-cpp>// STL wiil rebind rebind_alloc to allocator&lt;U, BackendAllocator&gt;, in which BackendAllocator may not be right
// So we always use rebind&lt;U&gt;::other to support allocator rebinding
template &lt;class U&gt;
struct rebind {
  using __rebind_backend_type_other =
      typename ::std::allocator_traits&lt;background_allocator_type&gt;::template rebind_alloc&lt;U&gt;;
  using other = allocator&lt;U, __rebind_backend_type_other&gt;;
};
</code></pre><h2 id=检测类型和设置alias的两种方式>检测类型和设置Alias的两种方式</h2><p>回顾前面标准的实现要求，可以看到 <code>allocator_traits</code> 内某些类型定义需要根据Allocator是否有某些定义来选择。</p><p>比如上面对 <code>std::allocator_traits&lt;Alloc>::rebind_alloc&lt;T></code> 的定义。这种编译期检测成员是否存在来走不同分支的实现，C++里要借助一些元编程的技巧。
顺着整个C++标准和编译器的演进，大体上有以下这几种方式。</p><h3 id=实现一-通过类型推导>实现一: 通过类型推导</h3><pre><code class=language-cpp>template &lt;class AllocType&gt;
struct allocator_traits {
// Foreach 每个类型
private:
  template &lt;class __TCNT&gt;
  static typename __TCNT::propagate_on_container_copy_assignment __nested_propagate_on_container_copy_assignment_helper(__TCNT*);
  static ::std::false_type __nested_propagate_on_container_copy_assignment_helper(...);

public:
  using propagate_on_container_copy_assignment =
      decltype(__nested_propagate_on_container_copy_assignment_helper(static_cast&lt;propagate_on_container_copy_assignment*&gt;(nullptr)));

};
</code></pre><h3 id=实现二-通过模板参数模板推断c172conceptsc-201的requires3关键字>实现二: 通过<a href=https://en.cppreference.com/w/cpp/language/template_parameters#Template_template_arguments>模板参数模板推断（C++17）</a>+<a href=https://en.cppreference.com/w/cpp/concepts>Concepts（C++ 20）</a>的<a href=https://en.cppreference.com/w/cpp/language/requires>requires</a>关键字</h3><p>一开始我们采用下面这个方法实现，让检测类型的模板变成公共模板。</p><pre><code class=language-cpp>template &lt;class AllocType&gt;
struct allocator_traits {
// Using void_t magic in C++17
#if ((defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201703L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)) ||
    (defined(__cpp_template_template_args) &amp;&amp; __cpp_template_template_args)
#  if __cpp_concepts
  // Implementation of the detection idiom (negative case).
  template &lt;class DefaultType, template &lt;class...&gt; class DetectTemplateType, class... TemplateArgs&gt;
  struct __nested_type_detected_or {
    using type = DefaultType;
    using __is_detected = ::std::false_type;
  };

  // Implementation of the detection idiom (positive case).
  // 注意这里的两个 `concepts` 分支里的两个 `requires`, 后一个是声明 Concept ，前一个是声明要满足这个 Concept 。
  template &lt;class DefaultType, template &lt;class...&gt; class DetectTemplateType, class... TemplateArgs&gt;
    requires requires { typename DetectTemplateType&lt;TemplateArgs...&gt;; }
  struct __nested_type_detected_or&lt;DefaultType, DetectTemplateType, TemplateArgs...&gt; {
    using type = DetectTemplateType&lt;TemplateArgs...&gt;;
    using __is_detected = ::std::true_type;
  };
#  else
  /// Implementation of the detection idiom (negative case).
  template &lt;class DefaultType, class _AlwaysVoid, template &lt;class...&gt; class DetectTemplateType, class... TemplateArgs&gt;
  struct __nested_type_detector {
    using type = DefaultType;
    using __is_detected = ::std::false_type;
  };

  /// Implementation of the detection idiom (positive case).
  template &lt;class DefaultType, template &lt;class...&gt; class DetectTemplateType, class... TemplateArgs&gt;
  struct __nested_type_detector&lt;DefaultType, ::std::void_t&lt;DetectTemplateType&lt;TemplateArgs...&gt;&gt;, DetectTemplateType,
                                TemplateArgs...&gt; {
    using type = DetectTemplateType&lt;TemplateArgs...&gt;;
    using __is_detected = ::std::true_type;
  };

  template &lt;class DefaultType, template &lt;class...&gt; class DetectTemplateType, class... TemplateArgs&gt;
  using __nested_type_detected_or = __nested_type_detector&lt;DefaultType, void, DetectTemplateType, TemplateArgs...&gt;;
#  endif  // __cpp_concepts

  template &lt;class DefaultType, template &lt;class...&gt; class DetectTemplateType, class... TemplateArgs&gt;
  using __nested_type_detected_or_t =
      typename __nested_type_detected_or&lt;DefaultType, DetectTemplateType, TemplateArgs...&gt;::type;
#endif

// Foreach 每个类型
private:
  template&lt;class __TCNT&gt;
  using __nested_type_propagate_on_container_copy_assignment = typename __TCNT::propagate_on_container_copy_assignment;

public:
  using propagate_on_container_copy_assignment = __nested_type_detected_or_t&lt;::std::false_type, __nested_type_propagate_on_container_copy_assignment, AllocType&gt;;
};
</code></pre><p>遗憾的是这个 <code>is_detected/detected_or</code> 还处于草案，至少当前的Clang版本（18）不兼容。</p><blockquote><p>可参考:</p><ul><li>GCC: <code>&lt;type_traits></code> / <code>&lt;experimental/type_traits></code></li><li>Clang: <code>&lt;experimental/type_traits></code></li></ul></blockquote><p>所以不得不还是使用老方法。这里也可以适配一下Concept。</p><pre><code class=language-cpp>template &lt;class AllocType&gt;
struct allocator_traits {
#if defined(__cpp_concepts) &amp;&amp; __cpp_concepts
private:
  template &lt;class DefaultType, class TemplateType&gt;
  struct __nested_type_propagate_on_container_copy_assignment {
    using type = DefaultType;
    using value_t = ::std::false_type;
  };
  template &lt;class DefaultType, class TemplateType&gt;
    requires requires { typename TemplateType::propagate_on_container_copy_assignment; }
  struct __nested_type_propagate_on_container_copy_assignment&lt;DefaultType, TemplateType&gt; {
    using type = typename TemplateType::propagate_on_container_copy_assignment;
    using value_t = ::std::true_type;
  };

public:
  using propagate_on_container_copy_assignment =
      typename __nested_type_propagate_on_container_copy_assignment&lt;::std::false_type, AllocType&gt;::type
#else
private:
  template &lt;class DefaultType, class TemplateType, class = void&gt;
  struct __nested_type_propagate_on_container_copy_assignment {
    using type = DefaultType;
    using value_t = ::std::false_type;
  };
  template &lt;class DefaultType, class TemplateType&gt;
  struct __nested_type_propagate_on_container_copy_assignment&lt;
      DefaultType, TemplateType, ::std::void_t&lt;typename TemplateType::propagate_on_container_copy_assignment&gt;&gt; {
    using type = typename TemplateType::propagate_on_container_copy_assignment;
    using value_t = ::std::true_type;
  };
public:
  using propagate_on_container_copy_assignment =
      typename __nested_type_propagate_on_container_copy_assignmentE&lt;::std::false_type, AllocType&gt;::type
#endif
}；
</code></pre><h2 id=检测函数存在的两种实现方法>检测函数存在的两种实现方法</h2><p>除了类型以外， <code>allocator_traits</code> 内某些接口实现也会根据Allocator是否有某些函数存在二选择不同的实现。</p><p>比如标准对 <code>std::allocator_traits&lt;Alloc>::max_size()</code> 的行为定义：</p><blockquote><p>If possible, obtains the maximum theoretically possible allocation size from the allocator a, by calling <code>a.max_size()</code>.</p><p>If the above is not possible (e.g. Alloc does not have the member function <code>max_size()</code>), then returns <code>std::numeric_limits&lt;size_type>::max() / sizeof(value_type)</code></p></blockquote><p>大体上有两种实现方式，本质上都是利用模板优先匹配的规则来实现。</p><h3 id=实现一-参数类型推导helper类>实现一: 参数类型推导+helper类</h3><pre><code class=language-cpp>// construct
template &lt;typename U, typename... _Args&gt;
struct __construct_helper {
  template &lt;typename AllocOther,
            typename = decltype(std::declval&lt;AllocOther*&gt;()-&gt;construct(std::declval&lt;U*&gt;(), std::declval&lt;_Args&gt;()...))&gt;
  static true_type __test(int);

  template &lt;typename&gt;
  static false_type __test(...);

  using type = decltype(__test&lt;allocator_type&gt;(0));
  static constexpr const bool value = type::value;
};

template &lt;typename U, typename... _Args&gt;
static inline constexpr
    typename ::std::enable_if&lt;__construct_helper&lt;U, _Args...&gt;::value, void&gt;::type
    _S_construct(allocator_type&amp; __a, U* __p, _Args&amp;&amp;... __args) {
  __a.construct(__p, std::forward&lt;_Args&gt;(__args)...);
}

template &lt;typename U, typename... _Args&gt;
static inline constexpr
    typename ::std::enable_if&lt;!__construct_helper&lt;U, _Args...&gt;::value &amp;&amp; ::std::is_constructible&lt;U, _Args...&gt;::value,
                              void&gt;::type
    _S_construct(allocator_type&amp;, U* __p, _Args&amp;&amp;... __args) {
#if defined(PROJECT_TRADE_DEBUG_OBJECT_POOL_TRACE) &amp;&amp; PROJECT_TRADE_DEBUG_OBJECT_POOL_TRACE
  global_object_pool::increase_constructor_counter_template&lt;value_type&gt;(reinterpret_cast&lt;void*&gt;(__p));
#endif

#if ((defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 202002L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 202002L))
  ::std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);
#else
  ::new ((void*)__p) U(std::forward&lt;_Args&gt;(__args)...);
#endif
}

template &lt;class T, class... Args&gt;
static inline constexpr void construct(allocator_type&amp; a, T* p, Args&amp;&amp;... args) noexcept(
    noexcept(_S_construct(a, p, std::forward&lt;Args&gt;(args)...))) {
  _S_construct(a, p, std::forward&lt;Args&gt;(args)...);
}
</code></pre><h3 id=实现二-返回值推导>实现二: 返回值推导</h3><pre><code class=language-cpp>// max_size
template &lt;typename AllocOther&gt;
static inline constexpr auto _S_max_size(const AllocOther&amp; __a, int) -&gt; decltype(__a.max_size()) {
  return __a.max_size();
}

template &lt;typename AllocOther&gt;
static inline constexpr size_type _S_max_size(const AllocOther&amp;, ...) {
  return ::std::numeric_limits&lt;size_type&gt;::max();
}

static inline constexpr size_type max_size(const allocator_type&amp; a) noexcept {
  return _S_max_size(a, 0);
}
</code></pre><h2 id=通用标准化-allocator_traits-实现的辅助类>通用标准化 <code>allocator_traits</code> 实现的辅助类</h2><p>可以看到我们想实现一个完整的 <code>allocator</code> 的必须接口还好并不是很多，但是 <code>allocator_traits</code> 的内容还是蛮多的。特别是很多实现需要借助一些C++的detection idiom技巧，还要考虑跨C++标准的兼容性，比较复杂。
所以为了降低这个实现难度，我这里提供了跨平台标准化实现。需要定制Allocator的话可以把特化 <code>std::allocator_traits&lt;Allocator></code> 继承这个辅助类然后仅仅定制化自己差异的部分就行了。</p><p>大家有需要可以自取: <a href=https://github.com/owent/atframe_utils/blob/main/include/memory/allocator_traits.h>https://github.com/owent/atframe_utils/blob/main/include/memory/allocator_traits.h</a></p><h2 id=按对象类型的内存统计模块>按对象类型的内存统计模块</h2><p>在内存统计和分析模块里，我们是需要对类型自动插桩。所以分析统计的不是像 <a href=https://github.com/jemalloc/jemalloc>jemalloc+jeperf</a> 或者 <a href=https://github.com/google/tcmalloc>tcmalloc+gperf</a> 那种基于malloc/free的。而是基于类型的。
这当中我们必然需要一些数据块来记录统计结果。那么为了减少这个开销，我们采用和类型相关的static变量的方式。简单show一下codes就是:</p><pre><code class=language-cpp>template &lt;class T&gt;
struct helper {
  static object_allocator_metrics_storage* get_instance() {
    static bool object_statistics_destroyed = false;
    static object_allocator_metrics_storage* object_statistics_inst = mutable_object_allocator_metrics_for_type(
        try_parse_raw_name(
            guess_raw_name&lt;typename ::std::remove_reference&lt;typename ::std::remove_cv&lt;T&gt;::type&gt;::type&gt;()),
        try_parse_demangle_name(
            guess_pretty_name&lt;typename ::std::remove_reference&lt;typename ::std::remove_cv&lt;T&gt;::type&gt;::type&gt;()),
        sizeof(typename ::std::remove_reference&lt;typename ::std::remove_cv&lt;T&gt;::type&gt;::type),
        object_statistics_destroyed);
    if (object_statistics_destroyed) {
      return nullptr;
    }
    return object_statistics_inst;
  }
};

template &lt;class U&gt;
static void add_constructor_counter_template(void* p) {
  if (nullptr != p) {
    add_constructor_counter(helper&lt;U&gt;::get_instance(), p);
  }
}
</code></pre><p>这里有个特殊的 <code>object_statistics_destroyed</code> 使用用于在退出阶段可能也会产生内存分配，这时候统计模块可能已经退出了。这时候就不需要统计了，不然反而循环创建销毁反而会有问题。
所有的单例模式实现如果涉及交叉引用也会有类似的问题，这又是属于另一个话题了。</p><h2 id=boost某些容器实现的问题>boost某些容器实现的问题</h2><p>理想情况下，所有标准化容器的实现我们都可以通过重定向Allocator来统计分析内存分配和构造析构。但是实际引用场景中，我们会发现很多（开源）组件其实并没有走这种完整的Allocator接入方式。
举个例子，在 <code>boost::share_ptr</code> 中，底层实际上也是会创建带引用计数相关的对象 <code>boost::detail::sp_counted_impl_p</code> , <code>boost::detail::sp_counted_impl_pd</code> , <code>boost::detail::sp_counted_impl_pda</code> 等等。
这里面充斥着一些没有走 <code>rebind_alloc/rebind</code> 的直接 <code>new/delete</code> 和 <code>placement new</code> ， 直接调用析构函数。这会导致一些统计miss掉。
所以实际实践中，特别是构造和析构，最好是不要依赖成对出现。</p><h2 id=demangle的小trick和-no-rtti-的读取符号实现>Demangle的小trick和 NO RTTI 的读取符号实现</h2><p>C++的原始符号是比较难看的，可读性好的符号。可以通过原始符号使用接口 demangle 出来。但是不同平台的方式不一样，也涉及动态内存分配。为了优化这个问题，我们采用了一个曲线救国的方案。</p><p>简单得说，对于函数模板，MSVC有 <code>__FUNCSIG__</code> 宏，GCC和Clang有 <code>__PRETTY_FUNCTION__</code> 宏可以取到 Demangle 后的名字。
大体上这个名字规则就是对于 <code>template &lt;class T> static const char* guess_pretty_name()</code> 预定义宏的名字规则大致是 <code>guess_pretty_name() [with T = 实际类型]</code>, <code>guess_pretty_name() [T = 实际类型]</code> 或<code>guess_pretty_name&lt;实际类型>(void)</code> ，然后我们根据不同的编译器剔除规则即可。
为了方便理解，直接贴一段剔除代码:</p><pre><code class=language-cpp>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

namespace atframework {
namespace memory {
    
class object_allocator_metrics_controller {
 public:
  template &lt;class T&gt;
  static const char* guess_raw_name() {
#  if defined(_MSC_VER)
    return typeid(T).raw_name();
#  else
    return typeid(T).name();
#  endif
  }

  template &lt;class T&gt;
  static const char* guess_pretty_name() {
#if defined(_MSC_VER)
    return __FUNCSIG__;
#else
    return __PRETTY_FUNCTION__;
#endif
  }
};

}
}

static const char* skip_space(const char* input) {
  if (nullptr == input) {
    return nullptr;
  }

  while (*input &amp;&amp; (' ' == *input || '\t' == *input || '\r' == *input || '\n' == *input)) {
    ++input;
  }

  return input;
}

static const char* find_char(const char* input, const char c) {
  if (nullptr == input) {
    return nullptr;
  }

  while (*input &amp;&amp; *input != c) {
    ++input;
  }

  return input;
}

std::string try_parse_demangle_name(const char* input) {
  if (nullptr == input) {
    return {};
  }

  if (!*input) {
    return {};
  }

  const char* start = input;
  while (*start) {
    if (*start == '&lt;' || *start == '[') {
      break;
    }

    ++start;
  }

  // Unknown pretty name, use origin for fallback
  do {
    if (!*start) {
      break;
    }

    // Parse guess_pretty_name() [with T = XXX]
    const char open_symbol = *start;
    const char close_symbol = open_symbol == '[' ? ']' : '&gt;';

    const char* begin;
    if (*start == '[') {
      const char* find_eq = find_char(start, '=');
      if (find_eq &amp;&amp; *find_eq == '=') {
        begin = skip_space(find_eq + 1);
      } else {
        begin = skip_space(start + 1);
      }
    } else {
      // Parse guess_pretty_name()&lt;XXX&gt;(void)
      begin = skip_space(start + 1);
    }

    size_t depth = 1;
    const char* end = begin;
    while (*end &amp;&amp; depth &gt; 0) {
      if (*end == open_symbol) {
        ++depth;
      } else if (*end == close_symbol) {
        --depth;
        if (depth &lt;= 0) {
            break;
        }
      }
      ++end;
    }

    if (end &gt; begin) {
      return std::string{begin, end};
    }
  } while (false);

  std::string fallback = input;
  std::string::size_type sidx = fallback.find(&quot;guess_pretty_name&quot;);
  if (std::string::npos != sidx) {
    return fallback.substr(sidx + 17);
  }

  return fallback;
}

namespace atfw = atframework;

template&lt;class T&gt;
void try_get_typename() {
    std::cout&lt;&lt; &quot;====================&quot;&lt;&lt; std::endl;
    std::cout&lt;&lt; &quot;Raw Name: &quot;&lt;&lt; atfw::memory::object_allocator_metrics_controller::guess_raw_name&lt;typename ::std::remove_reference&lt;typename std::remove_cv&lt;T&gt;::type&gt;::type&gt;()&lt;&lt; std::endl;
    std::cout&lt;&lt; &quot;Pretty Name: &quot;&lt;&lt; try_parse_demangle_name(atfw::memory::object_allocator_metrics_controller::guess_pretty_name&lt;typename ::std::remove_reference&lt;typename std::remove_cv&lt;T&gt;::type&gt;::type&gt;())&lt;&lt; std::endl;
}

int main()
{
    try_get_typename&lt;std::string&gt;();
    try_get_typename&lt;int[32]&gt;();
    return 0;
}
</code></pre><p>这段代码在Clang下的输出是:</p><pre><code class=language-bash>====================
Raw Name: NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
Pretty Name: std::basic_string&lt;char&gt;
====================
Raw Name: A32_i
Pretty Name: int[32]
</code></pre><p>在GCC下的输出是:</p><pre><code class=language-bash>Raw Name: NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
Pretty Name: std::__cxx11::basic_string&lt;char&gt;
====================
Raw Name: A32_i
Pretty Name: int [32]
</code></pre><p>在MSVC下的输出是:</p><pre><code class=language-bash>====================
Raw Name: .?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@
Pretty Name: class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;
====================
Raw Name: .$$BY0CA@H
Pretty Name: int[32]
</code></pre><h2 id=效果>效果</h2><p>简单展示下我们的Allocator的基础统计的部分输出：</p><table><thead><tr><th style=text-align:left>Construct counter</th><th style=text-align:left>Destructor counter</th><th style=text-align:left>Allocate Count</th><th style=text-align:left>Deallocate Count</th><th style=text-align:left>Cost</th><th style=text-align:left>Demangled name</th><th style=text-align:left>Raw name</th></tr></thead><tbody><tr><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>560B</td><td style=text-align:left>std::_Sp_counted_ptr_inplace&lt;std::basic_fstream, atframework::memory::object_allocator_manager::allocator&lt;std::basic_fstream, std::allocator&lt;std::basic_fstream > >, (__gnu_cxx::_Lock_policy)2u></td><td style=text-align:left>St23_Sp_counted_ptr_inplaceISt13basic_fstreamIcSt11char_traitsIcEEN11atframework6memory24object_allocator_manager9allocatorIS3_SaIS3_EEELN9__gnu_cxx12_Lock_policyE2EE</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>88B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const tgf::product_data_require_key, tgf::product_data_require_key_stat>, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKN3tgf24product_data_require_keyENS2_29product_data_require_key_statEELb0EEE</td></tr><tr><td style=text-align:left>1448</td><td style=text-align:left>0</td><td style=text-align:left>1448</td><td style=text-align:left>0</td><td style=text-align:left>57920B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const std::pair&lt;int, int>, std::vector&lt;global_order_manager::distribution_order_idx> >, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKS1_IiiESt6vectorIN20global_order_manager22distribution_order_idxESaIS6_EEELb0EEE</td></tr><tr><td style=text-align:left>4096</td><td style=text-align:left>0</td><td style=text-align:left>4096</td><td style=text-align:left>0</td><td style=text-align:left>288KB</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const int, std::unordered_map&lt;tgf::product_data_require_key, tgf::product_data_require_key_stat, tgf::trade_api::product_data_require_key_hash_type, tgf::trade_api::product_data_require_key_equal_type, atframework::memory::object_allocator_manager::allocator&lt;std::pair&lt;const tgf::product_data_require_key, tgf::product_data_require_key_stat>, std::allocator&lt;std::pair&lt;const tgf::product_data_require_key, tgf::product_data_require_key_stat> > > > >, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKiSt13unordered_mapIN3tgf24product_data_require_keyENS4_29product_data_require_key_statENS4_9trade_api34product_data_require_key_hash_typeENS7_35product_data_require_key_equal_typeEN11atframework6memory24object_allocator_manager9allocatorIS1_IKS5_S6_ESaISF_EEEEELb0EEE</td></tr><tr><td style=text-align:left>6574</td><td style=text-align:left>0</td><td style=text-align:left>6574</td><td style=text-align:left>0</td><td style=text-align:left>2157KB</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const tgf::DTradeMarketProductKey, tgf::product_stats_detail_info_by_cycle>, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKN3tgf22DTradeMarketProductKeyENS2_34product_stats_detail_info_by_cycleEELb0EEE</td></tr><tr><td style=text-align:left>5988</td><td style=text-align:left>2994</td><td style=text-align:left>2994</td><td style=text-align:left>0</td><td style=text-align:left>47904B</td><td style=text-align:left>global_order_manager::slot_data_order_type_db_slice_set</td><td style=text-align:left>N20global_order_manager33slot_data_order_type_db_slice_setE</td></tr><tr><td style=text-align:left>73</td><td style=text-align:left>73</td><td style=text-align:left>73</td><td style=text-align:left>73</td><td style=text-align:left>0B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const std::pair&lt;int, int>, global_order_manager::pending_calculate_product_info>, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKS1_IiiEN20global_order_manager30pending_calculate_product_infoEELb0EEE</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>1</td><td style=text-align:left>0B</td><td style=text-align:left>std::_Sp_counted_ptr_inplace&lt;logic_hpa_pull_internal_record_data, atframework::memory::object_allocator_manager::allocator&lt;logic_hpa_pull_internal_record_data, std::allocator&lt;logic_hpa_pull_internal_record_data> >, (__gnu_cxx::_Lock_policy)2u></td><td style=text-align:left>St23_Sp_counted_ptr_inplaceI35logic_hpa_pull_internal_record_dataN11atframework6memory24object_allocator_manager9allocatorIS0_SaIS0_EEELN9__gnu_cxx12_Lock_policyE2EE</td></tr><tr><td style=text-align:left>8</td><td style=text-align:left>7</td><td style=text-align:left>8</td><td style=text-align:left>7</td><td style=text-align:left>64B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const std::pair&lt;int, int>, std::map&lt;int, std::map&lt;int, std::vector<a href=tgf::DTradeMarketProductKey>tgf::DTradeMarketProductKey</a>, std::greater > > >, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKS1_IiiESt3mapIiS4_IiSt6vectorIN3tgf22DTradeMarketProductKeyESaIS7_EESt7greaterIiESaIS1_IKiS9_EEESt4lessIiESaIS1_ISC_SF_EEEELb0EEE</td></tr><tr><td style=text-align:left>8</td><td style=text-align:left>7</td><td style=text-align:left>8</td><td style=text-align:left>7</td><td style=text-align:left>64B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const std::pair&lt;int, int>, std::map&lt;int, std::map&lt;long int, std::vector<a href=tgf::DTradeMarketProductKey>tgf::DTradeMarketProductKey</a>, std::greater > > >, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKS1_IiiESt3mapIiS4_IlSt6vectorIN3tgf22DTradeMarketProductKeyESaIS7_EESt7greaterIlESaIS1_IKlS9_EEESt4lessIiESaIS1_IKiSF_EEEELb0EEE</td></tr><tr><td style=text-align:left>4</td><td style=text-align:left>2</td><td style=text-align:left>2</td><td style=text-align:left>0</td><td style=text-align:left>192B</td><td style=text-align:left>logic_hpa_pull_internal_result_data</td><td style=text-align:left>35logic_hpa_pull_internal_result_data</td></tr><tr><td style=text-align:left>112946</td><td style=text-align:left>54923</td><td style=text-align:left>56473</td><td style=text-align:left>0</td><td style=text-align:left>3529KB</td><td style=text-align:left>tgf::trade_product_sp_info_summary</td><td style=text-align:left>N3tgf29trade_product_sp_info_summaryE</td></tr><tr><td style=text-align:left>56473</td><td style=text-align:left>54923</td><td style=text-align:left>56473</td><td style=text-align:left>54923</td><td style=text-align:left>145KB</td><td style=text-align:left>util::v2006::memory::__rc_ptr_counted_data_inplace_alloc&lt;tgf::trade_product_sp_info_summary, atframework::memory::object_allocator_manager::allocator&lt;tgf::trade_product_sp_info_summary, std::allocator<a href=tgf::trade_product_sp_info_summary>tgf::trade_product_sp_info_summary</a> > ></td><td style=text-align:left>N4util5v20066memory35__rc_ptr_counted_data_inplace_allocIN3tgf29trade_product_sp_info_summaryEN11atframework6memory24object_allocator_manager9allocatorIS4_SaIS4_EEEEE</td></tr><tr><td style=text-align:left>155</td><td style=text-align:left>0</td><td style=text-align:left>155</td><td style=text-align:left>0</td><td style=text-align:left>13640B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const tgf::DTradeStandardPriceKey, std::map&lt;long int, util::v2006::memory::strong_rc_ptr<a href=tgf::trade_product_sp_info_summary>tgf::trade_product_sp_info_summary</a> > >, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKN3tgf22DTradeStandardPriceKeyESt3mapIlN4util5v20066memory13strong_rc_ptrINS2_29trade_product_sp_info_summaryEEESt4lessIlESaIS1_IKlSB_EEEELb0EEE</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>1</td><td style=text-align:left>2</td><td style=text-align:left>1</td><td style=text-align:left>112B</td><td style=text-align:left>std::__detail::_Hash_node&lt;std::pair&lt;const std::pair&lt;int, int>, global_order_manager::calculate_pool_cycle_cache>, false></td><td style=text-align:left>NSt8__detail10_Hash_nodeISt4pairIKS1_IiiEN20global_order_manager26calculate_pool_cycle_cacheEELb0EEE</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>0</td><td style=text-align:left>1</td><td style=text-align:left>0</td><td style=text-align:left>2176KB</td><td style=text-align:left>global_order_manager::slot_data_group_type</td><td style=text-align:left>N20global_order_manager20slot_data_group_typeE</td></tr><tr><td style=text-align:left>Allocator和不分内存统计的具体实现可以参见: <a href=https://github.com/atframework/atsf4g-co/blob/sample_solution/atframework/service/component/memory/object_allocator_manager.h>https://github.com/atframework/atsf4g-co/blob/sample_solution/atframework/service/component/memory/object_allocator_manager.h</a> 。</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p>后续也会根据需要酌情开源和增加malloc trace, 跟踪点diff, 动态规则的开关跟踪trace等功能。</p><p>欢迎有兴趣的小伙伴互相交流研究。</p></div><hr><footer class=article-footer><div class="article-panel-footer article-meta article-footer clearfix"><span class=article-meta-left><ol><li><a href=//owent.net/categories/article.html>Article</a></li><li><a href=//owent.net/categories/blablabla.html>Blablabla</a></li></ol></span><span class=article-meta-right><time datetime=2024-08-21T23:51:45.000+00:00 itemprop=datePublished>2024-08-21</time></span>
<span class=clearfix></span></div><div class=article-tags><ul class=article-tag-list><li class=article-tag-list-item><a href=//owent.net/tags/cpp.html>cpp</a></li><li class=article-tag-list-item><a href=//owent.net/tags/cxx.html>cxx</a></li><li class=article-tag-list-item><a href=//owent.net/tags/concepts.html>concepts</a></li><li class=article-tag-list-item><a href=//owent.net/tags/allocator.html>allocator</a></li></ul></div></footer></div><hr><nav id=article-nav><ul class=pagination><li class=page-item><a class=page-link id=article-nav-newer class=article-nav-link-wrap href=//owent.net/2024/2405.html>上一篇<strong>实现一个strong_rc_ptr(非线程安全版本的std::shared_ptr)</strong></a></li><li class=page-item><a class=page-link id=article-nav-older class=article-nav-link-wrap href=//owent.net/2024/2403.html>下一篇<strong>std::condition_variable 的信号丢失问题</strong></a></li></ul></nav><hr><script src=https://utteranc.es/client.js repo=owent/blog-website issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></div></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>
2024
owent
</strong><strong id=footer-right class="float-right float-end"><a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=text/javascript src=//unpkg.com/@popperjs/core@latest/dist/umd/popper.min.js crossorigin=anonymous></script><script type=text/javascript src=//unpkg.com/bootstrap@latest/dist/js/bootstrap.min.js crossorigin=anonymous></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/highlight.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/awk.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/bash.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cpp.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/capnproto.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/cmake.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/d.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/diff.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dockerfile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/dos.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/erlang.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/go.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/less.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/llvm.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/lua.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/php.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/powershell.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/protobuf.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/python.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/profile.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/typescript.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/vim.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/rust.min.js></script><script type=text/javascript src=//unpkg.com/@highlightjs/cdn-assets@latest/languages/yaml.min.js></script><script type=text/javascript>jQuery(function(){jQuery("head").append('<link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@latest/styles/vs2015.min.css" />'),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const e={};for(const t of hljs.listLanguages())e[t.toLowerCase()]=!0;jQuery("pre>code").each(function(e,t){try{if(t.className.match(/\bnohighlight\b|\bmermaid\b/i))return;const e=t.className.match(/language-([^\s]+)/i);if(e&&e.length>=2&&hljs.getLanguage(e[1]))hljs.highlightElement(t);else{const e=jQuery(t),n=hljs.highlightAuto(e.text(),hljs.listLanguages());n&&n.value&&(e.html(n.value),e.addClass("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-19298704-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-19298704-1")</script><script type=text/javascript src=//unpkg.com/katex@latest/dist/katex.min.js></script><script type=text/javascript src=//unpkg.com/katex@latest/dist/contrib/auto-render.min.js></script><script type=text/javascript>jQuery(function(){jQuery("head").append('<link rel="stylesheet" href="//unpkg.com/katex@latest/dist/katex.min.css" />'),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=text/javascript src=//unpkg.com/chart.js@latest/dist/chart.umd.js></script><script type=module>
    import mermaid from "\/\/unpkg.com\/mermaid@latest\/dist\/mermaid.esm.min.mjs";
    const config = {
        theme: 'neutral',
        logLevel: 'fatal',
        securityLevel: 'loose', 
        startOnLoad: true,
        arrowMarkerAbsolute: false,
        

    };
    mermaid.initialize(config);
</script></div></body></html>