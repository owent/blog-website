---
author: owent
categories:
  - Article
  - Blablabla
date: 2025-08-29 17:15:45
draft: true
id: 2506
tags: 
  - UE
  - unreal
  - unreal engine
  - CodeChecker
  - clang-tidy
title: UE使用CodeChecker和clang-tidy生成静态分析报告
type: post
---

## 背景

## UBT改造

文件: **Engine/Source/Programs/UnrealBuildTool/Platform/Linux/LinuxCommon.cs**
增加环境变量，UE_FORCE_USE_SYSTEM_COMPILER用于总控使用系统的编译器。（提升Clang版本）

```csharp
static public bool bForceUseSystemCompiler = GetDefaultForceUseSystemCompiler();

public static bool GetDefaultBoolValueFromEnvVar(string VarName)
{
    string? env = Environment.GetEnvironmentVariable(VarName);
    if (!string.IsNullOrWhiteSpace(env))
    {
        return !string.Equals(env.Trim(), "0", StringComparison.OrdinalIgnoreCase);
    }
    return false;
}

public static bool GetDefaultForceUseSystemCompiler()
{
    return GetDefaultBoolValueFromEnvVar("UE_FORCE_USE_SYSTEM_COMPILER");
}
```

文件: **Engine/Source/Programs/UnrealBuildTool/Platform/Linux/LinuxToolChain.cs**
（仅UE 5.6以下）引擎组某些定制化的组件有循环依赖，实际解决前可以先用这种方式适配。

主要改动有几处:

- `bUseFixdeps` 的赋值加上 `LinuxCommon.GetDefaultBoolValueFromEnvVar("UE_LINUX_USE_FIX_DEPS")` 。
  - `bUseFixdeps = LinuxCommon.GetDefaultBoolValueFromEnvVar("UE_LINUX_USE_FIX_DEPS")`
  - `bUseFixdeps = BuildHostPlatform.Current.Platform == UnrealTargetPlatform.Win64 || LinuxCommon.GetDefaultBoolValueFromEnvVar("UE_LINUX_USE_FIX_DEPS");`
- `ShouldUseLibcxx()` 处看需要加上 `LinuxCommon.GetDefaultBoolValueFromEnvVar("UE_LINUX_USE_SYSTEM_LIBCXX")`

> 这部分要注意一下ABI兼容性，因为UE自带的第三方库都是用自带的STL版本编译的，所以最好是用UE的libc++版本。
> 我这里自编译的llvm套件，为了防止ABI兼容性冲突，STL的abi都改成了v2，如果用的话符号会对不上。所以我是用了高版本编译器+低版本libc++。
> 如果要改的话，这里有一些参考：
>
> 1. `GetCompileArguments_Global` 里改成: `if (ShouldUseLibcxx() && !LinuxCommon.GetDefaultBoolValueFromEnvVar("UE_LINUX_USE_SYSTEM_LIBCXX"))`
> 2. 链接库的位置改成:
>
> ```csharp
> if (ShouldUseLibcxx())
> {
>   // libc++ and its abi lib
>   LinkCommandString += " -nodefaultlibs";
>   if (LinuxCommon.GetDefaultBoolValueFromEnvVar("UE_LINUX_USE_SYSTEM_LIBCXX"))
>   {
>     LinkCommandString += " -lc++";
>     LinkCommandString += " -lc++abi";
>   }
>   else
>   {
>     LinkCommandString += " -L" + "ThirdParty/Unix/LibCxx/lib/Unix/" + LinkEnvironment.Architecture.LinuxName + "/";
>     LinkCommandString += " " + "ThirdParty/Unix/LibCxx/lib/Unix/" + LinkEnvironment.Architecture.LinuxName + "/libc++.a";
>     LinkCommandString += " " + "ThirdParty/Unix/LibCxx/lib/Unix/" + LinkEnvironment.Architecture.LinuxName + "/libc++abi.a";
>   }
>   // ...
> }
> ```

文件: **Engine/Source/Programs/UnrealBuildTool/ToolChain/ClangWarnings.cs**
关闭一些高版本的warning或warning to error。（ `GetDisabledWarnings` 函数里 ）

```csharp
Arguments.Add("-Wno-misleading-indentation");
Arguments.Add("-Wno-vexing-parse");
Arguments.Add("-Wno-error=macro-redefined");
Arguments.Add("-Wno-error=shorten-64-to-32");
Arguments.Add("-Wno-error=shadow");
Arguments.Add("-Wno-error=logical-op-parentheses");
Arguments.Add("-Wno-error=unused-value");
Arguments.Add("-Wno-error=extra-qualification");
Arguments.Add("-Wno-error=range-loop-construct");
Arguments.Add("-Wno-error=comment");
Arguments.Add("-Wno-error=reorder-ctor");
Arguments.Add("-Wno-error=deprecated-comma-subscript");
Arguments.Add("-Wno-error=c++20-extensions");
Arguments.Add("-Wno-error=single-bit-bitfield-constant-conversion");
Arguments.Add("-Wno-error=null-conversion");
Arguments.Add("-Wno-error=dangling");

if (ClangVersion >= new VersionNumber(18))
{
  Arguments.Add("-Wno-deprecated-this-capture");          // https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-this-capture
  if (ClangVersion <= new VersionNumber(19))
  {
    Arguments.Add("-Wno-enum-constexpr-conversion");        // https://clang.llvm.org/docs/DiagnosticsReference.html#wenum-constexpr-conversion
  }
  Arguments.Add("-Wno-deprecated-literal-operator");
  Arguments.Add("-Wno-vla-cxx-extension");
  Arguments.Add("-Wno-invalid-unevaluated-string");
  Arguments.Add("-Wno-error=nontrivial-memcall");
}
if (ClangVersion >= new VersionNumber(19))
{
  Arguments.Add("-Wno-error=missing-template-arg-list-after-template-kw");
}

// 如果有遗漏再加就行了
```

## 分析日志

```bash
env UE_FORCE_USE_SYSTEM_COMPILER=1 UE_LINUX_USE_FIX_DEPS=1 CodeChecker log -o compile_commands.json \
    -b 'make LyraServer ARGS="-ForceUseSystemCompiler -StaticAnalyzer=Clang -StaticAnalyzerMode=deep -StaticAnalyzerOutputType=html"' 2>&1 | tee build.game.log

FIND_PCH_FILE=$(find $PWD/Projects/Intermediate/Build/Linux/x64/LyraServer/Development/Engine -name "SharedPCH.*Exceptions.*.h" | head -n 1)
if [[ -z "$FIND_PCH_FILE" ]]; then
    FIND_PCH_FILE=$(find $PWD/Projects/Intermediate/Build/Linux/x64/LyraServer/Development/Core -name "SharedPCH.*Exceptions.*.h" | head -n 1)
fi
if [[ -z "$FIND_PCH_FILE" ]]; then
    FIND_PCH_FILE=$(find $PWD/Projects/Intermediate/Build/Linux/x64/LyraServer/Development -name "SharedPCH.*Exceptions.*.h" | head -n 1)
fi
if [[ -z "$FIND_PCH_FILE" ]]; then
    FIND_PCH_FILE=$(find $PWD/Projects/Intermediate/Build/Linux/x64/LyraServer/Development/Engine -name "SharedPCH.*.h" | head -n 1)
fi
if [[ -z "$FIND_PCH_FILE" ]]; then
    FIND_PCH_FILE=$(find $PWD/Projects/Intermediate/Build/Linux/x64/LyraServer/Development/Core -name "SharedPCH.*.h" | head -n 1)
fi
if [[ -z "$FIND_PCH_FILE" ]]; then
    FIND_PCH_FILE=$(find $PWD/Projects/Intermediate/Build/Linux/x64/LyraServer/Development -name "SharedPCH.*.h" | head -n 1)
fi

python3 Projects/Script/FixClangDatabase.py -i compile_commands.json --pch "$FIND_PCH_FILE" --include-path "Projects/Source/LyraGame" --include-path "Projects/Plugins/MxLog/Source" --include-path "LyraGame/Module.LyraGame"

mv -f compile_commands.json compile_commands.json.bak

mv -f compile_commands.fixed.json compile_commands.json

CodeChecker analyze --config Projects/Plugins/MxClangSA/Source/MxClangSA/.codechecker.yaml -i Projects/Plugins/MxClangSA/Source/MxClangSA/.codechecker.skipfile -j 30 -o codechecker-result \
    compile_commands.json 2>&1 | tee build.game.log

CodeChecker parse -e html ./codechecker-result -o ./codechecker-html || true
```

```csharp
// Copyright Epic Games, Inc. All Rights Reserved.

using EpicGames.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnrealBuildTool;

public class MxClangSA : ModuleRules
{
  public class CheckerRules
  {
    public bool Configured;
    public ArrayList EnableCheckers;
    public ArrayList DisableCheckers;

    public HashSet<String> FinalCheckers;

    public CheckerRules() {
      Configured = false;
      EnableCheckers = new ArrayList();
      DisableCheckers = new ArrayList();
      FinalCheckers = null;
    }
  }

  static private Dictionary<string, CheckerRules> RulesInDirectory = new Dictionary<string, CheckerRules>();

  public MxClangSA(ReadOnlyTargetRules Target) : base(Target)
    {
        Type = ModuleType.External;
    }

  static public string GetClangSAEnableFilePath(String DirectoryPath)
  {
    return Path.Combine(DirectoryPath, ".clang-sa.enable");
  }

  static public string GetClangSADisableFilePath(String DirectoryPath)
  {
    return Path.Combine(DirectoryPath, ".clang-sa.disable");
  }

  static public string GetClangSAEnableFilePath(ReadOnlyTargetRules Target) {
    return GetClangSAEnableFilePath(Path.Combine(Target.ProjectFile.Directory.FullName, "Plugins", "MxClangSA", "Source", "MxClangSA"));
  }

  static public CheckerRules GetCheckRules(String DirectoryPath) {
    DirectoryPath = Path.GetFullPath(DirectoryPath);
    CheckerRules rules;
    lock (RulesInDirectory) {
      if (RulesInDirectory.TryGetValue(DirectoryPath, out rules)) {
        return rules;
      }
    }

    rules = new CheckerRules();
    string enableFilePath = GetClangSAEnableFilePath(DirectoryPath);
    if (File.Exists(enableFilePath))
    {
      rules.Configured = true;
      string[] checkers = File.ReadAllLines(enableFilePath);
      foreach (string checker in checkers)
      {
        int comment = checker.IndexOf('#');
        string trimmedChecker;
        if (comment >= 0)
        {
          trimmedChecker = checker.Substring(0, comment).Trim();
        }
        else
        {
          trimmedChecker = checker.Trim();
        }

        if (!string.IsNullOrWhiteSpace(trimmedChecker))
        {
          rules.EnableCheckers.Add(trimmedChecker);
        }
      }
    }

    string disableFilePath = GetClangSADisableFilePath(DirectoryPath);
    if (File.Exists(disableFilePath))
    {
      rules.Configured = true;
      string[] checkers = File.ReadAllLines(disableFilePath);
      foreach (string checker in checkers)
      {
        int comment = checker.IndexOf('#');
        string trimmedChecker;
        if (comment >= 0)
        {
          trimmedChecker = checker.Substring(0, comment).Trim();
        }
        else
        {
          trimmedChecker = checker.Trim();
        }

        if (!string.IsNullOrWhiteSpace(trimmedChecker))
        {
          rules.DisableCheckers.Add(trimmedChecker);
        }
      }
    }

    lock (RulesInDirectory)
    {
      RulesInDirectory.Add(DirectoryPath, rules);
    }

    return rules;
  }

  static public CheckerRules GetClangSACheckers(ReadOnlyTargetRules Target, String DirectoryFullName)
  {
    String ProjectFullName = Target.ProjectFile.Directory.FullName;
    String PluginFullName = Path.Combine(Target.ProjectFile.Directory.FullName, "Plugins", "MxClangSA", "Source", "MxClangSA");
    String ParentFullName = Path.GetDirectoryName(DirectoryFullName);

    CheckerRules CurrentRules = GetCheckRules(DirectoryFullName);
    if (CurrentRules.FinalCheckers != null) {
      return CurrentRules;
    }

    CurrentRules.FinalCheckers = new HashSet<string> { };
    if (!DirectoryFullName.Equals(PluginFullName) && !string.IsNullOrEmpty(ParentFullName) && !ParentFullName.Equals(DirectoryFullName))
    {
      CheckerRules ParentRules;
      if (DirectoryFullName.Equals(ProjectFullName))
      {
        ParentRules = GetClangSACheckers(Target, PluginFullName);
      }
      else
      {
        ParentRules = GetClangSACheckers(Target, ParentFullName);
        if (ParentRules.Configured)
        {
          CurrentRules.Configured = true;
        }
      }

      foreach (var item in ParentRules.FinalCheckers)
      {
        CurrentRules.FinalCheckers.Add(item);
      }
    }

    foreach (var item in CurrentRules.DisableCheckers)
    {
      CurrentRules.FinalCheckers.Remove(item.ToString());
    }

    foreach (var item in CurrentRules.EnableCheckers)
    {
      CurrentRules.FinalCheckers.Add(item.ToString());
    }

    return CurrentRules;
  }

  static public CheckerRules GetClangSACheckers(ReadOnlyTargetRules Target, ModuleRules Module)
  {
    return GetClangSACheckers(Target, Module.ModuleDirectory);
  }

  static public void SetupClangUESA(ReadOnlyTargetRules Target, ModuleRules Module)
  {
    if (Target.StaticAnalyzer != StaticAnalyzer.Clang && Target.StaticAnalyzer != StaticAnalyzer.Default)
    {
      System.Console.WriteLine($"-------------- Disable UE Static Analysis For {Module.Name} because whole disabled --------------");
      return;
    }

    CheckerRules Rules = GetClangSACheckers(Target, Module);
    if (!Rules.Configured)
    {
      System.Console.WriteLine($"-------------- Disable UE Static Analysis For {Module.Name} because no rules --------------");
      return;
    }

    if (Rules.FinalCheckers == null)
    {
      System.Console.WriteLine($"-------------- Disable UE Static Analysis For {Module.Name} because no rules --------------");
      return;
    }

    if (Rules.FinalCheckers.Count == 0)
    {
      System.Console.WriteLine($"-------------- Disable UE Static Analysis For {Module.Name} because no rules --------------");
      return;
    }

    Module.bDisableStaticAnalysis = false;
    Module.StaticAnalyzerCheckers = Rules.FinalCheckers;

    System.Console.WriteLine($"-------------- Enable UE Static Analysis For {Module.Name} --------------");
    System.Console.WriteLine($"-- Checkers: {string.Join(",", Rules.FinalCheckers)}");
  }

  static private string GetClangTidyConfigureFile(ReadOnlyTargetRules Target, string DirectoryFullName, string FileName)
  {
    string CheckModuleFullName = Path.Combine(DirectoryFullName, FileName);
    if (File.Exists(CheckModuleFullName))
    {
      return CheckModuleFullName;
    }

    string ProjectFullName = Target.ProjectFile.Directory.FullName;
    string PluginFullName = Path.Combine(Target.ProjectFile.Directory.FullName, "Plugins", "MxClangSA", "Source", "MxClangSA");
    string FallbackFullName = Path.Combine(PluginFullName, FileName);
    string ParentFullName = Path.GetDirectoryName(DirectoryFullName);

    if (!DirectoryFullName.Equals(PluginFullName) && !DirectoryFullName.Equals(ProjectFullName)
        && !string.IsNullOrEmpty(ParentFullName) && !ParentFullName.Equals(DirectoryFullName))
    {
      return GetClangTidyConfigureFile(Target, ParentFullName, FileName);
    }

    return FallbackFullName;
  }

  static public void SetupClangTidy(ReadOnlyTargetRules Target, ModuleRules Module)
  {
    if (Module.Type == ModuleType.External)
    {
      System.Console.WriteLine($"-------------- Disable ClangTidy For {Module.Name} because it's external module --------------");
      return;
    }

    // Target.IntermediateEnvironment
    string PlatformIntermediateFolder = GetPlatformIntermediateFolder(Target.Platform, Target.Architectures, false);
    string PlatformIntermediateFolderNoArch = GetPlatformIntermediateFolder(Target.Platform, null, false);

    string GeneratedCodeDirectory = GetGeneratedCodeDirectory(Target, Module, PlatformIntermediateFolderNoArch).FullName;
    string ModuleCodeDirectory = DirectoryReference.Combine(Target.ProjectFile.Directory, PlatformIntermediateFolder,
      GetTargetIntermediateFolderName(Target.Name, Target.IntermediateEnvironment),
      Target.Configuration.ToString(), Module.ShortName ?? Module.Name).FullName;
    // string ModuleDirectory = Module.ModuleDirectory;
    string[] CopyFiles = new string[] {
      ".codechecker.clang-tidy.args",
      ".codechecker.skipfile",
      ".codechecker.yaml",
      ".clang-tidy",
    };
    string[] CopyToDirs = new string[] {
      GeneratedCodeDirectory,
      ModuleCodeDirectory,
    };

    System.Console.WriteLine($"-------------- Setup ClangTidy For {Module.Name} --------------");
    foreach (string CopyFile in CopyFiles)
    {
      string ConfigureFilePath = GetClangTidyConfigureFile(Target, Module.ModuleDirectory, CopyFile);
      foreach (string CopyToDir in CopyToDirs)
      {
        string TargetFilePath = Path.Combine(CopyToDir, CopyFile);
        System.Console.WriteLine($"Setup ClangTidy: Copy {ConfigureFilePath} to {TargetFilePath}");
        if (!Directory.Exists(CopyToDir))
        {
          Directory.CreateDirectory(CopyToDir);
        }
        File.Copy(ConfigureFilePath, TargetFilePath, true);
      }
    }
  }

  static public void SetupClangSA(ReadOnlyTargetRules Target, ModuleRules Module)
  {
    SetupClangUESA(Target, Module);
    SetupClangTidy(Target, Module);
  }

  // UnrealBuildTool.UEBuildTarget.GetTargetIntermediateFolderName 是引擎内部接口，类不是Public的
  // 这里复制了一份出来，保持代码逻辑一致
  public static string GetTargetIntermediateFolderName(string TargetName, UnrealIntermediateEnvironment IntermediateEnvironment)
  {
    string TargetFolderName = TargetName;
    switch (IntermediateEnvironment)
    {
      case UnrealIntermediateEnvironment.IWYU:
        TargetFolderName += "IWYU";
        break;
      case UnrealIntermediateEnvironment.NonUnity:
        TargetFolderName += "NU";
        break;
      case UnrealIntermediateEnvironment.Analyze:
        TargetFolderName += "SA";
        break;
    }
    return TargetFolderName;
  }

  // UnrealBuildTool.UEBuildTarget.GetPlatformIntermediateFolder 是引擎内部接口，类不是Public的
  // 这里复制了一份出来，保持代码逻辑一致
  public static string GetPlatformIntermediateFolder(UnrealTargetPlatform Platform, UnrealArchitectures Architectures, bool External)
  {
    // now that we have the platform, we can set the intermediate path to include the platform/architecture name
    string FolderPath = Path.Combine("Intermediate", External ? "External" : String.Empty, "Build", Platform.ToString());
    if (Architectures != null)
    {
      FolderPath = Path.Combine(FolderPath, UnrealArchitectureConfig.ForPlatform(Platform).GetFolderNameForArchitectures(Architectures));
    }
    return FolderPath;
  }

  static public DirectoryReference GetGeneratedCodeDirectory(ReadOnlyTargetRules Target, ModuleRules Module, string PlatformIntermediateFolderNoArch)
  {
    DirectoryReference GeneratedCodeDirectory = null;
    // Get the base directory
    // if (Module.Context)
    // {
    //   GeneratedCodeDirectory = Module.Context.DefaultOutputBaseDir;
    // }
    // else
    // {
      GeneratedCodeDirectory = Target.ProjectFile.Directory;
    // }

    // Get the subfolder containing generated code - we don't need architeceture information since these are shared between all arches for a platform
    GeneratedCodeDirectory = DirectoryReference.Combine(GeneratedCodeDirectory, PlatformIntermediateFolderNoArch, GetTargetIntermediateFolderName(Target.Name, Target.IntermediateEnvironment), "Inc");

    // Append the binaries subfolder, if present. We rely on this to ensure that build products can be filtered correctly.
    if (Module.BinariesSubFolder != null)
    {
      GeneratedCodeDirectory = DirectoryReference.Combine(GeneratedCodeDirectory, Module.BinariesSubFolder);
    }

    // Finally, append the module name (using the ShortName if it has been set)
    GeneratedCodeDirectory = DirectoryReference.Combine(GeneratedCodeDirectory, Module.ShortName ?? Module.Name);

    return GeneratedCodeDirectory;
  }
}
```

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import codecs
import re
import argparse
import os
import sys
import json
from typing import List, Tuple, Set, Optional, Dict

__VERSION__ = "1.0.0"

CLANG_DATABASE_IGNORE_OPTIONS = set(["-c"])


def try_read_file(file_path):
    _err = None
    for try_encoding in ["utf-8", "utf-8-sig", "GB18030"]:
        try:
            ret = codecs.open(file_path, "r", encoding=try_encoding)
            return ret
        except Exception as e:
            if _err is None:
                _err = e
            if not os.path.exists(file_path):
                break
    raise _err


class ClangDatabaseProcessor:
    def __init__(
        self,
        engine_source: str,
        input_file: str,
        output_file: str,
        include_path: List[str],
        exclude_path: List[str],
        pch: Optional[str],
        verbose: bool,
    ):
        self.engine_source = engine_source
        self.input_file = input_file
        self.output_file = output_file
        self.include_path: List[re.Pattern] = [
            re.compile(p, re.IGNORECASE) for p in include_path
        ]
        self.exclude_path: List[re.Pattern] = [
            re.compile(p, re.IGNORECASE) for p in exclude_path
        ]
        self.expanded_cache: Dict[str, List[str]] = dict()
        self.pch = pch
        self.verbose = verbose

    def process(self):
        # Implement the processing logic here
        result = []
        json_data = self._parse_json()
        for item in json_data:
            if not self._should_include(item):
                continue
            if self.verbose:
                print(f"Processing command for file: {item['file']}")
            result.append(self._resolve_item(item))
        json.dump(result, self.output_file, indent=2)

    def _parse_flag_with_file(self, token, previous_token, flag):
        if previous_token == flag:
            file_path = token
            prefix = ""
            suffix = ""
            if (file_path.startswith('"') and file_path.endswith('"')) or (
                file_path.startswith("'") and file_path.endswith("'")
            ):
                file_path = file_path[1:-1]
                prefix = token[:1]
                suffix = token[:1]
            return (file_path, prefix, suffix)

        if not token.startswith(flag):
            return (None, None, None)

        flag_len = len(flag)
        prefix = token[:flag_len]
        suffix = ""
        file_path = token[flag_len:]
        if (file_path.startswith('"') and file_path.endswith('"')) or (
            file_path.startswith("'") and file_path.endswith("'")
        ):
            file_path = file_path[1:-1]
            prefix = token[: (flag_len + 1)]
            suffix = token[flag_len : (flag_len + 1)]
        return (file_path, prefix, suffix)

    def _resolve_token(self, token, previous_token):
        (file_path, prefix, suffix) = self._parse_flag_with_file(
            token, previous_token, "@"
        )
        if file_path:
            return self._resolve_response(file_path)

        (file_path, prefix, suffix) = self._parse_flag_with_file(
            token, previous_token, "-I"
        )
        if file_path:
            return self._resolve_flag_with_file_path(file_path, prefix, suffix)

        (file_path, prefix, suffix) = self._parse_flag_with_file(
            token, previous_token, "-isystem"
        )
        if file_path:
            return self._resolve_flag_with_file_path(file_path, prefix, suffix)

        (file_path, prefix, suffix) = self._parse_flag_with_file(
            token, previous_token, "-MF"
        )
        if file_path:
            return self._resolve_flag_with_file_path(file_path, prefix, suffix)

        (file_path, prefix, suffix) = self._parse_flag_with_file(
            token, previous_token, "-o"
        )
        if file_path:
            return self._resolve_flag_with_file_path(file_path, prefix, suffix)

        return [token]

    def _resolve_response(self, file_path):
        if not os.path.isabs(file_path):
            file_path = os.path.join(self.engine_source, file_path)
        if file_path in self.expanded_cache:
            return self.expanded_cache[file_path]
        expanded_paths = []
        try:
            with try_read_file(file_path) as rsp_file:
                previous_token = ""
                for line in rsp_file:
                    line = line.strip()
                    if not line:
                        continue
                    for token in self._split_tokens(line):
                        if token in CLANG_DATABASE_IGNORE_OPTIONS:
                            continue
                        expanded_paths.extend(
                            self._resolve_token(token, previous_token)
                        )
                        previous_token = token
            self.expanded_cache[file_path] = expanded_paths
            if self.verbose:
                print(
                    f"  - Expand response file '{file_path}' to {len(expanded_paths)} args"
                )
        except Exception as e:
            print(
                f"  - Error reading response file '{file_path}': {e}", file=sys.stderr
            )
            return [f'@"{file_path}"']
        return expanded_paths

    def _resolve_flag_with_file_path(self, file_path, prefix, suffix):
        if not os.path.isabs(file_path):
            file_path = os.path.realpath(os.path.join(self.engine_source, file_path))
        return [f"{prefix}{file_path}{suffix}"]

    def _next_token(self, input, start_idx):
        sz = len(input)
        while start_idx < sz and input[start_idx].isspace():
            start_idx += 1

        if start_idx >= sz:
            return (None, sz)

        string_quote = None
        end_idx = start_idx
        while end_idx < sz and not input[end_idx].isspace():
            if input[end_idx] == '"' or input[end_idx] == "'":
                string_quote = input[end_idx]
                end_idx += 1
                ignore_next = False
                while end_idx < sz and (ignore_next or input[end_idx] != string_quote):
                    ignore_next = input[end_idx] == "\\"
                    end_idx += 1
                if end_idx < sz:
                    end_idx += 1
            else:
                end_idx += 1
        return (input[start_idx:end_idx], end_idx)

    def _split_tokens(self, input):
        # Split the input into tokens based on whitespace
        idx = 0
        sz = len(input)
        ret = []
        while idx < sz:
            token, end_idx = self._next_token(input, idx)
            if token is not None:
                ret.append(token)
            idx = end_idx
        return ret

    def _resolve_item(self, item):
        command_args = []

        checked_pch = False
        # Resolve response files
        tokens = self._split_tokens(item["command"])
        previous_token = ""
        for token in tokens:
            if token in CLANG_DATABASE_IGNORE_OPTIONS:
                continue

            command_args.extend(self._resolve_token(token, previous_token))
            previous_token = token
            if not checked_pch:
                checked_pch = True
                if self.pch and self.pch.strip():
                    command_args.extend(["-include", f'"{self.pch}"'])

        if "-Wno-unused-command-line-argument" not in command_args:
            command_args.append("-Wno-unused-command-line-argument")

        if self.verbose:
            print(
                f"  * Resolve command for file: {item['file']} from {len(tokens)} args to {len(command_args)} args"
            )

        item["command"] = " ".join(command_args)
        # Patch file
        file_path = item["file"]
        if file_path.startswith("@"):
            file_path = file_path[1:]
            if file_path.endswith(".d.rsp"):
                file_path = file_path[: -len(".d.rsp")]
            item["file"] = file_path
        return item

    def _should_include(self, item):
        if "file" not in item or "command" not in item:
            return False
        file_param = item["file"]
        if self.include_path:
            if not any(p.search(file_param) for p in self.include_path):
                return False
        if self.exclude_path and any(p.search(file_param) for p in self.exclude_path):
            return False
        return True

    def _parse_json(self):
        json_data = json.load(self.input_file)
        # Process the JSON data as needed
        return json_data


def main():
    global __VERSION__

    parser = argparse.ArgumentParser(usage="%(prog)s [options...]")
    parser.add_argument("REMAINDER", nargs=argparse.REMAINDER, help="task names")
    parser.add_argument(
        "-v",
        "--version",
        action="store_true",
        help="show version and exit",
        dest="version",
        default=False,
    )

    parser.add_argument(
        "-V",
        "--verbose",
        action="store_true",
        help="show verbose",
        dest="verbose",
        default=False,
    )

    parser.add_argument(
        "-i",
        "--input",
        action="store",
        help="set input clang database build file (default: compile_commands.json)",
        dest="input",
        default="compile_commands.json",
    )

    parser.add_argument(
        "-o",
        "--output",
        action="store",
        help="set output clang database build file (default: compile_commands.json)",
        dest="output",
        default=None,
    )

    parser.add_argument(
        "--include-path",
        action="append",
        help="only keep files match include path(regex)",
        dest="include_path",
        default=[],
    )

    parser.add_argument(
        "--exclude-path",
        action="append",
        help="only keep files match exclude path(regex)",
        dest="exclude_path",
        default=[],
    )

    parser.add_argument(
        "--pch",
        action="store",
        help="set the pch file to include",
        dest="pch",
        default=None,
    )

    if os.path.exists(
        os.path.join(os.getcwd(), "Engine", "Source", "UnrealGame.Target.cs")
    ):
        find_default_engine_source = os.path.join(os.getcwd(), "Engine", "Source")
    elif os.path.exists(
        os.path.join(os.getcwd(), "..", "Engine", "Source", "UnrealGame.Target.cs")
    ):
        find_default_engine_source = os.path.realpath(
            os.path.join(os.getcwd(), "..", "Engine", "Source")
        )
    elif os.path.exists(
        os.path.join(
            os.getcwd(), "..", "..", "Engine", "Source", "UnrealGame.Target.cs"
        )
    ):
        find_default_engine_source = os.path.realpath(
            os.path.join(os.getcwd(), "..", "..", "Engine", "Source")
        )
    else:
        find_default_engine_source = os.getcwd()
    parser.add_argument(
        "-e",
        "--engine-source",
        action="store",
        help="set path of Engine/Source, it will be used to convert relative paths",
        dest="engine_source",
        default=find_default_engine_source,
    )

    options = parser.parse_args()
    if options.version:
        print(__VERSION__)
        return 0

    if options.input.strip() == "-":
        input_file = sys.stdin
    else:
        input_file = try_read_file(options.input)

    output_file_path = options.output
    if output_file_path is None:
        (input_base, input_ext) = os.path.splitext(options.input)
        if input_ext:
            output_file_path = input_base + ".fixed" + input_ext
        else:
            output_file_path = input_base + ".fixed"

    processor = ClangDatabaseProcessor(
        engine_source=options.engine_source,
        input_file=input_file,
        output_file=codecs.open(output_file_path, "w", encoding="utf-8"),
        include_path=options.include_path,
        exclude_path=options.exclude_path,
        pch=options.pch,
        verbose=options.verbose,
    )
    print(f"[FixClangDatabase]: Using engine source at {options.engine_source}")
    print(f"[FixClangDatabase]: Process {options.input} -> {output_file_path}")
    processor.process()

    return 0


if __name__ == "__main__":
    exit(main())

```

## 最后

[1]: https://fmt.dev/
[2]: https://en.cppreference.com/w/cpp/utility/format.html
