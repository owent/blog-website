<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>找出UE的循环依赖|I'm OWenT</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=canonical href=//owent.net/2025/2506.html><link rel=icon href=/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//owent.net//css/style.css><link rel=stylesheet href=//owent.net/css/syntax.css><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8180054975285991" crossorigin=anonymous></script><meta content="codeva-4M5iohb9TW" name=baidu-site-verification></head><body><div id=container><div id=wrap><header id=header><div id=banner></div><div id=header-outer><div id=header-title><h1 id=site-title><a href=//owent.net/ id=logo>I'm OWenT</a></h1><h2 id=site-description>Challenge Everything</h2></div><div id=header-inner><nav id=main-nav class="navbar navbar-expand-md navbar-dark"><button class="navbar-toggler navbar-toggler-right" type=button data-bs-toggle=collapse data-bs-target=#main-nav-links aria-controls=main-nav-links aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<a id=main-nav-brand class="navbar-brand collapse" href=#>#</a><div class="collapse navbar-collapse position-relative" id=main-nav-links><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/index.html title=Home>Home</a></li><li class=nav-item><a class=nav-link href=/archives/index.html title=Archives>Archives</a></li><li class=nav-item><a class=nav-link href=/about/index.html title=About>About</a></li></ul><div class="col-12 col-xl-2 col-lg-3 col-md-4" id=main-nav-search><form class=input-group method=get accept-charset=UTF-8 action=//www.bing.com/search><input type=hidden name=q1 value=site:owent.net>
<input class=form-control type=text placeholder=搜索 name=q>
<button class="btn btn-outline-secondary my-0" type=submit>搜索</button></form></div></div></nav></div></div></header><div id=main><section id=main-content><div id=post-content><article id=post-cb717325038f32478e9073d6ca766141 class="article-panel article article-type-post" itemscope itemprop=blogPost><div class="article-panel-inner article-inner"><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=//owent.net/2025/2506.html target=_blank itemprop=url>找出UE的循环依赖</a></h1></header><hr><div id=toc class="well toc m-3 p-1 pr-1 pt-1 pb-2 float-md-right float-md-end"><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#日志分析>日志分析</a><ul><li><a href=#1link-阶段-so-的-cyclic-actions>1）Link 阶段 <code>.so</code> 的 cyclic actions</a></li><li><a href=#2元数据生成阶段-targetmodules-的-cyclic-actions>2）元数据生成阶段 <code>.target/.modules</code> 的 cyclic actions</a></li><li><a href=#为什么-ubt-的信息不便直接使用>为什么 UBT 的信息不便直接使用？</a></li></ul></li><li><a href=#设计思路>设计思路</a></li><li><a href=#工具实现>工具实现</a><ul><li><a href=#实现要点>实现要点</a></li></ul></li><li><a href=#输出解读>输出解读</a></li><li><a href=#使用方法>使用方法</a><ul><li><a href=#1收集构建日志>1）收集构建日志</a></li><li><a href=#2运行脚本>2）运行脚本</a></li></ul></li><li><a href=#效果示例>效果示例</a></li><li><a href=#依赖环的常见形态>依赖环的常见形态</a><ul><li><a href=#1单一简单环>1）单一简单环</a></li><li><a href=#2多个环共享链路>2）多个环共享链路</a></li><li><a href=#3共享更长的链路>3）共享更长的链路</a></li></ul></li><li><a href=#打破循环依赖的方法>打破循环依赖的方法</a><ul><li><a href=#1抽取公共模块推荐>1）抽取公共模块（推荐）</a></li><li><a href=#2引入接口模块>2）引入接口模块</a></li><li><a href=#3降级为-includepathmodulenames>3）降级为 IncludePathModuleNames</a></li><li><a href=#4显式声明循环依赖兜底方案>4）显式声明循环依赖（兜底方案）</a></li></ul></li><li><a href=#局限性与改进方向>局限性与改进方向</a></li><li><a href=#总结>总结</a></li></ul></nav><div class="ads-placeholder ads-container"><ins class="adsbygoogle ads_toc" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=1249494377 data-ad-format="rectangle, vertical" data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><br><div class=article-entry itemprop=articleBody><h2 id=背景>背景</h2><p>在大型 UE（Unreal Engine）项目中，&ldquo;模块/插件"是维持工程可维护性的基本手段。但随着工程规模增长，很容易出现循环依赖问题：</p><ul><li>模块 A 为了复用工具函数依赖模块 B</li><li>模块 B 为了注册某些类型或访问某些资源又依赖模块 A</li><li>在某些平台或配置下（尤其是 Editor 构建或 Link 阶段需要聚合大量 <code>.so/.a</code> 时），最终表现为 <strong>循环依赖</strong></li></ul><p>UBT（UnrealBuildTool）能检测到循环依赖，但输出的是 <em>ActionGraph</em> 层面的信息：大量 <code>Action #xxxx</code>，并提示"这些 action 互相成环&rdquo;。对于实际排障来说，主要痛点在于：</p><ol><li>Action ID 数量庞大、信息分散</li><li>一次循环往往牵涉多个 <code>.so</code> / <code>.modules</code> 文件</li><li>真正需要的答案是：<strong>&ldquo;改动哪一条依赖能最快打破环？&rdquo;</strong></li></ol><p>为此我编写了一个小工具：从 UBT 日志中提取循环依赖相关的 action，构建依赖图并找出更短、更值得优先处理的循环链路，辅助定位 <em>最小改动点</em>。</p><p>本文按"日志分析 → 工具实现 → 输出解读 → 实际拆环"的顺序展开。</p><h2 id=日志分析>日志分析</h2><p>首先分析 UBT 报告循环依赖时的典型日志片段（以下示例来自 Linux 构建 UnrealEditor，Windows/MSVC 下结构类似）。</p><h3 id=1link-阶段-so-的-cyclic-actions>1）Link 阶段 <code>.so</code> 的 cyclic actions</h3><p>这段日志包含两个关键信息：</p><ul><li><code>Action #700</code> 产出 <code>libUnrealEditor-ActorSequence.so</code></li><li>它 &ldquo;Depends on cyclic actions&rdquo;，列出了 action 2282/1270/1503/1263</li></ul><p>从工程视角看，这意味着参与链接的几个库之间存在互相依赖，导致链接顺序无法拓扑排序。</p><pre><code class=language-{mermaid}>flowchart LR
    A[Action #700\nLink ActorSequence.so]
    E[Action #2282\nproduce Engine.so]
    M[Action #1270\nproduce MovieScene.so]
    MT[Action #1503\nproduce MovieSceneTracks.so]
    T[Action #1263\nproduce TimeManagement.so]

    A --&gt; E
    A --&gt; M
    A --&gt; MT
    A --&gt; T

    %% cyclic actions 本质上是在说：这几个节点之间成环
    E --&gt; M
    M --&gt; MT
    MT --&gt; T
    T --&gt; E
</code></pre><pre><code class=language-text>Action #700: /bin/sh
    with arguments:  &quot;/data/Stream_Depot/Client/Engine/Intermediate/Build/Linux/x64/UnrealEditor/Development/Link-libUnrealEditor-ActorSequence.so.link.sh&quot;
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-Core.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-CoreUObject.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-Engine.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieScene.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieSceneTracks.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-TimeManagement.so
    depends on: /data/Stream_Depot/Client/Engine/Plugins/MovieScene/ActorSequence/Intermediate/Build/Linux/x64/UnrealEditor/Development/ActorSequence/Module.ActorSequence.cpp.o
    depends on: /data/Stream_Depot/Client/Engine/Plugins/MovieScene/ActorSequence/Intermediate/Build/Linux/x64/UnrealEditor/Development/ActorSequence/libUnrealEditor-ActorSequence.so.rsp
    produces:   /data/Stream_Depot/Client/Engine/Plugins/MovieScene/ActorSequence/Binaries/Linux/libUnrealEditor-ActorSequence.so
    Depends on cyclic actions:
        2282 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-Engine.so)
        1270 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieScene.so)
        1503 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieSceneTracks.so)
        1263 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-TimeManagement.so)
</code></pre><h3 id=2元数据生成阶段-targetmodules-的-cyclic-actions>2）元数据生成阶段 <code>.target/.modules</code> 的 cyclic actions</h3><p>循环依赖也可能发生在元数据生成阶段，而非 Link 阶段。这类日志的特点是：一个 action 产出 <code>.target</code> 文件，另一个 action 产出多个平台的 <code>.modules</code> 文件，两者互相依赖形成环。</p><pre><code class=language-text>Action #5333: /data/Stream_Depot/Client/Engine/Binaries/ThirdParty/DotNet/6.0.302/linux/dotnet
    with arguments: &quot;/data/Stream_Depot/Client/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.dll&quot; -Mode=WriteMetadata -Input=&quot;/data/Stream_Depot/Client/Engine/Intermediate/Build/Linux/x64/UnrealEditor/Development/TargetMetadata.dat&quot; -Version=2
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/UnrealEditor.version
    depends on: /data/Stream_Depot/Client/Engine/Intermediate/Build/Linux/x64/UnrealEditor/Development/TargetMetadata.dat
    produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/UnrealEditor.target
    Depends on cyclic actions:
        5332
            produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/Android/UnrealEditor.modules
            produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/Linux/UnrealEditor.modules
            produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/LinuxArm64/UnrealEditor.modules
            ...
</code></pre><h3 id=为什么-ubt-的信息不便直接使用>为什么 UBT 的信息不便直接使用？</h3><p>UBT 日志存在以下阅读障碍：</p><ol><li><strong>Action ID 缺少上下文</strong>：需要从 <code>produces:</code> 反推对应的模块/目标。</li><li><strong>只告知存在环，未指明拆解点</strong>：循环中每条依赖可能是必要的，也可能只是冗余的间接引用。</li><li><strong>环的数量可能很多</strong>：大型工程中 UBT 可能报告多个循环点，需要确定优先级。</li></ol><p>因此本工具的目标不是替代 UBT 检测，而是：</p><ul><li>将 UBT 输出的循环 action 信息结构化为图</li><li>在图上进行轻量分析：找出更短的环，估算更值得优先拆解的链路</li></ul><h2 id=设计思路>设计思路</h2><p>将每个 <code>Action #id</code> 视为图中的一个节点：</p><ul><li><strong>节点属性</strong>：<code>produces:</code> 的文件列表（用于识别模块）</li><li><strong>有向边</strong>：<code>Action A</code> 的 &ldquo;Depends on cyclic actions&rdquo; 中列出的 <code>Action B</code>，视为边 <code>A -> B</code></li></ul><p>这样"循环依赖"即为图中的 <strong>有向环</strong>。</p><p>工具的处理流程如下：</p><pre><code class=language-{mermaid}>flowchart LR
    L[&quot;UBT Build Log&quot;] --&gt; P[&quot;正则解析 Action/produces/cyclic-actions&quot;]
    P --&gt; G[&quot;构建 ActionGraph&lt;br/&gt;节点=Action, 边=A depends B&quot;]
    G --&gt; C[&quot;DFS 扫描环&lt;br/&gt;记录环上的 action 序列&quot;]
    C --&gt; S[&quot;按链路长度和权重排序&quot;]
    S --&gt; O[&quot;输出候选环&lt;br/&gt;并列出每个 action 的产物文件&quot;]
</code></pre><h2 id=工具实现>工具实现</h2><p>以下是核心实现的 Python 脚本。</p><h3 id=实现要点>实现要点</h3><ul><li>使用正则匹配 <code>Action #xxx</code>、<code>produces:</code> 以及 <code>Depends on cyclic actions:</code> 后的 action id</li><li>将依赖关系存储到图结构中</li><li>通过 DFS 扫描依赖链，遇到栈内已存在的节点即认为找到一个环</li><li>为环上的边计算启发式权重：被依赖次数（<code>depended_count</code>）越高的节点，越可能是公共库/关键节点，在环中越值得优先关注</li></ul><blockquote><p><strong>注意</strong>：权重仅用于启发式排序，并非数学意义上的"最小反馈边集"。实践经验表明：<strong>先找出短环，再通过产物文件定位模块</strong>，排障效率更高。</p></blockquote><pre><code class=language-python>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import codecs
import re
import argparse
import os
import sys

__VERSION__ = &quot;1.0.0&quot;

UE_LOG_ACTION_START = re.compile(&quot;^\\s*Action #\\s*(?P&lt;ACTION_ID&gt;\\d+)\\s*:&quot;)
UE_LOG_ACTION_PRODUCE = re.compile(&quot;^\\s\\s*produces\\s*:\\s*(?P&lt;PRODUCE_FILE&gt;.+)$&quot;)
UE_LOG_ACTION_DEP_START = re.compile(
    &quot;^\\s\\s*Depends\\s+on\\s+cyclic\\s+actions&quot;, re.IGNORECASE
)
UE_LOG_ACTION_DEP_ID = re.compile(
    &quot;^\\s\\s\\s*(?P&lt;ACTION_ID&gt;\\d+)\\s*(\\(\\s*produces\\s*:|$)&quot;
)


class UEActionGraphNode:
    def __init__(self, action_id):
        self.action_id = action_id
        self.produce_files = []
        self.depend_actions = set()
        self.depended_count = 0

    def add_produce_file(self, file_path):
        if file_path not in self.produce_files:
            self.produce_files.append(file_path)

    def add_depend_action(self, action):
        if action not in self.depend_actions:
            self.depend_actions.add(action)
            action.depended_count += 1


class UEActionGraphSet:
    def __init__(self):
        self.actions = dict()

    def mutable_action(self, action_id):
        if action_id not in self.actions:
            self.actions[action_id] = UEActionGraphNode(action_id)
        return self.actions[action_id]

    def get_action(self, action_id):
        return self.actions.get(action_id, None)

    def __getitem__(self, action_id):
        return self.get_action(action_id)

    def __contains__(self, action_id):
        return action_id in self.actions


class UEActionGraphCircle:
    def __init__(self, from_action, to_action):
        self.from_action = from_action
        self.to_action = to_action
        self.weight = 0


def try_read_file(file_path):
    _err = None
    if not os.path.isabs(file_path):
        file_path = os.path.join(os.getcwd(), file_path)
    for try_encoding in [&quot;utf-8&quot;, &quot;utf-8-sig&quot;, &quot;GB18030&quot;]:
        try:
            ret = codecs.open(file_path, &quot;r&quot;, encoding=try_encoding)
            return ret
        except Exception as e:
            if _err is None:
                _err = e
            if not os.path.exists(file_path):
                break
    raise _err


def build_deps_from_fd(file):
    last_action_node = None
    actions = UEActionGraphSet()
    deps_started = False
    for line in file:
        mat = UE_LOG_ACTION_START.match(line)
        if mat:
            last_action_node = actions.mutable_action(int(mat.group(&quot;ACTION_ID&quot;)))
            deps_started = False
            continue

        if last_action_node is not None:
            mat = UE_LOG_ACTION_DEP_START.match(line)
            if mat:
                deps_started = True
                continue

        if last_action_node is not None:
            if deps_started:
                mat = UE_LOG_ACTION_DEP_ID.match(line)
                if mat:
                    dep_action_id = int(mat.group(&quot;ACTION_ID&quot;))
                    last_action_node.add_depend_action(
                        actions.mutable_action(dep_action_id)
                    )
                    continue
            else:
                mat = UE_LOG_ACTION_PRODUCE.match(line)
                if mat:
                    produce_file = mat.group(&quot;PRODUCE_FILE&quot;)
                    last_action_node.add_produce_file(produce_file)
                    continue

        if last_action_node is not None and (
            line.strip() == &quot;&quot; or (line and line[0] != &quot; &quot; and line[0] != &quot;\t&quot;)
        ):
            last_action_node = None
            deps_started = False

    return actions


def show_actions(actions):
    for action_id, action_node in actions.actions.items():
        print(f&quot;Action {action_id}:({action_node.depended_count} dependents)&quot;)
        print(f&quot;  - produces files:&quot;)
        for f in action_node.produce_files:
            print(f&quot;    - {f}&quot;)
        print(f&quot;  - depends on actions:&quot;)
        for d in action_node.depend_actions:
            print(f&quot;    - {d.action_id}&quot;)
    print(f&quot;Total actions: {len(actions.actions)}&quot;)


def mutable_circle_node(
    circle_nodes, from_action: UEActionGraphNode, to_action: UEActionGraphNode
):
    if from_action not in circle_nodes:
        circle_nodes[from_action] = dict()
    from_set = circle_nodes[from_action]
    if to_action not in from_set:
        from_set[to_action] = UEActionGraphCircle(from_action, to_action)
    return from_set[to_action]


def get_circle_node(
    circle_nodes: dict, from_action: UEActionGraphNode, to_action: UEActionGraphNode
):
    if from_action not in circle_nodes:
        return None
    return circle_nodes[from_action].get(to_action, None)


def __concat_circle_actions(
    circle_nodes: dict,
    dep_link_stack: list,
    start: UEActionGraphCircle,
):
    sz = len(dep_link_stack)
    for i in range(sz - 1):
        from_action = dep_link_stack[i]
        to_action = dep_link_stack[i + 1]
        circle_node = mutable_circle_node(circle_nodes, from_action, to_action)
        circle_node.weight += start.weight

    last_circle_node = mutable_circle_node(
        circle_nodes, dep_link_stack[-1], start.from_action
    )
    last_circle_node.weight += start.weight


def __collect_circle_actions(
    circle_nodes: dict, dep_link_stack: list, action_node: UEActionGraphNode
):
    start_idx = -1
    for i in range(len(dep_link_stack)):
        if dep_link_stack[i] == action_node:
            start_idx = i
            break
    if start_idx &lt; 0:
        raise RuntimeError(
            f&quot;Internal error: start action {action_node.action_id} not found in stack {' -&gt; '.join([str(n.action_id) for n in dep_link_stack])}&quot;
        )

    sz = len(dep_link_stack)
    first_circle_node = None
    for i in range(sz - start_idx - 1):
        from_action = dep_link_stack[i + start_idx]
        to_action = dep_link_stack[i + start_idx + 1]
        circle_node = mutable_circle_node(circle_nodes, from_action, to_action)
        circle_node.weight += from_action.depended_count / sz
        if first_circle_node is None:
            first_circle_node = circle_node

    last_circle_node = mutable_circle_node(
        circle_nodes, dep_link_stack[-1], dep_link_stack[start_idx]
    )
    last_circle_node.weight += dep_link_stack[-1].depended_count

    if start_idx &gt; 0:
        __concat_circle_actions(
            circle_nodes,
            dep_link_stack[0:start_idx],
            first_circle_node,
        )
    return dep_link_stack[start_idx:]


def __cal_circle_actions_weight(circle_nodes: dict, dep_link_stack: list):
    if len(dep_link_stack) &lt;= 1:
        return 0

    sz = len(dep_link_stack)
    ret = 0
    for i in range(sz - 1):
        from_action = dep_link_stack[i]
        to_action = dep_link_stack[i + 1]
        circle_node = mutable_circle_node(circle_nodes, from_action, to_action)
        ret += circle_node.weight
    return ret


def __dfs_scan_actions(
    actions: UEActionGraphSet,
    circle_nodes: dict,
    dep_link_dict: dict,
    dep_link_stack: list,
    action_node: UEActionGraphNode,
    show_verbose: bool = False,
):
    ret = []
    dep_link_dict[action_node.action_id] = action_node
    dep_link_stack.append(action_node)

    # 优先找短的链：这里用 DFS + 遇到环就提前返回的策略，实践里足够快
    dfs_depend_actions = []
    for dep_action in action_node.depend_actions:
        existed_chain = get_circle_node(circle_nodes, action_node, dep_action)
        if existed_chain:
            __concat_circle_actions(circle_nodes, dep_link_stack, existed_chain)
            continue

        if dep_action.action_id in dep_link_dict:
            if show_verbose:
                print(
                    f&quot;Found circle: &quot;
                    + &quot; -&gt; &quot;.join([str(n.action_id) for n in dep_link_stack])
                )
            ret.append(
                __collect_circle_actions(circle_nodes, dep_link_stack, dep_action)
            )
        else:
            dfs_depend_actions.append(dep_action)

    if not ret:
        for dep_action in dfs_depend_actions:
            res = __dfs_scan_actions(
                actions,
                circle_nodes,
                dep_link_dict,
                dep_link_stack,
                dep_action,
                show_verbose,
            )
            if res:
                ret += res
                break

    del dep_link_dict[action_node.action_id]
    del dep_link_stack[-1]

    return ret


def dfs_scan_actions(actions: UEActionGraphSet, show_verbose=False):
    circle_nodes = dict()  # (from, (to, UEActionGraphCircle))
    dep_link_dict = dict()
    dep_link_stack = []
    circle_chains = []
    for _, action_node in actions.actions.items():
        if action_node.depended_count == 0:
            continue

        if show_verbose:
            print(f&quot;Scanning action {action_node.action_id} ...&quot;)
        for circle_stack in __dfs_scan_actions(
            actions,
            circle_nodes,
            dep_link_dict,
            dep_link_stack,
            action_node,
            show_verbose,
        ):
            circle_chains.append(
                {
                    &quot;weight&quot;: __cal_circle_actions_weight(circle_nodes, circle_stack),
                    &quot;chains&quot;: circle_stack,
                }
            )

    circle_chains.sort(key=lambda x: (len(x[&quot;chains&quot;]), -x[&quot;weight&quot;]))
    for circle_chain in circle_chains:
        print(
            f&quot;Found circle chain: {' -&gt; '.join([str(x.action_id) for x in circle_chain['chains']])}&quot;
        )
        for circle_node in circle_chain[&quot;chains&quot;]:
            print(
                f&quot;  - ActionGraphNode #{circle_node.action_id} , depended: {circle_node.depended_count}, produces:&quot;
            )
            for produce in circle_node.produce_files:
                print(f&quot;    * {produce}&quot;)


def main():
    global __VERSION__

    parser = argparse.ArgumentParser(usage=&quot;%(prog)s [options...]&quot;)
    parser.add_argument(&quot;REMAINDER&quot;, nargs=argparse.REMAINDER, help=&quot;task names&quot;)
    parser.add_argument(
        &quot;-v&quot;,
        &quot;--version&quot;,
        action=&quot;store_true&quot;,
        help=&quot;show version and exit&quot;,
        dest=&quot;version&quot;,
        default=False,
    )

    parser.add_argument(
        &quot;-V&quot;,
        &quot;--verbose&quot;,
        action=&quot;store_true&quot;,
        help=&quot;show verbose&quot;,
        dest=&quot;verbose&quot;,
        default=False,
    )

    parser.add_argument(
        &quot;-i&quot;,
        &quot;--input&quot;,
        action=&quot;store&quot;,
        help=&quot;set input build log file, (use - to read from stdin)&quot;,
        dest=&quot;input&quot;,
        default=&quot;-&quot;,
    )

    options = parser.parse_args()
    if options.version:
        print(__VERSION__)
        return 0

    if options.input.strip() == &quot;-&quot;:
        log_file = sys.stdin
    else:
        log_file = try_read_file(options.input)

    actions = build_deps_from_fd(log_file)
    if options.verbose:
        show_actions(actions)

    dfs_scan_actions(actions, show_verbose=options.verbose)

    return 0


if __name__ == &quot;__main__&quot;:
    exit(main())
</code></pre><h2 id=输出解读>输出解读</h2><p>脚本输出类似如下信息：</p><ul><li><code>Found circle chain: 2282 -> 1270 -> 1503 -> 1263</code></li><li>链路上每个 action 的 <code>produces:</code> 文件列表</li></ul><p>这表明这些 action 之间存在有向环。<strong>下一步是将 action 级别的环映射回模块级别的环。</strong></p><p>常用的映射规则：</p><table><thead><tr><th>产物路径模式</th><th>对应内容</th></tr></thead><tbody><tr><td><code>.../libUnrealEditor-XXX.so</code></td><td>模块 <code>XXX</code></td></tr><tr><td><code>Engine/Plugins/.../Binaries/.../libUnrealEditor-PluginName.so</code></td><td>插件模块</td></tr><tr><td><code>.modules</code> / <code>.target</code></td><td>Target/元数据生成流程</td></tr></tbody></table><p>确认环上的产物对应哪些模块后，下一步是检查 <code>*.Build.cs</code> / <code>Target.cs</code> 中的依赖引用。</p><h2 id=使用方法>使用方法</h2><h3 id=1收集构建日志>1）收集构建日志</h3><p>将 UBT 的输出重定向到文本文件，并启用 <code>-Verbose</code> 选项以获取完整的 action 信息。</p><p><strong>Linux</strong>：</p><pre><code class=language-bash>./Engine/Build/BatchFiles/Linux/Build.sh UnrealEditor Linux Development -Verbose &gt; build.log 2&gt;&amp;1
</code></pre><p><strong>Windows PowerShell</strong>：</p><pre><code class=language-powershell>./Engine/Build/BatchFiles/Build.bat UnrealEditor Win64 Development -Verbose *&gt; build.log
</code></pre><h3 id=2运行脚本>2）运行脚本</h3><pre><code class=language-bash>python3 ue_cycle_finder.py -i build.log
</code></pre><p>支持从 stdin 读取：</p><pre><code class=language-bash>cat build.log | python3 ue_cycle_finder.py -i -
</code></pre><h2 id=效果示例>效果示例</h2><p>以上述日志为例，UBT 原始信息是：</p><blockquote><p>Action #700 depends on cyclic actions: 2282/1270/1503/1263</p></blockquote><p>真正需要的是"哪个模块与哪个模块形成环"。脚本输出环链路和 <code>produces:</code> 后，可以得到如下模块关系：</p><pre><code class=language-{mermaid}>graph LR
    Engine[Engine.so] --&gt; MovieScene[MovieScene.so]
    MovieScene --&gt; MovieSceneTracks[MovieSceneTracks.so]
    MovieSceneTracks --&gt; TimeManagement[TimeManagement.so]
    TimeManagement --&gt; Engine
</code></pre><p>排障方式从：</p><ul><li>面对大量 <code>Action #xxxx</code> 无从下手</li></ul><p>转变为：</p><ul><li>在 <code>Engine</code> / <code>MovieScene</code> / <code>MovieSceneTracks</code> / <code>TimeManagement</code> 几个明确的模块间查找依赖引用</li></ul><h2 id=依赖环的常见形态>依赖环的常见形态</h2><p>实际工程中，循环依赖不只存在"单一简单环"这一种形态。明确形态有助于确定拆解优先级。</p><h3 id=1单一简单环>1）单一简单环</h3><pre><code class=language-{mermaid}>graph LR
    A[ModuleA] --&gt; B[ModuleB]
    B --&gt; C[ModuleC]
    C --&gt; A
</code></pre><p>这种情况较为直观：打断任意一条依赖边即可使图满足拓扑排序。</p><h3 id=2多个环共享链路>2）多个环共享链路</h3><p>这种情况更常见，也更值得优先处理。以下示例包含两个环：</p><ul><li>环 1：<code>A -> B -> C -> A</code></li><li>环 2：<code>D -> B -> C -> D</code></li></ul><p>它们<strong>共享链路</strong> <code>B -> C</code>。</p><pre><code class=language-{mermaid}>graph LR
    A[ModuleA] --&gt; B[ModuleB]
    B --&gt; C[ModuleC]
    C --&gt; A

    D[ModuleD] --&gt; B
    C --&gt; D
</code></pre><p>这类结构提供了高性价比的排障策略：</p><ul><li>如果在共享链路上找到"可替换/可降级/可抽象"的依赖（如仅为 include，或可下沉到 Common/Interface 模块）</li><li><strong>拆掉共享链路可同时消除多个环</strong></li></ul><p>当脚本输出多个环时，应优先观察是否存在共享的 action/产物——共享链路往往意味着更少的改动和更大的收益。</p><h3 id=3共享更长的链路>3）共享更长的链路</h3><p>以下示例中两个环都经过 <code>B -> C -> E</code>：</p><pre><code class=language-{mermaid}>graph LR
    A[ModuleA] --&gt; B[ModuleB]
    B --&gt; C[ModuleC]
    C --&gt; E[ModuleE]
    E --&gt; A

    D[ModuleD] --&gt; B
    E --&gt; D
</code></pre><p>如果 <code>B -> C</code>、<code>C -> E</code>、<code>E -> ...</code> 中某一段是"非必要链接依赖"（如仅为头文件可见），拆掉它即可同时断开多个环。</p><blockquote><p><strong>实践建议</strong>：优先从共享链路中"最弱"的依赖入手（如 include-only、工具模块、纯声明引用），避免拆解真正必需的核心链接依赖。</p></blockquote><h2 id=打破循环依赖的方法>打破循环依赖的方法</h2><p>工具的作用是更清晰地定位环，实际拆解仍需回到 UE 的模块依赖设计。</p><p>以下按优先级总结常用策略。</p><h3 id=1抽取公共模块推荐>1）抽取公共模块（推荐）</h3><p>如果模块 A 和 B 互相依赖只是为了共享少量代码或类型：</p><ul><li>将共享部分抽取到底层模块 <code>Common</code></li><li>A、B 均依赖 <code>Common</code></li></ul><p>这是最干净、长期收益最高的方案：降低耦合、明确编译依赖。</p><h3 id=2引入接口模块>2）引入接口模块</h3><p>适用场景：A 需要调用 B 的能力，但不应强依赖 B 的实现细节。</p><p>做法：</p><ul><li>定义 <code>BInterface</code> 模块，仅包含纯接口和轻量声明（尽量使用前向声明）</li><li>A 只依赖 <code>BInterface</code></li><li>B 依赖 <code>BInterface</code> 并提供实现（通过模块加载、Subsystem 注册或工厂注入等方式在运行时注入）</li></ul><h3 id=3降级为-includepathmodulenames>3）降级为 IncludePathModuleNames</h3><p>如果依赖仅用于 include 头文件而不需要链接，可将其从 <code>PrivateDependencyModuleNames</code> / <code>PublicDependencyModuleNames</code> 降级为 <code>PrivateIncludePathModuleNames</code> / <code>PublicIncludePathModuleNames</code>，避免将"头文件可见"升级为"链接依赖"。</p><h3 id=4显式声明循环依赖兜底方案>4）显式声明循环依赖（兜底方案）</h3><p>如果短期无法拆解，UBT 曾提供显式声明循环依赖的机制：<code>CircularlyReferencedDependentModules</code>。Epic 官方知识库建议：优先移除循环依赖，无法移除时再显式声明以规避构建错误 <a href=https://dev.epicgames.com/community/learning/knowledge-base/kj4B/unreal-engine-workaround-for-circular-dependencies>1</a>。</p><blockquote><p><strong>注意</strong>：不同 UE 版本对此字段的支持可能有所调整。在较新版本的 UE 中，该接口已被移除，强制要求解除循环依赖——这对链接优化也有显著好处。</p></blockquote><h2 id=局限性与改进方向>局限性与改进方向</h2><p>本脚本刻意保持轻量，存在以下局限：</p><ul><li>仅分析日志中的 cyclic actions 段落，不复原完整的 UBT ActionGraph</li><li>权重为启发式排序，不保证给出全局最优的"最小拆边集合"</li><li>DFS 实现偏向快速找出短链，而非枚举所有环</li></ul><p>后续可考虑的增强方向：</p><ol><li>输出 <code>.dot</code> / Graphviz 格式以便可视化</li><li>在候选拆边上进一步提示：打印 <code>from produces -> to produces</code> 作为建议检查的依赖对</li></ol><h2 id=总结>总结</h2><p>本文的核心经验：</p><ul><li>UBT 报错的 ActionGraph 层信息对机器友好，对人不友好</li><li>将日志结构化为图并进行轻量分析，能显著降低排障成本</li></ul><p>工具本身并不复杂，但能将问题从"海量 action id"收敛到"几个明确模块之间的一条环"。之后即可用常规工程手段（抽取模块、接口隔离、降级依赖）完成拆解。</p><p>也欢迎有兴趣的小伙伴们互相交流探讨。</p></div><hr><footer class=article-footer><div class="article-panel-footer article-meta article-footer clearfix"><span class=article-meta-left><ol><li><a href=//owent.net/categories/article.html>Article</a></li><li><a href=//owent.net/categories/blablabla.html>Blablabla</a></li></ol></span><span class=article-meta-right><time datetime=2025-12-21T17:15:45.000+00:00 itemprop=datePublished>2025-12-21</time></span>
<span class=clearfix></span></div><div class=article-tags><ul class=article-tag-list><li class=article-tag-list-item><a href=//owent.net/tags/ue.html>UE</a></li><li class=article-tag-list-item><a href=//owent.net/tags/unreal-engine.html>Unreal Engine</a></li><li class=article-tag-list-item><a href=//owent.net/tags/ubt.html>UBT</a></li><li class=article-tag-list-item><a href=//owent.net/tags/unrealbuildtool.html>UnrealBuildTool</a></li><li class=article-tag-list-item><a href=//owent.net/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html>循环依赖</a></li><li class=article-tag-list-item><a href=//owent.net/tags/%E6%A8%A1%E5%9D%97%E5%8C%96.html>模块化</a></li></ul></div></footer><div class="ads-placeholder ads-container"><ins class="adsbygoogle ads_infeed" style=display:block data-ad-client=ca-pub-8180054975285991 data-ad-slot=5599802929 data-ad-format="rectangle, horizontal" data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div><hr><nav id=article-nav><ul class=pagination><li class=page-item><a class=page-link id=article-nav-newer class=article-nav-link-wrap href=//owent.net/2025/2507.html>上一篇<strong>UE使用CodeChecker和clang-tidy生成静态分析报告</strong></a></li><li class=page-item><a class=page-link id=article-nav-older class=article-nav-link-wrap href=//owent.net/2025/2505.html>下一篇<strong>C++小协程栈和临时变量及作用域的栈溢出问题分析</strong></a></li></ul></nav><hr><script src=https://utteranc.es/client.js repo=owent/blog-website issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></div></section></div><footer id=footer><div class=outer><div id=footer-info class="inner clearfix"><strong id=footer-left class="float-left float-start"><a rel=license href=https://github.com/owent/blog-hugo/blob/master/LICENSE.md><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png></a>2026&nbsp;owent
</strong><strong id=footer-right class="float-right float-end"><a href=https://beian.miit.gov.cn/ target=_blank>沪ICP备2022003252号</a>&nbsp;&nbsp;<a href=https://github.com/owent/blog-hugo target=_blank>本站源码</a>,
发布者 <a href=https://gohugo.io/ target=_blank>Hugo</a>,
主题 <a href=https://github.com/owent/hugo-theme-distinctionpp target=_blank>distinctionpp</a>
</strong><span class=clearfix></span></div></div></footer></div><script type=importmap>
{"imports":{"@popperjs/core":"https://esm.run/popper.js","bootstrap":"https://esm.run/bootstrap","mermaid":"https://esm.sh/mermaid","react":"https://esm.run/react","react-bootstrap":"https://esm.run/react-bootstrap"}}
</script><script type=module>// import * as Popper from "@popperjs/core";// import * as bootstrap from "bootstrap";
// import React from "react";

        
</script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/accesslog.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/armasm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/awk.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/basic.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/bnf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/capnproto.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/cmake.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/d.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/dockerfile.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/dos.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/erlang.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ebnf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/latex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/llvm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/lua.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/powershell.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/protobuf.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/profile.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/vim.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/x86asm.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/yaml.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/vs2015.min.css",document.querySelector("head").appendChild(t),window.JSON?hljs.configure(JSON.parse('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}')):hljs.configure(evel('{"ignoreunescapedhtml":true,"languages":{},"tabreplace":"    ","throwunescapedhtml":false,"usebr":false}'));const n={};for(const e of hljs.listLanguages())n[e.toLowerCase()]=!0;for(const e of document.querySelectorAll("pre>code"))try{if(e.className.match(/\bmermaid\b/i)){e.classList.add("mermaid");continue}if(e.className.match(/\bexcalidraw\b/i)){e.classList.add("excalidraw-root");continue}if(e.className.match(/\bdrawio\b/i)){e.classList.add("drawio-root"),e.classList.add("mxgraph");continue}if(e.className.match(/\bchart(js)?\b/i)){e.classList.add("chartjs-container");continue}if(e.className.match(/\bnohighlight\b/i))continue;const t=e.className.match(/language-([^\s]+)/i);if(t&&t.length>=2&&hljs.getLanguage(t[1]))hljs.highlightElement(e);else{const t=hljs.highlightAuto(e.innerText,hljs.listLanguages());t&&t.value&&(e.innerHTML=t.value,e.classList.add("hljs"))}}catch(e){window.console&&console.log(e.toString()+`\r
Maybe can not detect the language`)}})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PQEY77BYG1"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PQEY77BYG1")}</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",e=>{const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css",document.querySelector("head").appendChild(t),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><script type=module>
import mermaid from "mermaid";
const config = {
    theme: 'neutral',
    logLevel: 'fatal',
    securityLevel: 'loose', 
    startOnLoad: false, 
    arrowMarkerAbsolute: false,
    

};
mermaid.initialize(config);


(async () => {
    const pendingElements = document.querySelectorAll('.mermaid-pending[data-mermaid-src]');
    for (const el of pendingElements) {
        const src = el.getAttribute('data-mermaid-src');
        if (!src) continue;
        try {
            const response = await fetch(src);
            if (!response.ok) {
                throw new Error(`Failed to fetch ${src}: ${response.status}`);
            }
            const content = await response.text();
            el.textContent = content;
            el.classList.remove('mermaid-pending');
        } catch (e) {
            if (window.console) {
                console.error("Failed to fetch mermaid file:", src, e);
            }
            el.textContent = `Failed to load: ${src}`;
            el.classList.remove('mermaid');
            el.classList.remove('mermaid-pending');
        }
    }
    
    await mermaid.run();
})();
</script><script type=text/javascript>var _hmt=_hmt||[];(function(){var t,n,e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6a0daf8d58889f1cf55a353867bfdbb0",t=document.getElementsByTagName("script"),n=document.getElementsByTagName("script")[t.length-1],n.parentNode.appendChild(e)})()</script></div></body></html>