---
author: owent
categories:
  - Article
  - Blablabla
date: 2025-08-22 17:15:45
draft: true
id: 2506
tags: 
  - UE
  - unreal
  - unreal engine
title: 找出UE的循环依赖
type: post
---

## 背景


## 分析日志

```basic
Action #700: /bin/sh
    with arguments:  "/data/Stream_Depot/Client/Engine/Intermediate/Build/Linux/x64/UnrealEditor/Development/Link-libUnrealEditor-ActorSequence.so.link.sh"
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-Core.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-CoreUObject.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-Engine.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieScene.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieSceneTracks.so
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-TimeManagement.so
    depends on: /data/Stream_Depot/Client/Engine/Plugins/MovieScene/ActorSequence/Intermediate/Build/Linux/x64/UnrealEditor/Development/ActorSequence/Module.ActorSequence.cpp.o
    depends on: /data/Stream_Depot/Client/Engine/Plugins/MovieScene/ActorSequence/Intermediate/Build/Linux/x64/UnrealEditor/Development/ActorSequence/libUnrealEditor-ActorSequence.so.rsp
    produces:   /data/Stream_Depot/Client/Engine/Plugins/MovieScene/ActorSequence/Binaries/Linux/libUnrealEditor-ActorSequence.so
    Depends on cyclic actions:
        2282 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-Engine.so)
        1270 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieScene.so)
        1503 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-MovieSceneTracks.so)
        1263 (produces: /data/Stream_Depot/Client/Engine/Binaries/Linux/libUnrealEditor-TimeManagement.so)
```

```basic
Action #5333: /data/Stream_Depot/Client/Engine/Binaries/ThirdParty/DotNet/6.0.302/linux/dotnet
    with arguments: "/data/Stream_Depot/Client/Engine/Binaries/DotNET/UnrealBuildTool/UnrealBuildTool.dll" -Mode=WriteMetadata -Input="/data/Stream_Depot/Client/Engine/Intermediate/Build/Linux/x64/UnrealEditor/Development/TargetMetadata.dat" -Version=2
    depends on: /data/Stream_Depot/Client/Engine/Binaries/Linux/UnrealEditor.version
    depends on: /data/Stream_Depot/Client/Engine/Intermediate/Build/Linux/x64/UnrealEditor/Development/TargetMetadata.dat
    produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/UnrealEditor.target
    Depends on cyclic actions:
        5332
            produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/Android/UnrealEditor.modules
            produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/Linux/UnrealEditor.modules
            produces:   /data/Stream_Depot/Client/Engine/Binaries/Linux/LinuxArm64/UnrealEditor.modules
            ...
```

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import codecs
import re
import argparse
import os
import sys

from numpy import sort

__VERSION__ = "1.0.0"

UE_LOG_ACTION_START = re.compile("^\\s*Action #\\s*(?P<ACTION_ID>\\d+)\\s*:")
UE_LOG_ACTION_PRODUCE = re.compile("^\\s\\s*produces\\s*:\\s*(?P<PRODUCE_FILE>.+)$")
UE_LOG_ACTION_DEP_START = re.compile(
    "^\\s\\s*Depends\\s+on\\s+cyclic\\s+actions", re.IGNORECASE
)
UE_LOG_ACTION_DEP_ID = re.compile(
    "^\\s\\s\\s*(?P<ACTION_ID>\\d+)\\s*(\\(\\s*produces\\s*:|$)"
)


class UEActionGraphNode:
    def __init__(self, action_id):
        self.action_id = action_id
        self.produce_files = []
        self.depend_actions = set()
        self.depended_count = 0

    def add_produce_file(self, file_path):
        if file_path not in self.produce_files:
            self.produce_files.append(file_path)

    def add_depend_action(self, action):
        if action not in self.depend_actions:
            self.depend_actions.add(action)
            action.depended_count += 1


class UEActionGraphSet:
    def __init__(self):
        self.actions = dict()

    def mutable_action(self, action_id):
        if action_id not in self.actions:
            self.actions[action_id] = UEActionGraphNode(action_id)
        return self.actions[action_id]

    def get_action(self, action_id):
        return self.actions.get(action_id, None)

    def __getitem__(self, action_id):
        return self.get_action(action_id)

    def __contains__(self, action_id):
        return action_id in self.actions


class UEActionGraphCircle:
    def __init__(self, from_action, to_action):
        self.from_action = from_action
        self.to_action = to_action
        self.weight = 0


def try_read_file(file_path):
    _err = None
    if not os.path.isabs(file_path):
        file_path = os.path.join(file_path)
    for try_encoding in ["utf-8", "utf-8-sig", "GB18030"]:
        try:
            ret = codecs.open(file_path, "r", encoding=try_encoding)
            return ret
        except Exception as e:
            if _err is None:
                _err = e
            if not os.path.exists(file_path):
                break
    raise _err


def build_deps_from_fd(file):
    last_action_node = None
    actions = UEActionGraphSet()
    deps_started = False
    for line in file:
        mat = UE_LOG_ACTION_START.match(line)
        if mat:
            last_action_node = actions.mutable_action(int(mat.group("ACTION_ID")))
            deps_started = False
            continue

        if last_action_node is not None:
            mat = UE_LOG_ACTION_DEP_START.match(line)
            if mat:
                deps_started = True
                continue

        if last_action_node is not None:
            if deps_started:
                mat = UE_LOG_ACTION_DEP_ID.match(line)
                if mat:
                    dep_action_id = int(mat.group("ACTION_ID"))
                    last_action_node.add_depend_action(
                        actions.mutable_action(dep_action_id)
                    )
                    continue
            else:
                mat = UE_LOG_ACTION_PRODUCE.match(line)
                if mat:
                    produce_file = mat.group("PRODUCE_FILE")
                    last_action_node.add_produce_file(produce_file)
                    continue

        if (
            last_action_node is not None
            and line.strip() == ""
            or (line[0] != " " and line[0] != "\t")
        ):
            last_action_node = None
            deps_started = False

    return actions


def show_actions(actions):
    for action_id, action_node in actions.actions.items():
        print(f"Action {action_id}:({action_node.depended_count} dependents)")
        print(f"  - produces files:")
        for f in action_node.produce_files:
            print(f"    - {f}")
        print(f"  - depends on actions:")
        for d in action_node.depend_actions:
            print(f"    - {d.action_id}")
    print(f"Total actions: {len(actions.actions)}")


def mutable_circle_node(
    circle_nodes, from_action: UEActionGraphNode, to_action: UEActionGraphNode
):
    if from_action not in circle_nodes:
        circle_nodes[from_action] = dict()
    from_set = circle_nodes[from_action]
    if to_action not in from_set:
        from_set[to_action] = UEActionGraphCircle(from_action, to_action)
    return from_set[to_action]


def get_circle_node(
    circle_nodes: dict, from_action: UEActionGraphNode, to_action: UEActionGraphNode
):
    if from_action not in circle_nodes:
        return None
    return circle_nodes[from_action].get(to_action, None)


def __concat_circle_actions(
    circle_nodes: dict,
    dep_link_stack: list,
    start: UEActionGraphCircle,
):
    sz = len(dep_link_stack)
    for i in range(sz - 1):
        from_action = dep_link_stack[i]
        to_action = dep_link_stack[i + 1]
        circle_node = mutable_circle_node(circle_nodes, from_action, to_action)
        circle_node.weight += start.weight

    last_circle_node = mutable_circle_node(
        circle_nodes, dep_link_stack[-1], start.from_action
    )
    last_circle_node.weight += start.weight


def __collect_circle_actions(
    circle_nodes: dict, dep_link_stack: list, action_node: UEActionGraphNode
):
    start_idx = -1
    for i in range(len(dep_link_stack)):
        if dep_link_stack[i] == action_node:
            start_idx = i
            break
    if start_idx < 0:
        raise RuntimeError(
            f"Internal error: start action {action_node.action_id} not found in stack {' -> '.join([str(n.action_id) for n in dep_link_stack])}"
        )

    sz = len(dep_link_stack)
    first_circle_node = None
    for i in range(sz - start_idx - 1):
        from_action = dep_link_stack[i + start_idx]
        to_action = dep_link_stack[i + start_idx + 1]
        circle_node = mutable_circle_node(circle_nodes, from_action, to_action)
        circle_node.weight += from_action.depended_count / sz
        if first_circle_node is None:
            first_circle_node = circle_node

    last_circle_node = mutable_circle_node(
        circle_nodes, dep_link_stack[-1], dep_link_stack[start_idx]
    )
    last_circle_node.weight += dep_link_stack[-1].depended_count

    if start_idx > 0:
        __concat_circle_actions(
            circle_nodes,
            dep_link_stack[0:start_idx],
            first_circle_node,
        )
    return dep_link_stack[start_idx:]


def __cal_circle_actions_weight(circle_nodes: dict, dep_link_stack: list):
    if len(dep_link_stack) <= 1:
        return 0

    sz = len(dep_link_stack)
    ret = 0
    for i in range(sz - 1):
        from_action = dep_link_stack[i]
        to_action = dep_link_stack[i + 1]
        circle_node = mutable_circle_node(circle_nodes, from_action, to_action)
        ret += circle_node.weight
    return ret


def __dfs_scan_actions(
    actions: UEActionGraphSet,
    circle_nodes: dict,
    dep_link_dict: dict,
    dep_link_stack: list,
    action_node: UEActionGraphNode,
    show_verbose: bool = False,
):
    ret = []
    dep_link_dict[action_node.action_id] = action_node
    dep_link_stack.append(action_node)

    # 优先找短的链(BFS)
    dfs_depend_actions = []
    for dep_action in action_node.depend_actions:
        existed_chain = get_circle_node(circle_nodes, action_node, dep_action)
        if existed_chain:
            __concat_circle_actions(circle_nodes, dep_link_stack, existed_chain)
            continue

        if dep_action.action_id in dep_link_dict:
            if show_verbose:
                print(
                    f"Found circle: "
                    + " -> ".join([str(n.action_id) for n in dep_link_stack])
                )
            ret.append(
                __collect_circle_actions(circle_nodes, dep_link_stack, dep_action)
            )
        else:
            dfs_depend_actions.append(dep_action)

    if not ret:
        for dep_action in dfs_depend_actions:
            res = __dfs_scan_actions(
                actions,
                circle_nodes,
                dep_link_dict,
                dep_link_stack,
                dep_action,
                show_verbose,
            )
            if res:
                ret += res
                break

    del dep_link_dict[action_node.action_id]
    del dep_link_stack[-1]

    return ret


def dfs_scan_actions(actions: UEActionGraphSet, show_verbose=False):
    circle_nodes = dict()  # (from, (to, UEActionGraphCircle))
    dep_link_dict = dict()
    dep_link_stack = []
    circle_chains = []
    for _, action_node in actions.actions.items():
        if action_node.depended_count == 0:
            continue

        if show_verbose:
            print(f"Scanning action {action_node.action_id} ...")
        for circle_stack in __dfs_scan_actions(
            actions,
            circle_nodes,
            dep_link_dict,
            dep_link_stack,
            action_node,
            show_verbose,
        ):
            circle_chains.append(
                {
                    "weight": __cal_circle_actions_weight(circle_nodes, circle_stack),
                    "chains": circle_stack,
                }
            )

    circle_chains.sort(key=lambda x: (len(x["chains"]), -x["weight"]))
    for circle_chain in circle_chains:
        print(
            f"Found circle chain: {' -> '.join([str(x.action_id) for x in circle_chain['chains']])}"
        )
        for circle_node in circle_chain["chains"]:
            print(
                f"  - ActionGraphNode #{circle_node.action_id} , depended: {circle_node.depended_count}, produces:"
            )
            for produce in circle_node.produce_files:
                print(f"    * {produce}")


def main():
    global __VERSION__

    parser = argparse.ArgumentParser(usage="%(prog)s [options...]")
    parser.add_argument("REMAINDER", nargs=argparse.REMAINDER, help="task names")
    parser.add_argument(
        "-v",
        "--version",
        action="store_true",
        help="show version and exit",
        dest="version",
        default=False,
    )

    parser.add_argument(
        "-V",
        "--verbose",
        action="store_true",
        help="show verbose",
        dest="verbose",
        default=False,
    )

    parser.add_argument(
        "-i",
        "--input",
        action="store",
        help="set input build log file, (use - to read from stdin)",
        dest="input",
        default="-",
    )

    options = parser.parse_args()
    if options.version:
        print(__VERSION__)
        return 0

    if options.input.strip() == "-":
        log_file = sys.stdin
    else:
        log_file = try_read_file(options.input)

    actions = build_deps_from_fd(log_file)
    if options.verbose:
        show_actions(actions)

    dfs_scan_actions(actions, show_verbose=options.verbose)

    return 0


if __name__ == "__main__":
    exit(main())
```

## 最后

[1]: https://fmt.dev/
[2]: https://en.cppreference.com/w/cpp/utility/format.html
